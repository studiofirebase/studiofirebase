"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function (IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item) => {\n        for (const [key, value] of Object.entries(item)) {\n            switch (key) {\n                case 'uninterpreted_option':\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: [],\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLFlBQVk7QUFDek0sa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz9hZDYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTkNZX1VOS05PV05cIl0gPSBcIklERU1QT1RFTkNZX1VOS05PV05cIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xufSkoSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCB8fCAoZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0ge30pKTtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIG9iai51bmludGVycHJldGVkX29wdGlvbi5wdXNoKGl0ZW0udW5pbnRlcnByZXRlZF9vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge1xuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaWRlbXBvdGVuY3lfbGV2ZWw6IElkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTixcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgb3B0aW9uczogbWFwTWV0aG9kT3B0aW9ucyhtZXRob2QucGFyc2VkT3B0aW9ucyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2UsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XG4gICAgICAgIGRlZlttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudW1EZWZpbml0aW9uKGVudW1UeXBlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBlbnVtRGVzY3JpcHRvciA9IGVudW1UeXBlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRW51bURlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IGVudW1EZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KGVudW1EZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlNlcnZpY2UsIG5hbWU6IHN0cmluZywgb3B0aW9uczpcbiAqIE9wdGlvbnMpOiBTZXJ2aWNlRGVmaW5pdGlvbjsgZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlR5cGUsXG4gKiBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiBNZXNzYWdlVHlwZURlZmluaXRpb247IGZ1bmN0aW9uXG4gKiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuRW51bSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTpcbiAqIEVudW1UeXBlRGVmaW5pdGlvbjtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW51bURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG1pc21hdGNoIGluIHJlZmxlY3Rpb24gb2JqZWN0IGhhbmRsaW5nJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JMaXN0ID0gcm9vdC50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpLmZpbGU7XG4gICAgY29uc3QgYnVmZmVyTGlzdCA9IGRlc2NyaXB0b3JMaXN0Lm1hcCh2YWx1ZSA9PiBCdWZmZXIuZnJvbShkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yUHJvdG8uZW5jb2RlKHZhbHVlKS5maW5pc2goKSkpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIG9ial0gb2YgZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKHJvb3QsICcnKSkge1xuICAgICAgICBkZWZbbmFtZV0gPSBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgYnVmZmVyTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgcm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbURlc2NyaXB0b3IoZGVjb2RlZERlc2NyaXB0b3JTZXQpO1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKTtcbn1cbi8qKlxuICogTG9hZCBhIC5wcm90byBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICogQHBhcmFtIGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlIHBhdGhzIHRvIGxvYWQuIENhbiBiZSBhbiBhYnNvbHV0ZSBwYXRoXG4gKiAgICAgb3IgcmVsYXRpdmUgdG8gYW4gaW5jbHVkZSBwYXRoLlxuICogQHBhcmFtIG9wdGlvbnMua2VlcENhc2UgUHJlc2VydmUgZmllbGQgbmFtZXMuIFRoZSBkZWZhdWx0IGlzIHRvIGNoYW5nZSB0aGVtXG4gKiAgICAgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSBvcHRpb25zLmxvbmdzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBsb25nYCB2YWx1ZXMuXG4gKiAgICAgVmFsaWQgb3B0aW9ucyBhcmUgYE51bWJlcmAgYW5kIGBTdHJpbmdgLiBEZWZhdWx0cyB0byBhIGBMb25nYCBvYmplY3QgdHlwZVxuICogICAgIGZyb20gYSBsaWJyYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMuZW51bXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGVudW1gIHZhbHVlcy5cbiAqICAgICBUaGUgb25seSB2YWxpZCBvcHRpb24gaXMgYFN0cmluZ2AuIERlZmF1bHRzIHRvIHRoZSBudW1lcmljIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuYnl0ZXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGJ5dGVzYFxuICogICAgIHZhbHVlcy4gVmFsaWQgb3B0aW9ucyBhcmUgYEFycmF5YCBhbmQgYFN0cmluZ2AuIFRoZSBkZWZhdWx0IGlzIHRvIHVzZVxuICogICAgIGBCdWZmZXJgLlxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHMgU2V0IGRlZmF1bHQgdmFsdWVzIG9uIG91dHB1dCBvYmplY3RzLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5hcnJheXMgU2V0IGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyBhcnJheSB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9iamVjdHMgU2V0IGVtcHR5IG9iamVjdHMgZm9yIG1pc3Npbmcgb2JqZWN0IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub25lb2ZzIFNldCB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgdG8gdGhlIHByZXNlbnQgZmllbGQnc1xuICogICAgIG5hbWVcbiAqIEBwYXJhbSBvcHRpb25zLmpzb24gUmVwcmVzZW50IEluZmluaXR5IGFuZCBOYU4gYXMgc3RyaW5ncyBpbiBmbG9hdCBmaWVsZHMsXG4gKiAgICAgYW5kIGF1dG9tYXRpY2FsbHkgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5BbnkgdmFsdWVzLlxuICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZURpcnMgUGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRlZCBgLnByb3RvYCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9ucykoZmlsZW5hbWUsIG9wdGlvbnMpLnRoZW4obG9hZGVkUm9vdCA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMpKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbUpTT04oanNvbik7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcbigwLCB1dGlsXzEuYWRkQ29tbW9uUHJvdG9zKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkI7QUFDM0YsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsd0NBQXdDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBcUM7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTRDO0FBQ3JGLG9DQUFvQyxtQkFBTyxDQUFDLDJIQUFnRDtBQUM1RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanM/NzkwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBQcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xuZnVuY3Rpb24gYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBpbmNsdWRlUGF0aHMpIHtcbiAgICBjb25zdCBvcmlnaW5hbFJlc29sdmVQYXRoID0gcm9vdC5yZXNvbHZlUGF0aDtcbiAgICByb290LnJlc29sdmVQYXRoID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRpcmVjdG9yeSBvZiBpbmNsdWRlUGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnMuYWNjZXNzU3luYyhmdWxsUGF0aCwgZnMuY29uc3RhbnRzLlJfT0spO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGAke3RhcmdldH0gbm90IGZvdW5kIGluIGFueSBvZiB0aGUgaW5jbHVkZSBwYXRocyAke2luY2x1ZGVQYXRoc31gKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzb2x2ZVBhdGgob3JpZ2luLCB0YXJnZXQpO1xuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIGluY2x1ZGVEaXJzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5JykpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBhd2FpdCByb290LmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBsb2FkZWRSb290O1xufVxuZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnM7XG5mdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY2x1ZGVEaXJzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IHJvb3QubG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBsb2FkZWRSb290O1xufVxuZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYztcbi8qKlxuICogTG9hZCBHb29nbGUncyB3ZWxsLWtub3duIHByb3RvIGZpbGVzIHRoYXQgYXJlbid0IGV4cG9zZWQgYnkgUHJvdG9idWYuanMuXG4gKi9cbmZ1bmN0aW9uIGFkZENvbW1vblByb3RvcygpIHtcbiAgICAvLyBQcm90b2J1Zi5qcyBleHBvc2VzOiBhbnksIGR1cmF0aW9uLCBlbXB0eSwgZmllbGRfbWFzaywgc3RydWN0LCB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdyYXBwZXJzLiBjb21waWxlci9wbHVnaW4gaXMgZXhjbHVkZWQgaW4gUHJvdG9idWYuanMgYW5kIGhlcmUuXG4gICAgLy8gVXNpbmcgY29uc3RhbnQgc3RyaW5ncyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRvb2xzIGxpa2UgV2VicGFja1xuICAgIGNvbnN0IGFwaURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9hcGkuanNvbicpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5qc29uJyk7XG4gICAgY29uc3Qgc291cmNlQ29udGV4dERlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5qc29uJyk7XG4gICAgY29uc3QgdHlwZURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi90eXBlLmpzb24nKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ2FwaScsIGFwaURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ2Rlc2NyaXB0b3InLCBkZXNjcmlwdG9yRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbignc291cmNlX2NvbnRleHQnLCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbigndHlwZScsIHR5cGVEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG59XG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGFkZENvbW1vblByb3Rvcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerAdminService = registerAdminService;\nexports.addAdminServicesToServer = addAdminServicesToServer;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\n}\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9hZG1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanM/MWE5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7XG5jb25zdCByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBZG1pblNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzKSB7XG4gICAgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMucHVzaCh7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9KTtcbn1cbmZ1bmN0aW9uIGFkZEFkbWluU2VydmljZXNUb1NlcnZlcihzZXJ2ZXIpIHtcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcbiAgICAgICAgc2VydmVyLmFkZFNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24oKSwgZ2V0SGFuZGxlcnMoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRtaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackoffTimeout = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'backoff';\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */\n        this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */\n        this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */\n        this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */\n        this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */\n        this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */\n        this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */\n        this.endTime = new Date();\n        this.id = BackoffTimeout.getNextId();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.trace('constructed initialDelay=' + this.initialDelay + ' multiplier=' + this.multiplier + ' jitter=' + this.jitter + ' maxDelay=' + this.maxDelay);\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    static getNextId() {\n        return this.nextId++;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '{' + this.id + '} ' + text);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.trace('runTimer(delay=' + delay + ')');\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + delay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(() => {\n            this.trace('timer fired');\n            this.running = false;\n            this.callback();\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.trace('runOnce()');\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        this.trace('stop()');\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */\n    reset() {\n        this.trace('reset() running=' + this.running);\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            }\n            else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */\n    getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\nBackoffTimeout.nextId = 0;\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpQkFBaUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanM/NTJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdiYWNrb2ZmJztcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEyMDAwMDtcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xuLyoqXG4gKiBHZXQgYSBudW1iZXIgdW5pZm9ybWx5IGF0IHJhbmRvbSBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4KVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwb25lbnRpYWwgYmFja29mZiBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhEZWxheSA9IE1BWF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcbiAgICAgICAgICogYXBwbHlpbmcgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXG4gICAgICAgICAqIG90aGVyIGFzeW5jIG9wZXJhdGlvbiBpcyBkb2luZyBzby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcHByb3hpbWF0ZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdpbGwgZW5kLiBPbmx5IHZhbGlkXG4gICAgICAgICAqIGlmIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuaWQgPSBCYWNrb2ZmVGltZW91dC5nZXROZXh0SWQoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnY29uc3RydWN0ZWQgaW5pdGlhbERlbGF5PScgKyB0aGlzLmluaXRpYWxEZWxheSArICcgbXVsdGlwbGllcj0nICsgdGhpcy5tdWx0aXBsaWVyICsgJyBqaXR0ZXI9JyArIHRoaXMuaml0dGVyICsgJyBtYXhEZWxheT0nICsgdGhpcy5tYXhEZWxheSk7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXROZXh0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJZCsrO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ3snICsgdGhpcy5pZCArICd9ICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcnVuVGltZXIoZGVsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50cmFjZSgncnVuVGltZXIoZGVsYXk9JyArIGRlbGF5ICsgJyknKTtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMuZW5kVGltZS5zZXRNaWxsaXNlY29uZHModGhpcy5lbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgZGVsYXkpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd0aW1lciBmaXJlZCcpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZikge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXG4gICAgICovXG4gICAgcnVuT25jZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncnVuT25jZSgpJyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcih0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNvbnN0IG5leHRCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5uZXh0RGVsYXkgKiB0aGlzLm11bHRpcGxpZXIsIHRoaXMubWF4RGVsYXkpO1xuICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSBuZXh0QmFja29mZiAqIHRoaXMuaml0dGVyO1xuICAgICAgICB0aGlzLm5leHREZWxheSA9XG4gICAgICAgICAgICBuZXh0QmFja29mZiArIHVuaWZvcm1SYW5kb20oLWppdHRlck1hZ25pdHVkZSwgaml0dGVyTWFnbml0dWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIuIFRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgdW50aWwgYHJ1bk9uY2VgIGlzIGNhbGxlZFxuICAgICAqIGFnYWluLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0b3AoKScpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBkZWxheSB0aW1lIHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJZiB0aGUgdGltZXIgaXMgc3RpbGwgcnVubmluZyxcbiAgICAgKiByZXRyb2FjdGl2ZWx5IGFwcGx5IHRoYXQgcmVzZXQgdG8gdGhlIGN1cnJlbnQgdGltZXIuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3Jlc2V0KCkgcnVubmluZz0nICsgdGhpcy5ydW5uaW5nKTtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIG5ld0VuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKG5ld0VuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgICAgIGlmIChub3cgPCBuZXdFbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lcihuZXdFbmRUaW1lLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgcmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQgbm90IGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gZmFsc2U7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcHByb3hpbWF0ZSB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgdGltZXIgd2lsbCBmaXJlLiBPbmx5IHZhbGlkIGlmXG4gICAgICogdGhpcy5pc1J1bm5pbmcoKSBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldEVuZFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFRpbWU7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xuQmFja29mZlRpbWVvdXQubmV4dElkID0gMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error('Headers not set by metadata plugin'));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then(headers => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, err => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzPzFlYWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoJ2dldFJlcXVlc3RIZWFkZXJzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXG4gKi9cbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSBnaXZlbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlc1xuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxuICAgICAqIGdlbmVyYXRlcyBhIE1ldGFkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGVzZSBvcHRpb25zLCB3aGljaCBpcyBwYXNzZWQgYmFja1xuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBDYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0SGVhZGVycyhvcHRpb25zLnNlcnZpY2VfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSGVhZGVycyBub3Qgc2V0IGJ5IG1ldGFkYXRhIHBsdWdpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbihoZWFkZXJzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcbmNsYXNzIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRzID0gY3JlZHM7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoY3JlZCA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICBiYXNlLm1lcmdlKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlZHMuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUuX2VxdWFscyhvdGhlci5jcmVkc1tpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xuICAgIH1cbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFbXB0eUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InterceptingListenerImpl = void 0;\nexports.statusOrFromValue = statusOrFromValue;\nexports.statusOrFromError = statusOrFromError;\nexports.isInterceptingListener = isInterceptingListener;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction statusOrFromValue(value) {\n    return {\n        ok: true,\n        value: value\n    };\n}\nfunction statusOrFromError(error) {\n    var _a;\n    return {\n        ok: false,\n        error: Object.assign(Object.assign({}, error), { metadata: (_a = error.metadata) !== null && _a !== void 0 ? _a : new metadata_1.Metadata() })\n    };\n}\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, metadata => {\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, msg => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, processedStatus => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n//# sourceMappingURL=call-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLDRGQUE0RjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWludGVyZmFjZS5qcz84ZmJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuc3RhdHVzT3JGcm9tVmFsdWUgPSBzdGF0dXNPckZyb21WYWx1ZTtcbmV4cG9ydHMuc3RhdHVzT3JGcm9tRXJyb3IgPSBzdGF0dXNPckZyb21FcnJvcjtcbmV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGlzSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5mdW5jdGlvbiBzdGF0dXNPckZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RhdHVzT3JGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBlcnJvcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlcnJvciksIHsgbWV0YWRhdGE6IChfYSA9IGVycm9yLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEubGVuZ3RoID09PSAxKTtcbn1cbmNsYXNzIEludGVyY2VwdGluZ0xpc3RlbmVySW1wbCB7XG4gICAgY29uc3RydWN0b3IobGlzdGVuZXIsIG5leHRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEsIG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogSWYgdGhpcyBsaXN0ZW5lciBwcm9jZXNzZXMgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHksIHRoZSBsYXN0IG1lc3NhZ2UgbWF5XG4gICAgICAgICAqIGJlIHJlb3JkZXJlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXR1cyAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIG1zZyA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXMoc3RhdHVzLCBwcm9jZXNzZWRTdGF0dXMgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBwcm9jZXNzZWRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMocHJvY2Vzc2VkU3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNextCallNumber = getNextCallNumber;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n}\n//# sourceMappingURL=call-number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLW51bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzPzQ4OTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSBnZXROZXh0Q2FsbE51bWJlcjtcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XG5mdW5jdGlvbiBnZXROZXh0Q2FsbE51bWJlcigpIHtcbiAgICByZXR1cm4gbmV4dENhbGxOdW1iZXIrKztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = void 0;\nexports.callErrorFromStatus = callErrorFromStatus;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, { stack });\n}\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor() {\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    getAuthContext() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getAuthContext()) !== null && _b !== void 0 ? _b : null;\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize) {\n        super({ objectMode: true });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    getAuthContext() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getAuthContext()) !== null && _b !== void 0 ? _b : null;\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    getAuthContext() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getAuthContext()) !== null && _b !== void 0 ? _b : null;\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    getAuthContext() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getAuthContext()) !== null && _b !== void 0 ? _b : null;\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCO0FBQ2xJLDJCQUEyQjtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLEVBQUUsZ0NBQWdDLElBQUksZUFBZTtBQUN6RjtBQUNBLHFCQUFxQixZQUFZLGlCQUFpQixZQUFZO0FBQzlELHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcz9lZDNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gdm9pZCAwO1xuZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gY2FsbEVycm9yRnJvbVN0YXR1cztcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBTZXJ2aWNlRXJyb3IgZnJvbSBhIFN0YXR1c09iamVjdC4gVGhpcyBmdW5jdGlvbiBleGlzdHMgcHJpbWFyaWx5XG4gKiBhcyBhbiBhdHRlbXB0IHRvIG1ha2UgdGhlIGVycm9yIHN0YWNrIHRyYWNlIGNsZWFybHkgY29tbXVuaWNhdGUgdGhhdCB0aGVcbiAqIGVycm9yIGlzIG5vdCBuZWNlc3NhcmlseSBhIHByb2JsZW0gaW4gZ1JQQyBpdHNlbGYuXG4gKiBAcGFyYW0gc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIGNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtzdGF0dXMuY29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzLmNvZGVdfTogJHtzdGF0dXMuZGV0YWlsc31gO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHN0YWNrID0gYCR7ZXJyb3Iuc3RhY2t9XFxuZm9yIGNhbGwgYXRcXG4ke2NhbGxlclN0YWNrfWA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCBzdGF0dXMsIHsgc3RhY2sgfSk7XG59XG5jbGFzcyBDbGllbnRVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEF1dGhDb250ZXh0KCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gQ2xpZW50VW5hcnlDYWxsSW1wbDtcbmNsYXNzIENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEF1dGhDb250ZXh0KCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnRXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgZ2V0QXV0aENvbnRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRBdXRoQ29udGV4dCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgZ2V0QXV0aENvbnRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRBdXRoQ29udGV4dCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IENsaWVudER1cGxleFN0cmVhbUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/certificate-provider.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileWatcherCertificateProvider = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst TRACER_NAME = 'certificate_provider';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst readFilePromise = (0, util_1.promisify)(fs.readFile);\nclass FileWatcherCertificateProvider {\n    constructor(config) {\n        this.config = config;\n        this.refreshTimer = null;\n        this.fileResultPromise = null;\n        this.latestCaUpdate = undefined;\n        this.caListeners = new Set();\n        this.latestIdentityUpdate = undefined;\n        this.identityListeners = new Set();\n        this.lastUpdateTime = null;\n        if ((config.certificateFile === undefined) !== (config.privateKeyFile === undefined)) {\n            throw new Error('certificateFile and privateKeyFile must be set or unset together');\n        }\n        if (config.certificateFile === undefined && config.caCertificateFile === undefined) {\n            throw new Error('At least one of certificateFile and caCertificateFile must be set');\n        }\n        trace('File watcher constructed with config ' + JSON.stringify(config));\n    }\n    updateCertificates() {\n        if (this.fileResultPromise) {\n            return;\n        }\n        this.fileResultPromise = Promise.allSettled([\n            this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),\n            this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),\n            this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()\n        ]);\n        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {\n            if (!this.refreshTimer) {\n                return;\n            }\n            trace('File watcher read certificates certificate ' + certificateResult.status + ', privateKey ' + privateKeyResult.status + ', CA certificate ' + caCertificateResult.status);\n            this.lastUpdateTime = new Date();\n            this.fileResultPromise = null;\n            if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {\n                this.latestIdentityUpdate = {\n                    certificate: certificateResult.value,\n                    privateKey: privateKeyResult.value\n                };\n            }\n            else {\n                this.latestIdentityUpdate = null;\n            }\n            if (caCertificateResult.status === 'fulfilled') {\n                this.latestCaUpdate = {\n                    caCertificate: caCertificateResult.value\n                };\n            }\n            else {\n                this.latestCaUpdate = null;\n            }\n            for (const listener of this.identityListeners) {\n                listener(this.latestIdentityUpdate);\n            }\n            for (const listener of this.caListeners) {\n                listener(this.latestCaUpdate);\n            }\n        });\n        trace('File watcher initiated certificate update');\n    }\n    maybeStartWatchingFiles() {\n        if (!this.refreshTimer) {\n            /* Perform the first read immediately, but only if there was not already\n             * a recent read, to avoid reading from the filesystem significantly more\n             * frequently than configured if the provider quickly switches between\n             * used and unused. */\n            const timeSinceLastUpdate = this.lastUpdateTime ? (new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs) {\n                this.updateCertificates();\n            }\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {\n                // Clear out old updates if they are definitely stale\n                this.latestCaUpdate = undefined;\n                this.latestIdentityUpdate = undefined;\n            }\n            this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);\n            trace('File watcher started watching');\n        }\n    }\n    maybeStopWatchingFiles() {\n        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {\n            this.fileResultPromise = null;\n            if (this.refreshTimer) {\n                clearInterval(this.refreshTimer);\n                this.refreshTimer = null;\n            }\n        }\n    }\n    addCaCertificateListener(listener) {\n        this.caListeners.add(listener);\n        this.maybeStartWatchingFiles();\n        if (this.latestCaUpdate !== undefined) {\n            process.nextTick(listener, this.latestCaUpdate);\n        }\n    }\n    removeCaCertificateListener(listener) {\n        this.caListeners.delete(listener);\n        this.maybeStopWatchingFiles();\n    }\n    addIdentityCertificateListener(listener) {\n        this.identityListeners.add(listener);\n        this.maybeStartWatchingFiles();\n        if (this.latestIdentityUpdate !== undefined) {\n            process.nextTick(listener, this.latestIdentityUpdate);\n        }\n    }\n    removeIdentityCertificateListener(listener) {\n        this.identityListeners.delete(listener);\n        this.maybeStopWatchingFiles();\n    }\n}\nexports.FileWatcherCertificateProvider = FileWatcherCertificateProvider;\n//# sourceMappingURL=certificate-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jZXJ0aWZpY2F0ZS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQztBQUN0QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NlcnRpZmljYXRlLXByb3ZpZGVyLmpzP2VjMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjQgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdjZXJ0aWZpY2F0ZV9wcm92aWRlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IHJlYWRGaWxlUHJvbWlzZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShmcy5yZWFkRmlsZSk7XG5jbGFzcyBGaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pZGVudGl0eUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IG51bGw7XG4gICAgICAgIGlmICgoY29uZmlnLmNlcnRpZmljYXRlRmlsZSA9PT0gdW5kZWZpbmVkKSAhPT0gKGNvbmZpZy5wcml2YXRlS2V5RmlsZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjZXJ0aWZpY2F0ZUZpbGUgYW5kIHByaXZhdGVLZXlGaWxlIG11c3QgYmUgc2V0IG9yIHVuc2V0IHRvZ2V0aGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jZXJ0aWZpY2F0ZUZpbGUgPT09IHVuZGVmaW5lZCAmJiBjb25maWcuY2FDZXJ0aWZpY2F0ZUZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgb2YgY2VydGlmaWNhdGVGaWxlIGFuZCBjYUNlcnRpZmljYXRlRmlsZSBtdXN0IGJlIHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdGaWxlIHdhdGNoZXIgY29uc3RydWN0ZWQgd2l0aCBjb25maWcgJyArIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xuICAgIH1cbiAgICB1cGRhdGVDZXJ0aWZpY2F0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGVSZXN1bHRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxlUmVzdWx0UHJvbWlzZSA9IFByb21pc2UuYWxsU2V0dGxlZChbXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jZXJ0aWZpY2F0ZUZpbGUgPyByZWFkRmlsZVByb21pc2UodGhpcy5jb25maWcuY2VydGlmaWNhdGVGaWxlKSA6IFByb21pc2UucmVqZWN0KCksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5wcml2YXRlS2V5RmlsZSA/IHJlYWRGaWxlUHJvbWlzZSh0aGlzLmNvbmZpZy5wcml2YXRlS2V5RmlsZSkgOiBQcm9taXNlLnJlamVjdCgpLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FDZXJ0aWZpY2F0ZUZpbGUgPyByZWFkRmlsZVByb21pc2UodGhpcy5jb25maWcuY2FDZXJ0aWZpY2F0ZUZpbGUpIDogUHJvbWlzZS5yZWplY3QoKVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5maWxlUmVzdWx0UHJvbWlzZS50aGVuKChbY2VydGlmaWNhdGVSZXN1bHQsIHByaXZhdGVLZXlSZXN1bHQsIGNhQ2VydGlmaWNhdGVSZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0ZpbGUgd2F0Y2hlciByZWFkIGNlcnRpZmljYXRlcyBjZXJ0aWZpY2F0ZSAnICsgY2VydGlmaWNhdGVSZXN1bHQuc3RhdHVzICsgJywgcHJpdmF0ZUtleSAnICsgcHJpdmF0ZUtleVJlc3VsdC5zdGF0dXMgKyAnLCBDQSBjZXJ0aWZpY2F0ZSAnICsgY2FDZXJ0aWZpY2F0ZVJlc3VsdC5zdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjZXJ0aWZpY2F0ZVJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmIHByaXZhdGVLZXlSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBjZXJ0aWZpY2F0ZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleVJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYUNlcnRpZmljYXRlUmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBjYUNlcnRpZmljYXRlOiBjYUNlcnRpZmljYXRlUmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmlkZW50aXR5TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuY2FMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmxhdGVzdENhVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNlKCdGaWxlIHdhdGNoZXIgaW5pdGlhdGVkIGNlcnRpZmljYXRlIHVwZGF0ZScpO1xuICAgIH1cbiAgICBtYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgLyogUGVyZm9ybSB0aGUgZmlyc3QgcmVhZCBpbW1lZGlhdGVseSwgYnV0IG9ubHkgaWYgdGhlcmUgd2FzIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICAgKiBhIHJlY2VudCByZWFkLCB0byBhdm9pZCByZWFkaW5nIGZyb20gdGhlIGZpbGVzeXN0ZW0gc2lnbmlmaWNhbnRseSBtb3JlXG4gICAgICAgICAgICAgKiBmcmVxdWVudGx5IHRoYW4gY29uZmlndXJlZCBpZiB0aGUgcHJvdmlkZXIgcXVpY2tseSBzd2l0Y2hlcyBiZXR3ZWVuXG4gICAgICAgICAgICAgKiB1c2VkIGFuZCB1bnVzZWQuICovXG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0VXBkYXRlID0gdGhpcy5sYXN0VXBkYXRlVGltZSA/IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RVcGRhdGVUaW1lLmdldFRpbWUoKSA6IEluZmluaXR5O1xuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RVcGRhdGUgPiB0aGlzLmNvbmZpZy5yZWZyZXNoSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2VydGlmaWNhdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdFVwZGF0ZSA+IHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbE1zICogMikge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIG91dCBvbGQgdXBkYXRlcyBpZiB0aGV5IGFyZSBkZWZpbml0ZWx5IHN0YWxlXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnVwZGF0ZUNlcnRpZmljYXRlcygpLCB0aGlzLmNvbmZpZy5yZWZyZXNoSW50ZXJ2YWxNcyk7XG4gICAgICAgICAgICB0cmFjZSgnRmlsZSB3YXRjaGVyIHN0YXJ0ZWQgd2F0Y2hpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZVN0b3BXYXRjaGluZ0ZpbGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jYUxpc3RlbmVycy5zaXplID09PSAwICYmIHRoaXMuaWRlbnRpdHlMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maWxlUmVzdWx0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVmcmVzaFRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2FMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcygpO1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDYVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGxpc3RlbmVyLCB0aGlzLmxhdGVzdENhVXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYUNlcnRpZmljYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jYUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm1heWJlU3RvcFdhdGNoaW5nRmlsZXMoKTtcbiAgICB9XG4gICAgYWRkSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaWRlbnRpdHlMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcygpO1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGxpc3RlbmVyLCB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pZGVudGl0eUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm1heWJlU3RvcFdhdGNoaW5nRmlsZXMoKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlciA9IEZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlcnRpZmljYXRlLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelCredentials = void 0;\nexports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n    /**\n     * Returns a copy of this object with the included set of per-call credentials\n     * expanded to include callCredentials.\n     * @param callCredentials A CallCredentials object to associate with this\n     * instance.\n     */\n    compose(callCredentials) {\n        return new ComposedChannelCredentialsImpl(this, callCredentials);\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\n        verifyIsBufferOrNull(privateKey, 'Private key');\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\n        if (privateKey && !certChain) {\n            throw new Error('Private key must be given with accompanying certificate chain');\n        }\n        if (!privateKey && certChain) {\n            throw new Error('Certificate chain must be given with accompanying private key');\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */\n    static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor() {\n        super();\n    }\n    compose(callCredentials) {\n        throw new Error('Cannot compose insecure credentials');\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        return {\n            connect(socket) {\n                return Promise.resolve({\n                    socket,\n                    secure: false\n                });\n            },\n            waitForReady: () => {\n                return Promise.resolve();\n            },\n            getCallCredentials: () => {\n                return callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty();\n            },\n            destroy() { }\n        };\n    }\n}\nfunction getConnectionOptions(secureContext, verifyOptions, channelTarget, options) {\n    var _a, _b;\n    const connectionOptions = {\n        secureContext: secureContext\n    };\n    let realTarget = channelTarget;\n    if ('grpc.http_connect_target' in options) {\n        const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\n        if (parsedTarget) {\n            realTarget = parsedTarget;\n        }\n    }\n    const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n    connectionOptions.host = remoteHost;\n    if (verifyOptions.checkServerIdentity) {\n        connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n    if (verifyOptions.rejectUnauthorized !== undefined) {\n        connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;\n    }\n    connectionOptions.ALPNProtocols = ['h2'];\n    if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n        const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== void 0 ? _b : tls_1.checkServerIdentity;\n        connectionOptions.checkServerIdentity = (host, cert) => {\n            return originalCheckServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n    }\n    else {\n        connectionOptions.servername = remoteHost;\n    }\n    if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n    }\n    return connectionOptions;\n}\nclass SecureConnectorImpl {\n    constructor(connectionOptions, callCredentials) {\n        this.connectionOptions = connectionOptions;\n        this.callCredentials = callCredentials;\n    }\n    connect(socket) {\n        const tlsConnectOptions = Object.assign({ socket: socket }, this.connectionOptions);\n        return new Promise((resolve, reject) => {\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\n                var _a;\n                if (((_a = this.connectionOptions.rejectUnauthorized) !== null && _a !== void 0 ? _a : true) && !tlsSocket.authorized) {\n                    reject(tlsSocket.authorizationError);\n                    return;\n                }\n                resolve({\n                    socket: tlsSocket,\n                    secure: true\n                });\n            });\n            tlsSocket.on('error', (error) => {\n                reject(error);\n            });\n        });\n    }\n    waitForReady() {\n        return Promise.resolve();\n    }\n    getCallCredentials() {\n        return this.callCredentials;\n    }\n    destroy() { }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions) {\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return (this.secureContext === other.secureContext &&\n                this.verifyOptions.checkServerIdentity ===\n                    other.verifyOptions.checkServerIdentity);\n        }\n        else {\n            return false;\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);\n        return new SecureConnectorImpl(connectionOptions, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n    }\n}\nclass CertificateProviderChannelCredentialsImpl extends ChannelCredentials {\n    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {\n        super();\n        this.caCertificateProvider = caCertificateProvider;\n        this.identityCertificateProvider = identityCertificateProvider;\n        this.verifyOptions = verifyOptions;\n        this.refcount = 0;\n        /**\n         * `undefined` means that the certificates have not yet been loaded. `null`\n         * means that an attempt to load them has completed, and has failed.\n         */\n        this.latestCaUpdate = undefined;\n        /**\n         * `undefined` means that the certificates have not yet been loaded. `null`\n         * means that an attempt to load them has completed, and has failed.\n         */\n        this.latestIdentityUpdate = undefined;\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n        this.secureContextWatchers = [];\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        var _a, _b;\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof CertificateProviderChannelCredentialsImpl) {\n            return this.caCertificateProvider === other.caCertificateProvider &&\n                this.identityCertificateProvider === other.identityCertificateProvider &&\n                ((_a = this.verifyOptions) === null || _a === void 0 ? void 0 : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === void 0 ? void 0 : _b.checkServerIdentity);\n        }\n        else {\n            return false;\n        }\n    }\n    ref() {\n        var _a;\n        if (this.refcount === 0) {\n            this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n        this.refcount += 1;\n    }\n    unref() {\n        var _a;\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        this.ref();\n        return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n    }\n    maybeUpdateWatchers() {\n        if (this.hasReceivedUpdates()) {\n            for (const watcher of this.secureContextWatchers) {\n                watcher(this.getLatestSecureContext());\n            }\n            this.secureContextWatchers = [];\n        }\n    }\n    handleCaCertificateUpdate(update) {\n        this.latestCaUpdate = update;\n        this.maybeUpdateWatchers();\n    }\n    handleIdentityCertitificateUpdate(update) {\n        this.latestIdentityUpdate = update;\n        this.maybeUpdateWatchers();\n    }\n    hasReceivedUpdates() {\n        if (this.latestCaUpdate === undefined) {\n            return false;\n        }\n        if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {\n            return false;\n        }\n        return true;\n    }\n    getSecureContext() {\n        if (this.hasReceivedUpdates()) {\n            return Promise.resolve(this.getLatestSecureContext());\n        }\n        else {\n            return new Promise(resolve => {\n                this.secureContextWatchers.push(resolve);\n            });\n        }\n    }\n    getLatestSecureContext() {\n        var _a, _b;\n        if (!this.latestCaUpdate) {\n            return null;\n        }\n        if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {\n            return null;\n        }\n        try {\n            return (0, tls_1.createSecureContext)({\n                ca: this.latestCaUpdate.caCertificate,\n                key: (_a = this.latestIdentityUpdate) === null || _a === void 0 ? void 0 : _a.privateKey,\n                cert: (_b = this.latestIdentityUpdate) === null || _b === void 0 ? void 0 : _b.certificate,\n                ciphers: tls_helpers_1.CIPHER_SUITES\n            });\n        }\n        catch (e) {\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to createSecureContext with error ' + e.message);\n            return null;\n        }\n    }\n}\nCertificateProviderChannelCredentialsImpl.SecureConnectorImpl = class {\n    constructor(parent, channelTarget, options, callCredentials) {\n        this.parent = parent;\n        this.channelTarget = channelTarget;\n        this.options = options;\n        this.callCredentials = callCredentials;\n    }\n    connect(socket) {\n        return new Promise((resolve, reject) => {\n            const secureContext = this.parent.getLatestSecureContext();\n            if (!secureContext) {\n                reject(new Error('Failed to load credentials'));\n                return;\n            }\n            if (socket.closed) {\n                reject(new Error('Socket closed while loading credentials'));\n            }\n            const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);\n            const tlsConnectOptions = Object.assign({ socket: socket }, connnectionOptions);\n            const closeCallback = () => {\n                reject(new Error('Socket closed'));\n            };\n            const errorCallback = (error) => {\n                reject(error);\n            };\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\n                var _a;\n                tlsSocket.removeListener('close', closeCallback);\n                tlsSocket.removeListener('error', errorCallback);\n                if (((_a = this.parent.verifyOptions.rejectUnauthorized) !== null && _a !== void 0 ? _a : true) && !tlsSocket.authorized) {\n                    reject(tlsSocket.authorizationError);\n                    return;\n                }\n                resolve({\n                    socket: tlsSocket,\n                    secure: true\n                });\n            });\n            tlsSocket.once('close', closeCallback);\n            tlsSocket.once('error', errorCallback);\n        });\n    }\n    async waitForReady() {\n        await this.parent.getSecureContext();\n    }\n    getCallCredentials() {\n        return this.callCredentials;\n    }\n    destroy() {\n        this.parent.unref();\n    }\n};\nfunction createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {\n    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCredentials) {\n        super();\n        this.channelCredentials = channelCredentials;\n        this.callCredentials = callCredentials;\n        if (!channelCredentials._isSecure()) {\n            throw new Error('Cannot compose insecure credentials');\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return (this.channelCredentials._equals(other.channelCredentials) &&\n                this.callCredentials._equals(other.callCredentials));\n        }\n        else {\n            return false;\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n        return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);\n    }\n}\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLG1EQUFtRDtBQUNuRCxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMkJBQTJCLG1CQUFPLENBQUMsdUdBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFlO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvTEFBb0w7QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzP2JiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzID0gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscztcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XG4gICAgaWYgKG9iaiAmJiAhKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmcmllbmRseU5hbWV9LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIEJ1ZmZlci5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxuICogYXMgYSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMsIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IG1ldGhvZCBjYWxsIG1hZGVcbiAqIG92ZXIgYSBjaGFubmVsIGluaXRpYWxpemVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIG9iamVjdCB3aXRoIHRoZSBpbmNsdWRlZCBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHNcbiAgICAgKiBleHBhbmRlZCB0byBpbmNsdWRlIGNhbGxDcmVkZW50aWFscy5cbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEEgQ2FsbENyZWRlbnRpYWxzIG9iamVjdCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzXG4gICAgICogaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWxzLlxuICAgICAqIFRoZSByZXN1bHRpbmcgaW5zdGFuY2UgY2FuIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgQ2hhbm5lbCB0aGF0IGNvbW11bmljYXRlc1xuICAgICAqIG92ZXIgVExTLlxuICAgICAqIEBwYXJhbSByb290Q2VydHMgVGhlIHJvb3QgY2VydGlmaWNhdGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBUaGUgY2xpZW50IGNlcnRpZmljYXRlIHByaXZhdGUga2V5LCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIGNlcnRDaGFpbiBUaGUgY2xpZW50IGNlcnRpZmljYXRlIGtleSBjaGFpbiwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNzbChyb290Q2VydHMsIHByaXZhdGVLZXksIGNlcnRDaGFpbiwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHJvb3RDZXJ0cywgJ1Jvb3QgY2VydGlmaWNhdGUnKTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocHJpdmF0ZUtleSwgJ1ByaXZhdGUga2V5Jyk7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKGNlcnRDaGFpbiwgJ0NlcnRpZmljYXRlIGNoYWluJyk7XG4gICAgICAgIGlmIChwcml2YXRlS2V5ICYmICFjZXJ0Q2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgbXVzdCBiZSBnaXZlbiB3aXRoIGFjY29tcGFueWluZyBjZXJ0aWZpY2F0ZSBjaGFpbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJpdmF0ZUtleSAmJiBjZXJ0Q2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgY2hhaW4gbXVzdCBiZSBnaXZlbiB3aXRoIGFjY29tcGFueWluZyBwcml2YXRlIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlY3VyZUNvbnRleHQgPSAoMCwgdGxzXzEuY3JlYXRlU2VjdXJlQ29udGV4dCkoe1xuICAgICAgICAgICAgY2E6IChfYSA9IHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiByb290Q2VydHMgIT09IHZvaWQgMCA/IHJvb3RDZXJ0cyA6ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5ICE9PSB2b2lkIDAgPyBwcml2YXRlS2V5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydDogY2VydENoYWluICE9PSBudWxsICYmIGNlcnRDaGFpbiAhPT0gdm9pZCAwID8gY2VydENoYWluIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIGNyZWRlbnRpYWxzIGNyZWF0ZWQgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dC4gVGhlIHJlc3VsdGluZyBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzIG92ZXIgVExTLiBnUlBDIHdpbGwgbm90IG92ZXJyaWRlXG4gICAgICogYW55dGhpbmcgaW4gdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQsIHNvIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgKiBHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIGFuZCBHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCB3aWxsXG4gICAgICogbm90IGJlIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHNlY3VyZUNvbnRleHQgVGhlIHJldHVybiB2YWx1ZSBvZiB0bHMuY3JlYXRlU2VjdXJlQ29udGV4dCgpXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggbm8gY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gQ2hhbm5lbENyZWRlbnRpYWxzO1xuY2xhc3MgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGw7XG4gICAgfVxuICAgIF9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25uZWN0KHNvY2tldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YWl0Rm9yUmVhZHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2FsbENyZWRlbnRpYWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxDcmVkZW50aWFscyAhPT0gbnVsbCAmJiBjYWxsQ3JlZGVudGlhbHMgIT09IHZvaWQgMCA/IGNhbGxDcmVkZW50aWFscyA6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95KCkgeyB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbk9wdGlvbnMoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucywgY2hhbm5lbFRhcmdldCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIHNlY3VyZUNvbnRleHQ6IHNlY3VyZUNvbnRleHRcbiAgICB9O1xuICAgIGxldCByZWFsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShvcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSk7XG4gICAgICAgIGlmIChwYXJzZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlYWxUYXJnZXQgPSBwYXJzZWRUYXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKHJlYWxUYXJnZXQpO1xuICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcbiAgICBjb25zdCByZW1vdGVIb3N0ID0gKF9hID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRhcmdldFBhdGg7XG4gICAgY29ubmVjdGlvbk9wdGlvbnMuaG9zdCA9IHJlbW90ZUhvc3Q7XG4gICAgaWYgKHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgIH1cbiAgICBpZiAodmVyaWZ5T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSB2ZXJpZnlPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgICB9XG4gICAgY29ubmVjdGlvbk9wdGlvbnMuQUxQTlByb3RvY29scyA9IFsnaDInXTtcbiAgICBpZiAob3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICBjb25zdCBzc2xUYXJnZXROYW1lT3ZlcnJpZGUgPSBvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xuICAgICAgICBjb25zdCBvcmlnaW5hbENoZWNrU2VydmVySWRlbnRpdHkgPSAoX2IgPSBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbENoZWNrU2VydmVySWRlbnRpdHkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSByZW1vdGVIb3N0O1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSkge1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5lbmFibGVUcmFjZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uT3B0aW9ucztcbn1cbmNsYXNzIFNlY3VyZUNvbm5lY3RvckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25PcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyA9IGNvbm5lY3Rpb25PcHRpb25zO1xuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscztcbiAgICB9XG4gICAgY29ubmVjdChzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgdGxzQ29ubmVjdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc29ja2V0OiBzb2NrZXQgfSwgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSAoMCwgdGxzXzEuY29ubmVjdCkodGxzQ29ubmVjdE9wdGlvbnMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSkgJiYgIXRsc1NvY2tldC5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0bHNTb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0OiB0bHNTb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bHNTb2NrZXQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvclJlYWR5KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG5jbGFzcyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VjdXJlQ29udGV4dCA9IHNlY3VyZUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucyA9IHZlcmlmeU9wdGlvbnM7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VjdXJlQ29udGV4dCA9PT0gb3RoZXIuc2VjdXJlQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID09PVxuICAgICAgICAgICAgICAgICAgICBvdGhlci52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25PcHRpb25zID0gZ2V0Q29ubmVjdGlvbk9wdGlvbnModGhpcy5zZWN1cmVDb250ZXh0LCB0aGlzLnZlcmlmeU9wdGlvbnMsIGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNvbm5lY3RvckltcGwoY29ubmVjdGlvbk9wdGlvbnMsIGNhbGxDcmVkZW50aWFscyAhPT0gbnVsbCAmJiBjYWxsQ3JlZGVudGlhbHMgIT09IHZvaWQgMCA/IGNhbGxDcmVkZW50aWFscyA6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHkoKSk7XG4gICAgfVxufVxuY2xhc3MgQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhQ2VydGlmaWNhdGVQcm92aWRlciwgaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciA9IGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlcjtcbiAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zID0gdmVyaWZ5T3B0aW9ucztcbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdW5kZWZpbmVkYCBtZWFucyB0aGF0IHRoZSBjZXJ0aWZpY2F0ZXMgaGF2ZSBub3QgeWV0IGJlZW4gbG9hZGVkLiBgbnVsbGBcbiAgICAgICAgICogbWVhbnMgdGhhdCBhbiBhdHRlbXB0IHRvIGxvYWQgdGhlbSBoYXMgY29tcGxldGVkLCBhbmQgaGFzIGZhaWxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdW5kZWZpbmVkYCBtZWFucyB0aGF0IHRoZSBjZXJ0aWZpY2F0ZXMgaGF2ZSBub3QgeWV0IGJlZW4gbG9hZGVkLiBgbnVsbGBcbiAgICAgICAgICogbWVhbnMgdGhhdCBhbiBhdHRlbXB0IHRvIGxvYWQgdGhlbSBoYXMgY29tcGxldGVkLCBhbmQgaGFzIGZhaWxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVDYUNlcnRpZmljYXRlVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVJZGVudGl0eUNlcnRpdGlmaWNhdGVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0V2F0Y2hlcnMgPSBbXTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgPT09IG90aGVyLmNhQ2VydGlmaWNhdGVQcm92aWRlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyID09PSBvdGhlci5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy52ZXJpZnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hlY2tTZXJ2ZXJJZGVudGl0eSkgPT09ICgoX2IgPSBvdGhlci52ZXJpZnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlci5hZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZjb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIucmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLnJlZigpO1xuICAgICAgICByZXR1cm4gbmV3IENlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHNJbXBsLlNlY3VyZUNvbm5lY3RvckltcGwodGhpcywgY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpKTtcbiAgICB9XG4gICAgbWF5YmVVcGRhdGVXYXRjaGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWRVcGRhdGVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlciBvZiB0aGlzLnNlY3VyZUNvbnRleHRXYXRjaGVycykge1xuICAgICAgICAgICAgICAgIHdhdGNoZXIodGhpcy5nZXRMYXRlc3RTZWN1cmVDb250ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0V2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDYUNlcnRpZmljYXRlVXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB0aGlzLm1heWJlVXBkYXRlV2F0Y2hlcnMoKTtcbiAgICB9XG4gICAgaGFuZGxlSWRlbnRpdHlDZXJ0aXRpZmljYXRlVXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB0aGlzLm1heWJlVXBkYXRlV2F0Y2hlcnMoKTtcbiAgICB9XG4gICAgaGFzUmVjZWl2ZWRVcGRhdGVzKCkge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDYVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRTZWN1cmVDb250ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oYXNSZWNlaXZlZFVwZGF0ZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmdldExhdGVzdFNlY3VyZUNvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0V2F0Y2hlcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExhdGVzdFNlY3VyZUNvbnRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDYVVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICE9PSBudWxsICYmICF0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0bHNfMS5jcmVhdGVTZWN1cmVDb250ZXh0KSh7XG4gICAgICAgICAgICAgICAgY2E6IHRoaXMubGF0ZXN0Q2FVcGRhdGUuY2FDZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICBrZXk6IChfYSA9IHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIGNlcnQ6IChfYiA9IHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNyZWF0ZVNlY3VyZUNvbnRleHQgd2l0aCBlcnJvciAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwuU2VjdXJlQ29ubmVjdG9ySW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGNvbm5lY3Qoc29ja2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gdGhpcy5wYXJlbnQuZ2V0TGF0ZXN0U2VjdXJlQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKCFzZWN1cmVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY3JlZGVudGlhbHMnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvY2tldC5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgY2xvc2VkIHdoaWxlIGxvYWRpbmcgY3JlZGVudGlhbHMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25ubmVjdGlvbk9wdGlvbnMgPSBnZXRDb25uZWN0aW9uT3B0aW9ucyhzZWN1cmVDb250ZXh0LCB0aGlzLnBhcmVudC52ZXJpZnlPcHRpb25zLCB0aGlzLmNoYW5uZWxUYXJnZXQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0bHNDb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBzb2NrZXQ6IHNvY2tldCB9LCBjb25ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgY2xvc2VkJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9ICgwLCB0bHNfMS5jb25uZWN0KSh0bHNDb25uZWN0T3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0bHNTb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5wYXJlbnQudmVyaWZ5T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpICYmICF0bHNTb2NrZXQuYXV0aG9yaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QodGxzU29ja2V0LmF1dGhvcml6YXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGxzU29ja2V0LFxuICAgICAgICAgICAgICAgICAgICBzZWN1cmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGxzU29ja2V0Lm9uY2UoJ2Nsb3NlJywgY2xvc2VDYWxsYmFjayk7XG4gICAgICAgICAgICB0bHNTb2NrZXQub25jZSgnZXJyb3InLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JSZWFkeSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wYXJlbnQuZ2V0U2VjdXJlQ29udGV4dCgpO1xuICAgIH1cbiAgICBnZXRDYWxsQ3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxDcmVkZW50aWFscztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQudW5yZWYoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscyhjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgdmVyaWZ5T3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwoY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbn1cbmNsYXNzIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENyZWRlbnRpYWxzLCBjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzID0gY2FsbENyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoIWNoYW5uZWxDcmVkZW50aWFscy5faXNTZWN1cmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCh0aGlzLmNoYW5uZWxDcmVkZW50aWFscywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hhbm5lbENyZWRlbnRpYWxzKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2FsbENyZWRlbnRpYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZVNlY3VyZUNvbm5lY3RvcihjaGFubmVsVGFyZ2V0LCBvcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyAhPT0gbnVsbCAmJiBjYWxsQ3JlZGVudGlhbHMgIT09IHZvaWQgMCA/IGNhbGxDcmVkZW50aWFscyA6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHkoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recognizedOptions = void 0;\nexports.channelOptionsEqual = channelOptionsEqual;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */\nexports.recognizedOptions = {\n    'grpc.ssl_target_name_override': true,\n    'grpc.primary_user_agent': true,\n    'grpc.secondary_user_agent': true,\n    'grpc.default_authority': true,\n    'grpc.keepalive_time_ms': true,\n    'grpc.keepalive_timeout_ms': true,\n    'grpc.keepalive_permit_without_calls': true,\n    'grpc.service_config': true,\n    'grpc.max_concurrent_streams': true,\n    'grpc.initial_reconnect_backoff_ms': true,\n    'grpc.max_reconnect_backoff_ms': true,\n    'grpc.use_local_subchannel_pool': true,\n    'grpc.max_send_message_length': true,\n    'grpc.max_receive_message_length': true,\n    'grpc.enable_http_proxy': true,\n    'grpc.enable_channelz': true,\n    'grpc.dns_min_time_between_resolutions_ms': true,\n    'grpc.enable_retries': true,\n    'grpc.per_rpc_retry_buffer_size': true,\n    'grpc.retry_buffer_size': true,\n    'grpc.max_connection_age_ms': true,\n    'grpc.max_connection_age_grace_ms': true,\n    'grpc-node.max_session_memory': true,\n    'grpc.service_config_disable_resolution': true,\n    'grpc.client_idle_timeout_ms': true,\n    'grpc-node.tls_enable_trace': true,\n    'grpc.lb.ring_hash.ring_size_cap': true,\n    'grpc-node.retry_max_attempts_limit': true,\n    'grpc-node.flow_control_window': true,\n    'grpc.server_call_metric_recording': true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let i = 0; i < keys1.length; i += 1) {\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLW9wdGlvbnMuanM/OWIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHZvaWQgMDtcbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGNoYW5uZWxPcHRpb25zRXF1YWw7XG4vKipcbiAqIFRoaXMgaXMgZm9yIGNoZWNraW5nIHByb3ZpZGVkIG9wdGlvbnMgYXQgcnVudGltZS4gVGhpcyBpcyBhbiBvYmplY3QgZm9yXG4gKiBlYXNpZXIgbWVtYmVyc2hpcCBjaGVja2luZy5cbiAqL1xuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHtcbiAgICAnZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnOiB0cnVlLFxuICAgICdncnBjLnByaW1hcnlfdXNlcl9hZ2VudCc6IHRydWUsXG4gICAgJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLmRlZmF1bHRfYXV0aG9yaXR5JzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyc6IHRydWUsXG4gICAgJ2dycGMuc2VydmljZV9jb25maWcnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnOiB0cnVlLFxuICAgICdncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXG4gICAgJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCc6IHRydWUsXG4gICAgJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfaHR0cF9wcm94eSc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2NoYW5uZWx6JzogdHJ1ZSxcbiAgICAnZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX3JldHJpZXMnOiB0cnVlLFxuICAgICdncnBjLnBlcl9ycGNfcmV0cnlfYnVmZmVyX3NpemUnOiB0cnVlLFxuICAgICdncnBjLnJldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25uZWN0aW9uX2FnZV9ncmFjZV9tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbic6IHRydWUsXG4gICAgJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJzogdHJ1ZSxcbiAgICAnZ3JwYy5sYi5yaW5nX2hhc2gucmluZ19zaXplX2NhcCc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS5yZXRyeV9tYXhfYXR0ZW1wdHNfbGltaXQnOiB0cnVlLFxuICAgICdncnBjLW5vZGUuZmxvd19jb250cm9sX3dpbmRvdyc6IHRydWUsXG4gICAgJ2dycGMuc2VydmVyX2NhbGxfbWV0cmljX3JlY29yZGluZyc6IHRydWVcbn07XG5mdW5jdGlvbiBjaGFubmVsT3B0aW9uc0VxdWFsKG9wdGlvbnMxLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob3B0aW9uczEpLnNvcnQoKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9wdGlvbnMyKS5zb3J0KCk7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoa2V5czFbaV0gIT09IGtleXMyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMxW2tleXMxW2ldXSAhPT0gb3B0aW9uczJba2V5czJbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwuanM/ZWFlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbmNsYXNzIENoYW5uZWxJbXBsZW1lbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbCA9IG5ldyBpbnRlcm5hbF9jaGFubmVsXzEuSW50ZXJuYWxDaGFubmVsKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC53YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgZGVhZGxpbmUgPT09ICdudW1iZXInIHx8IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;\nexports.unregisterChannelzRef = unregisterChannelzRef;\nexports.getChannelzHandlers = getChannelzHandlers;\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nexports.setup = setup;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst ordered_map_1 = __webpack_require__(/*! @js-sdsl/ordered-map */ \"(action-browser)/./node_modules/@js-sdsl/ordered-map/dist/esm/index.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id,\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name,\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n/**\n * Default number of sockets/servers/channels/subchannels to return\n */\nconst DEFAULT_MAX_RESULTS = 100;\nclass ChannelzTraceStub {\n    constructor() {\n        this.events = [];\n        this.creationTimestamp = new Date();\n        this.eventsLogged = 0;\n    }\n    addTrace() { }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: [],\n        };\n    }\n}\nexports.ChannelzTraceStub = ChannelzTraceStub;\nclass ChannelzTrace {\n    constructor() {\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map(event => {\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel\n                        ? channelRefToMessage(event.childChannel)\n                        : null,\n                    subchannel_ref: event.childSubchannel\n                        ? subchannelRefToMessage(event.childSubchannel)\n                        : null,\n                };\n            }),\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor() {\n        this.channelChildren = new ordered_map_1.OrderedMap();\n        this.subchannelChildren = new ordered_map_1.OrderedMap();\n        this.socketChildren = new ordered_map_1.OrderedMap();\n        this.trackerMap = {\n            [\"channel\" /* EntityTypes.channel */]: this.channelChildren,\n            [\"subchannel\" /* EntityTypes.subchannel */]: this.subchannelChildren,\n            [\"socket\" /* EntityTypes.socket */]: this.socketChildren,\n        };\n    }\n    refChild(child) {\n        const tracker = this.trackerMap[child.kind];\n        const trackedChild = tracker.find(child.id);\n        if (trackedChild.equals(tracker.end())) {\n            tracker.setElement(child.id, {\n                ref: child,\n                count: 1,\n            }, trackedChild);\n        }\n        else {\n            trackedChild.pointer[1].count += 1;\n        }\n    }\n    unrefChild(child) {\n        const tracker = this.trackerMap[child.kind];\n        const trackedChild = tracker.getElementByKey(child.id);\n        if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n                tracker.eraseElementByKey(child.id);\n            }\n        }\n    }\n    getChildLists() {\n        return {\n            channels: this.channelChildren,\n            subchannels: this.subchannelChildren,\n            sockets: this.socketChildren,\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {\n    refChild() { }\n    unrefChild() { }\n}\nexports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;\nclass ChannelzCallTracker {\n    constructor() {\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nclass ChannelzCallTrackerStub extends ChannelzCallTracker {\n    addCallStarted() { }\n    addCallSucceeded() { }\n    addCallFailed() { }\n}\nexports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;\nconst entityMaps = {\n    [\"channel\" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),\n    [\"subchannel\" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),\n    [\"server\" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),\n    [\"socket\" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),\n};\nconst generateRegisterFn = (kind) => {\n    let nextId = 1;\n    function getNextId() {\n        return nextId++;\n    }\n    const entityMap = entityMaps[kind];\n    return (name, getInfo, channelzEnabled) => {\n        const id = getNextId();\n        const ref = { id, name, kind };\n        if (channelzEnabled) {\n            entityMap.setElement(id, { ref, getInfo });\n        }\n        return ref;\n    };\n};\nexports.registerChannelzChannel = generateRegisterFn(\"channel\" /* EntityTypes.channel */);\nexports.registerChannelzSubchannel = generateRegisterFn(\"subchannel\" /* EntityTypes.subchannel */);\nexports.registerChannelzServer = generateRegisterFn(\"server\" /* EntityTypes.server */);\nexports.registerChannelzSocket = generateRegisterFn(\"socket\" /* EntityTypes.socket */);\nfunction unregisterChannelzRef(ref) {\n    entityMaps[ref.kind].eraseElementByKey(ref.id);\n}\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [(numberValue / 256) | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n    if (addressChunk === '') {\n        return [];\n    }\n    const bytePairs = addressChunk\n        .split(':')\n        .map(section => parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\nfunction isIPv6MappedIPv4(ipAddress) {\n    return (0, net_1.isIPv6)(ipAddress) && ipAddress.toLowerCase().startsWith('::ffff:') && (0, net_1.isIPv4)(ipAddress.substring(7));\n}\n/**\n * Prerequisite: isIPv4(ipAddress)\n * @param ipAddress\n * @returns\n */\nfunction ipv4AddressStringToBuffer(ipAddress) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return ipv4AddressStringToBuffer(ipAddress);\n    }\n    else if (isIPv6MappedIPv4(ipAddress)) {\n        return ipv4AddressStringToBuffer(ipAddress.substring(7));\n    }\n    else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf('::');\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = '';\n        }\n        else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n    }\n    else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch (state) {\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: 'CONNECTING',\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: 'IDLE',\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: 'READY',\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: 'SHUTDOWN',\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: 'TRANSIENT_FAILURE',\n            };\n        default:\n            return {\n                state: 'UNKNOWN',\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: (millisSinceEpoch / 1000) | 0,\n        nanos: (millisSinceEpoch % 1000) * 1000000,\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    const channelRef = [];\n    const subchannelRef = [];\n    resolvedInfo.children.channels.forEach(el => {\n        channelRef.push(channelRefToMessage(el[1].ref));\n    });\n    resolvedInfo.children.subchannels.forEach(el => {\n        subchannelRef.push(subchannelRefToMessage(el[1].ref));\n    });\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        channel_ref: channelRef,\n        subchannel_ref: subchannelRef,\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = parseInt(call.request.channel_id, 10);\n    const channelEntry = entityMaps[\"channel\" /* EntityTypes.channel */].getElementByKey(channelId);\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No channel data found for id ' + channelId,\n        });\n        return;\n    }\n    callback(null, { channel: getChannelMessage(channelEntry) });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const resultList = [];\n    const startId = parseInt(call.request.start_channel_id, 10);\n    const channelEntries = entityMaps[\"channel\" /* EntityTypes.channel */];\n    let i;\n    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {\n        resultList.push(getChannelMessage(i.pointer[1]));\n    }\n    callback(null, {\n        channel: resultList,\n        end: i.equals(channelEntries.end()),\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    const listenSocket = [];\n    resolvedInfo.listenerChildren.sockets.forEach(el => {\n        listenSocket.push(socketRefToMessage(el[1].ref));\n    });\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        listen_socket: listenSocket,\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = parseInt(call.request.server_id, 10);\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\n    const serverEntry = serverEntries.getElementByKey(serverId);\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    callback(null, { server: getServerMessage(serverEntry) });\n}\nfunction GetServers(call, callback) {\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const startId = parseInt(call.request.start_server_id, 10);\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\n    const resultList = [];\n    let i;\n    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {\n        resultList.push(getServerMessage(i.pointer[1]));\n    }\n    callback(null, {\n        server: resultList,\n        end: i.equals(serverEntries.end()),\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = parseInt(call.request.subchannel_id, 10);\n    const subchannelEntry = entityMaps[\"subchannel\" /* EntityTypes.subchannel */].getElementByKey(subchannelId);\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No subchannel data found for id ' + subchannelId,\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const listenSocket = [];\n    resolvedInfo.children.sockets.forEach(el => {\n        listenSocket.push(socketRefToMessage(el[1].ref));\n    });\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        socket_ref: listenSocket,\n    };\n    callback(null, { subchannel: subchannelMessage });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: 'tcpip_address',\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port,\n            },\n        };\n    }\n    else {\n        return {\n            address: 'uds_address',\n            uds_address: {\n                filename: subchannelAddress.path,\n            },\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = parseInt(call.request.socket_id, 10);\n    const socketEntry = entityMaps[\"socket\" /* EntityTypes.socket */].getElementByKey(socketId);\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No socket data found for id ' + socketId,\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security\n        ? {\n            model: 'tls',\n            tls: {\n                cipher_suite: resolvedInfo.security.cipherSuiteStandardName\n                    ? 'standard_name'\n                    : 'other_name',\n                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,\n            },\n        }\n        : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\n            : null,\n        remote: resolvedInfo.remoteAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\n            : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow\n                ? { value: resolvedInfo.localFlowControlWindow }\n                : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\n                ? { value: resolvedInfo.remoteFlowControlWindow }\n                : null,\n        },\n    };\n    callback(null, { socket: socketMessage });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = parseInt(call.request.server_id, 10);\n    const serverEntry = entityMaps[\"server\" /* EntityTypes.server */].getElementByKey(serverId);\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    const startId = parseInt(call.request.start_socket_id, 10);\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets;\n    const resultList = [];\n    let i;\n    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {\n        resultList.push(socketRefToMessage(i.pointer[1].ref));\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i.equals(allSockets.end()),\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets,\n    };\n}\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync('channelz.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [`${__dirname}/../../proto`],\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition =\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLDhCQUE4QixHQUFHLGtDQUFrQyxHQUFHLCtCQUErQixHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLG1DQUFtQyxHQUFHLCtCQUErQixHQUFHLHFCQUFxQixHQUFHLHlCQUF5QjtBQUNsVSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLG9DQUFvQztBQUNwQyxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFzQjtBQUNwRCw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1FQUFtRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0VBQWtFO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtEQUErRDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRKQUNWO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/NTY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViID0gZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gZXhwb3J0cy5DaGFubmVselRyYWNlU3R1YiA9IHZvaWQgMDtcbmV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gdW5yZWdpc3RlckNoYW5uZWx6UmVmO1xuZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZ2V0Q2hhbm5lbHpIYW5kbGVycztcbmV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBvcmRlcmVkX21hcF8xID0gcmVxdWlyZShcIkBqcy1zZHNsL29yZGVyZWQtbWFwXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG4vKipcbiAqIERlZmF1bHQgbnVtYmVyIG9mIHNvY2tldHMvc2VydmVycy9jaGFubmVscy9zdWJjaGFubmVscyB0byByZXR1cm5cbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVTVUxUUyA9IDEwMDtcbmNsYXNzIENoYW5uZWx6VHJhY2VTdHViIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzTG9nZ2VkID0gMDtcbiAgICB9XG4gICAgYWRkVHJhY2UoKSB7IH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6VHJhY2VTdHViID0gQ2hhbm5lbHpUcmFjZVN0dWI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKTtcbiAgICAgICAgdGhpcy50cmFja2VyTWFwID0ge1xuICAgICAgICAgICAgW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dOiB0aGlzLmNoYW5uZWxDaGlsZHJlbixcbiAgICAgICAgICAgIFtcInN1YmNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5zdWJjaGFubmVsICovXTogdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBbXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi9dOiB0aGlzLnNvY2tldENoaWxkcmVuLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWZDaGlsZChjaGlsZCkge1xuICAgICAgICBjb25zdCB0cmFja2VyID0gdGhpcy50cmFja2VyTWFwW2NoaWxkLmtpbmRdO1xuICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0cmFja2VyLmZpbmQoY2hpbGQuaWQpO1xuICAgICAgICBpZiAodHJhY2tlZENoaWxkLmVxdWFscyh0cmFja2VyLmVuZCgpKSkge1xuICAgICAgICAgICAgdHJhY2tlci5zZXRFbGVtZW50KGNoaWxkLmlkLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgIH0sIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFja2VkQ2hpbGQucG9pbnRlclsxXS5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IHRoaXMudHJhY2tlck1hcFtjaGlsZC5raW5kXTtcbiAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdHJhY2tlci5nZXRFbGVtZW50QnlLZXkoY2hpbGQuaWQpO1xuICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRyYWNrZXIuZXJhc2VFbGVtZW50QnlLZXkoY2hpbGQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoaWxkTGlzdHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBzdWJjaGFubmVsczogdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBzb2NrZXRzOiB0aGlzLnNvY2tldENoaWxkcmVuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIgPSBDaGFubmVsekNoaWxkcmVuVHJhY2tlcjtcbmNsYXNzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YiBleHRlbmRzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIHtcbiAgICByZWZDaGlsZCgpIHsgfVxuICAgIHVucmVmQ2hpbGQoKSB7IH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViO1xuY2xhc3MgQ2hhbm5lbHpDYWxsVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCA9IDA7XG4gICAgICAgIHRoaXMuY2FsbHNGYWlsZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgfVxuICAgIGFkZENhbGxTdGFydGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdWNjZWVkZWQgKz0gMTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCArPSAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IENoYW5uZWx6Q2FsbFRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyU3R1YiBleHRlbmRzIENoYW5uZWx6Q2FsbFRyYWNrZXIge1xuICAgIGFkZENhbGxTdGFydGVkKCkgeyB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHsgfVxuICAgIGFkZENhbGxGYWlsZWQoKSB7IH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIgPSBDaGFubmVsekNhbGxUcmFja2VyU3R1YjtcbmNvbnN0IGVudGl0eU1hcHMgPSB7XG4gICAgW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dOiBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCksXG4gICAgW1wic3ViY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLnN1YmNoYW5uZWwgKi9dOiBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCksXG4gICAgW1wic2VydmVyXCIgLyogRW50aXR5VHlwZXMuc2VydmVyICovXTogbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpLFxuICAgIFtcInNvY2tldFwiIC8qIEVudGl0eVR5cGVzLnNvY2tldCAqL106IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKSxcbn07XG5jb25zdCBnZW5lcmF0ZVJlZ2lzdGVyRm4gPSAoa2luZCkgPT4ge1xuICAgIGxldCBuZXh0SWQgPSAxO1xuICAgIGZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRJZCsrO1xuICAgIH1cbiAgICBjb25zdCBlbnRpdHlNYXAgPSBlbnRpdHlNYXBzW2tpbmRdO1xuICAgIHJldHVybiAobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQgfTtcbiAgICAgICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgZW50aXR5TWFwLnNldEVsZW1lbnQoaWQsIHsgcmVmLCBnZXRJbmZvIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gZ2VuZXJhdGVSZWdpc3RlckZuKFwiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi8pO1xuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcInN1YmNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5zdWJjaGFubmVsICovKTtcbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqLyk7XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQgPSBnZW5lcmF0ZVJlZ2lzdGVyRm4oXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi8pO1xuZnVuY3Rpb24gdW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZikge1xuICAgIGVudGl0eU1hcHNbcmVmLmtpbmRdLmVyYXNlRWxlbWVudEJ5S2V5KHJlZi5pZCk7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHNlY3Rpb24gb2YgYW4gSVB2NiBhZGRyZXNzIGFzIHR3byBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NTZWN0aW9uIEEgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGxlbmd0aCB1cCB0byA0XG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2U2VjdGlvbihhZGRyZXNzU2VjdGlvbikge1xuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XG4gICAgcmV0dXJuIFsobnVtYmVyVmFsdWUgLyAyNTYpIHwgMCwgbnVtYmVyVmFsdWUgJSAyNTZdO1xufVxuLyoqXG4gKiBQYXJzZSBhIGNodW5rIG9mIGFuIElQdjYgYWRkcmVzcyBzdHJpbmcgdG8gc29tZSBudW1iZXIgb2YgYnl0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzQ2h1bmsgU29tZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgdXAgdG8gNCBoZXhhZGVjaW1hbFxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIGNodW5rXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xuICAgIGlmIChhZGRyZXNzQ2h1bmsgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZVBhaXJzID0gYWRkcmVzc0NodW5rXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCguLi5ieXRlUGFpcnMpO1xufVxuZnVuY3Rpb24gaXNJUHY2TWFwcGVkSVB2NChpcEFkZHJlc3MpIHtcbiAgICByZXR1cm4gKDAsIG5ldF8xLmlzSVB2NikoaXBBZGRyZXNzKSAmJiBpcEFkZHJlc3MudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCc6OmZmZmY6JykgJiYgKDAsIG5ldF8xLmlzSVB2NCkoaXBBZGRyZXNzLnN1YnN0cmluZyg3KSk7XG59XG4vKipcbiAqIFByZXJlcXVpc2l0ZTogaXNJUHY0KGlwQWRkcmVzcylcbiAqIEBwYXJhbSBpcEFkZHJlc3NcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwdjRBZGRyZXNzU3RyaW5nVG9CdWZmZXIoaXBBZGRyZXNzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFVpbnQ4QXJyYXkuZnJvbShpcEFkZHJlc3Muc3BsaXQoJy4nKS5tYXAoc2VnbWVudCA9PiBOdW1iZXIucGFyc2VJbnQoc2VnbWVudCkpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBpcHY0QWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSVB2Nk1hcHBlZElQdjQoaXBBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gaXB2NEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihpcEFkZHJlc3Muc3Vic3RyaW5nKDcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIG5ldF8xLmlzSVB2NikoaXBBZGRyZXNzKSkge1xuICAgICAgICBsZXQgbGVmdFNlY3Rpb247XG4gICAgICAgIGxldCByaWdodFNlY3Rpb247XG4gICAgICAgIGNvbnN0IGRvdWJsZUNvbG9uSW5kZXggPSBpcEFkZHJlc3MuaW5kZXhPZignOjonKTtcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcztcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKDAsIGRvdWJsZUNvbG9uSW5kZXgpO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZyhkb3VibGVDb2xvbkluZGV4ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKGxlZnRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsocmlnaHRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiAtIGxlZnRCdWZmZXIubGVuZ3RoIC0gcmlnaHRCdWZmZXIubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2xlZnRCdWZmZXIsIG1pZGRsZUJ1ZmZlciwgcmlnaHRCdWZmZXJdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnQ09OTkVDVElORycsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnSURMRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1JFQURZJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV046XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnU0hVVERPV04nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdUUkFOU0lFTlRfRkFJTFVSRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VOS05PV04nLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRlVG9Qcm90b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaWxsaXNTaW5jZUVwb2NoID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpc1NpbmNlRXBvY2ggLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAobWlsbGlzU2luY2VFcG9jaCAlIDEwMDApICogMTAwMDAwMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBjaGFubmVsUmVmID0gW107XG4gICAgY29uc3Qgc3ViY2hhbm5lbFJlZiA9IFtdO1xuICAgIHJlc29sdmVkSW5mby5jaGlsZHJlbi5jaGFubmVscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgY2hhbm5lbFJlZi5wdXNoKGNoYW5uZWxSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLnN1YmNoYW5uZWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBzdWJjaGFubmVsUmVmLnB1c2goc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShlbFsxXS5yZWYpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IGNoYW5uZWxSZWZUb01lc3NhZ2UoY2hhbm5lbEVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShyZXNvbHZlZEluZm8uc3RhdGUpLFxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbF9yZWY6IGNoYW5uZWxSZWYsXG4gICAgICAgIHN1YmNoYW5uZWxfcmVmOiBzdWJjaGFubmVsUmVmLFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRDaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2hhbm5lbElkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQsIDEwKTtcbiAgICBjb25zdCBjaGFubmVsRW50cnkgPSBlbnRpdHlNYXBzW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dLmdldEVsZW1lbnRCeUtleShjaGFubmVsSWQpO1xuICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIGNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIGNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBjaGFubmVsOiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0VG9wQ2hhbm5lbHMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzLCAxMCkgfHwgREVGQVVMVF9NQVhfUkVTVUxUUztcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgY29uc3Qgc3RhcnRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9jaGFubmVsX2lkLCAxMCk7XG4gICAgY29uc3QgY2hhbm5lbEVudHJpZXMgPSBlbnRpdHlNYXBzW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IGNoYW5uZWxFbnRyaWVzLmxvd2VyQm91bmQoc3RhcnRJZCk7ICFpLmVxdWFscyhjaGFubmVsRW50cmllcy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGkucG9pbnRlclsxXSkpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGNoYW5uZWw6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaS5lcXVhbHMoY2hhbm5lbEVudHJpZXMuZW5kKCkpLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkge1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBsaXN0ZW5Tb2NrZXQgPSBbXTtcbiAgICByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsaXN0ZW5Tb2NrZXQucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBzZXJ2ZXJSZWZUb01lc3NhZ2Uoc2VydmVyRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuX3NvY2tldDogbGlzdGVuU29ja2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQsIDEwKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyaWVzID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL107XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJFbnRyaWVzLmdldEVsZW1lbnRCeUtleShzZXJ2ZXJJZCk7XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cywgMTApIHx8IERFRkFVTFRfTUFYX1JFU1VMVFM7XG4gICAgY29uc3Qgc3RhcnRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zZXJ2ZXJfaWQsIDEwKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyaWVzID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL107XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHNlcnZlckVudHJpZXMubG93ZXJCb3VuZChzdGFydElkKTsgIWkuZXF1YWxzKHNlcnZlckVudHJpZXMuZW5kKCkpICYmIHJlc3VsdExpc3QubGVuZ3RoIDwgbWF4UmVzdWx0czsgaSA9IGkubmV4dCgpKSB7XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRTZXJ2ZXJNZXNzYWdlKGkucG9pbnRlclsxXSkpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNlcnZlcjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpLmVxdWFscyhzZXJ2ZXJFbnRyaWVzLmVuZCgpKSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIEdldFN1YmNoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdWJjaGFubmVsSWQgPSBwYXJzZUludChjYWxsLnJlcXVlc3Quc3ViY2hhbm5lbF9pZCwgMTApO1xuICAgIGNvbnN0IHN1YmNoYW5uZWxFbnRyeSA9IGVudGl0eU1hcHNbXCJzdWJjaGFubmVsXCIgLyogRW50aXR5VHlwZXMuc3ViY2hhbm5lbCAqL10uZ2V0RWxlbWVudEJ5S2V5KHN1YmNoYW5uZWxJZCk7XG4gICAgaWYgKHN1YmNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc3ViY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc3ViY2hhbm5lbElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzdWJjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIGNvbnN0IGxpc3RlblNvY2tldCA9IFtdO1xuICAgIHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsaXN0ZW5Tb2NrZXQucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShzdWJjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBzb2NrZXRfcmVmOiBsaXN0ZW5Tb2NrZXQsXG4gICAgfTtcbiAgICBjYWxsYmFjayhudWxsLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHN1YmNoYW5uZWxBZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoc3ViY2hhbm5lbEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndGNwaXBfYWRkcmVzcycsXG4gICAgICAgICAgICB0Y3BpcF9hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaXBfYWRkcmVzczogKF9hID0gaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIoc3ViY2hhbm5lbEFkZHJlc3MuaG9zdCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwb3J0OiBzdWJjaGFubmVsQWRkcmVzcy5wb3J0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndWRzX2FkZHJlc3MnLFxuICAgICAgICAgICAgdWRzX2FkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogc3ViY2hhbm5lbEFkZHJlc3MucGF0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0U29ja2V0KGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBzb2NrZXRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zb2NrZXRfaWQsIDEwKTtcbiAgICBjb25zdCBzb2NrZXRFbnRyeSA9IGVudGl0eU1hcHNbXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi9dLmdldEVsZW1lbnRCeUtleShzb2NrZXRJZCk7XG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzb2NrZXRFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc2VjdXJpdHlNZXNzYWdlID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZWw6ICd0bHMnLFxuICAgICAgICAgICAgdGxzOiB7XG4gICAgICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAnc3RhbmRhcmRfbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgOiAnb3RoZXJfbmFtZScsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJfbmFtZTogKF9iID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlT3RoZXJOYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYWxfY2VydGlmaWNhdGU6IChfYyA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5sb2NhbENlcnRpZmljYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHNvY2tldE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc29ja2V0UmVmVG9NZXNzYWdlKHNvY2tldEVudHJ5LnJlZiksXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ucmVtb3RlQWRkcmVzcylcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eU1lc3NhZ2UsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcbiAgICAgICAgICAgIHN0cmVhbXNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3NlbnQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfcmVjZWl2ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbG9jYWxfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5sb2NhbEZsb3dDb250cm9sV2luZG93IH1cbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93XG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVyU29ja2V0cyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCwgMTApO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL10uZ2V0RWxlbWVudEJ5S2V5KHNlcnZlcklkKTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBwYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc29ja2V0X2lkLCAxMCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cywgMTApIHx8IERFRkFVTFRfTUFYX1JFU1VMVFM7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIC8vIElmIHdlIHdhbnRlZCB0byBpbmNsdWRlIGxpc3RlbmVyIHNvY2tldHMgaW4gdGhlIHJlc3VsdCwgdGhpcyBsaW5lIHdvdWxkXG4gICAgLy8gaW5zdGVhZCBzYXlcbiAgICAvLyBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLmxpc3RlbmVyQ2hpbGRyZW4uc29ja2V0cy5jb25jYXQocmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzKS5zb3J0KChyZWYxLCByZWYyKSA9PiByZWYxLmlkIC0gcmVmMi5pZCk7XG4gICAgY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cztcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gYWxsU29ja2V0cy5sb3dlckJvdW5kKHN0YXJ0SWQpOyAhaS5lcXVhbHMoYWxsU29ja2V0cy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShpLnBvaW50ZXJbMV0ucmVmKSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc29ja2V0X3JlZjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpLmVxdWFscyhhbGxTb2NrZXRzLmVuZCgpKSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzLFxuICAgIH07XG59XG5sZXQgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24oKSB7XG4gICAgaWYgKGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xuICAgIH1cbiAgICAvKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNvbXBsZXhpdHkgaXMgdG8gYXZvaWQgbG9hZGluZyBAZ3JwYy9wcm90by1sb2FkZXIgYXRcbiAgICAgKiBydW50aW1lIGZvciB1c2VycyB3aG8gd2lsbCBub3QgdXNlL2VuYWJsZSBjaGFubmVsei4gKi9cbiAgICBjb25zdCBsb2FkZXJMb2FkU3luYyA9IHJlcXVpcmUoJ0BncnBjL3Byb3RvLWxvYWRlcicpXG4gICAgICAgIC5sb2FkU3luYztcbiAgICBjb25zdCBsb2FkZWRQcm90byA9IGxvYWRlckxvYWRTeW5jKCdjaGFubmVsei5wcm90bycsIHtcbiAgICAgICAga2VlcENhc2U6IHRydWUsXG4gICAgICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgICAgIGVudW1zOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgICAgICBvbmVvZnM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVEaXJzOiBbYCR7X19kaXJuYW1lfS8uLi8uLi9wcm90b2BdLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5uZWx6R3JwY09iamVjdCA9ICgwLCBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbikobG9hZGVkUHJvdG8pO1xuICAgIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9XG4gICAgICAgIGNoYW5uZWx6R3JwY09iamVjdC5ncnBjLmNoYW5uZWx6LnYxLkNoYW5uZWx6LnNlcnZpY2U7XG4gICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlKShnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uLCBnZXRDaGFubmVsekhhbmRsZXJzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWx6LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nexports.getInterceptingCall = getInterceptingCall;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: next => {\n        next();\n    },\n    cancel: next => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */\n        this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, finalMessage => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            }\n            else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    getAuthContext() {\n        return this.nextCall.getAuthContext();\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    constructor(call, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: metadata => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: message => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: status => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n    getAuthContext() {\n        return this.call.getAuthContext();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQtaW50ZXJjZXB0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcscUNBQXFDO0FBQ3JILDJCQUEyQjtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBa0I7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1JBQW9SO0FBQ3BSLGlSQUFpUjtBQUNqUiw4UUFBOFE7QUFDOVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxnQ0FBZ0M7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb09BQW9PO0FBQ3BPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQtaW50ZXJjZXB0b3JzLmpzP2Q1ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IGV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbi8qKlxuICogRXJyb3IgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHBhc3NpbmcgYm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yXG4gKiBwcm92aWRlcnMgdG8gYSBjbGllbnQgY29uc3RydWN0b3Igb3IgYXMgY2FsbCBvcHRpb25zLlxuICovXG5jbGFzcyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3InO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yO1xuY2xhc3MgTGlzdGVuZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1ldGFkYXRhKG9uUmVjZWl2ZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVTdGF0dXMob25SZWNlaXZlU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb25SZWNlaXZlU3RhdHVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBMaXN0ZW5lckJ1aWxkZXI7XG5jbGFzcyBSZXF1ZXN0ZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhTdGFydChzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoSGFsZkNsb3NlKGhhbGZDbG9zZSkge1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IGhhbGZDbG9zZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhDYW5jZWwoY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBoYWxmQ2xvc2U6IHRoaXMuaGFsZkNsb3NlLFxuICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBSZXF1ZXN0ZXJCdWlsZGVyO1xuLyoqXG4gKiBBIExpc3RlbmVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IExpc3RlbmVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0TGlzdGVuZXIgPSB7XG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChzdGF0dXMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBIFJlcXVlc3RlciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBSZXF1ZXN0ZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRSZXF1ZXN0ZXIgPSB7XG4gICAgc3RhcnQ6IChtZXRhZGF0YSwgbGlzdGVuZXIsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBoYWxmQ2xvc2U6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbn07XG5jbGFzcyBJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihuZXh0Q2FsbCwgcmVxdWVzdGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbCA9IG5leHRDYWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgbWV0YWRhdGEgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzdGFydFxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lc3NhZ2UgY29udGV4dCBmb3IgYSBwZW5kaW5nIG1lc3NhZ2UgdGhhdCBpcyB3YWl0aW5nIGZvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBtZXNzYWdlIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc2VuZE1lc3NhZ2VcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgc3RhdHVzIHdhcyByZWNlaXZlZCBidXQgY291bGQgbm90IGJlIHByb3BhZ2F0ZWQgYmVjYXVzZVxuICAgICAgICAgKiBhIG1lc3NhZ2Ugd2FzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICBpZiAocmVxdWVzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlciA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogKF9hID0gcmVxdWVzdGVyLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0UmVxdWVzdGVyLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAoX2IgPSByZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRSZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgaGFsZkNsb3NlOiAoX2MgPSByZXF1ZXN0ZXIuaGFsZkNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVxdWVzdGVyLmhhbGZDbG9zZSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IChfZCA9IHJlcXVlc3Rlci5jYW5jZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRSZXF1ZXN0ZXIuY2FuY2VsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0gZGVmYXVsdFJlcXVlc3RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5jYW5jZWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9kID0gKF9jID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKG1lc3NhZ2UgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9mID0gKF9lID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoc3RhdHVzID0+IHsgfSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc3RhcnQobWV0YWRhdGEsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciwgKG1kLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG4gICAgICAgICAgICBpZiAoKDAsIGNhbGxfaW50ZXJmYWNlXzEuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcikobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX2ludGVyZmFjZV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KG1kLCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgZmluYWxNZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaW5hbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuaGFsZkNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0QXV0aENvbnRleHQoKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBJbnRlcmNlcHRpbmdDYWxsO1xuZnVuY3Rpb24gZ2V0Q2FsbChjaGFubmVsLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkZWFkbGluZSA9IChfYSA9IG9wdGlvbnMuZGVhZGxpbmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xuICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgY29uc3QgcGFyZW50ID0gKF9iID0gb3B0aW9ucy5wYXJlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgY29uc3QgcHJvcGFnYXRlRmxhZ3MgPSBvcHRpb25zLnByb3BhZ2F0ZV9mbGFncztcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHM7XG4gICAgY29uc3QgY2FsbCA9IGNoYW5uZWwuY3JlYXRlQ2FsbChwYXRoLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50LCBwcm9wYWdhdGVGbGFncyk7XG4gICAgaWYgKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbDtcbn1cbi8qKlxuICogSW50ZXJjZXB0aW5nQ2FsbCBpbXBsZW1lbnRhdGlvbiB0aGF0IGRpcmVjdGx5IG93bnMgdGhlIHVuZGVybHlpbmcgQ2FsbFxuICogb2JqZWN0IGFuZCBoYW5kbGVzIHNlcmlhbGl6YXRpb24gYW5kIGRlc2VyYWl6bGlhdGlvbi5cbiAqL1xuY2xhc3MgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGhvZERlZmluaXRpb24gPSBtZXRob2REZWZpbml0aW9uO1xuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlcXVlc3RTZXJpYWxpemUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgYFJlcXVlc3QgbWVzc2FnZSBzZXJpYWxpemF0aW9uIGZhaWx1cmU6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBzZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xuICAgICAgICBsZXQgcmVhZEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0KG1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbGV0IGRlc2VyaWFsaXplZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VEZXNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3BvbnNlIG1lc3NhZ2UgcGFyc2luZyBlcnJvcjogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMocmVhZEVycm9yLmNvZGUsIHJlYWRFcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIGRlc2VyaWFsaXplZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgcmVhZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEF1dGhDb250ZXh0KCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCB1bmFyeVxuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcihjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZWNlaXZlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd3JhcHBlckxpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQobGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobWV0YWRhdGEgPT4geyB9KSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChsaXN0ZW5lciwgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLnN0YXJ0KG1ldGFkYXRhLCB3cmFwcGVyTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCBzdHJlYW1pbmdcbiAqIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwgZXh0ZW5kcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG59XG5mdW5jdGlvbiBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsKGNoYW5uZWwsIG9wdGlvbnMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1ldGhvZERlZmluaXRpb24pIHtcbiAgICBjb25zdCBjYWxsID0gZ2V0Q2FsbChjaGFubmVsLCBtZXRob2REZWZpbml0aW9uLnBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChtZXRob2REZWZpbml0aW9uLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1ldGhvZERlZmluaXRpb24sIG9wdGlvbnMsIGNoYW5uZWwpIHtcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgY2FsbCAnICtcbiAgICAgICAgICAgICdvcHRpb25zLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgIH1cbiAgICBsZXQgaW50ZXJjZXB0b3JzID0gW107XG4gICAgLy8gSW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2FsbCBvdmVycmlkZSBpbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjbGllbnQgY29uc3RydWN0b3JcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCB8fFxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcbiAgICB9XG4gICAgY29uc3QgaW50ZXJjZXB0b3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBtZXRob2RfZGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICB9KTtcbiAgICAvKiBGb3IgZWFjaCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdGhlIG5leHRDYWxsIGZ1bmN0aW9uIHBhc3NlZCB0byBpdCBpc1xuICAgICAqIGJhc2VkIG9uIHRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB1c2luZyBhIG5leHRDYWxsIGZ1bmN0aW9uXG4gICAgICogY29uc3RydWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCBhbmQgc28gb24uIFRoZVxuICAgICAqIGluaXRpYWxWYWx1ZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgaXMgYSBuZXh0Q2FsbFxuICAgICAqIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsLCB0aGUgcmVzdWx0IG9mIHdoaWNoXG4gICAgICogaGFuZGxlcyAoZGUpc2VyaWFsaXphdGlvbiBhbmQgYWxzbyBnZXRzIHRoZSB1bmRlcmx5aW5nIGNhbGwgZnJvbSB0aGVcbiAgICAgKiBjaGFubmVsLiAqL1xuICAgIGNvbnN0IGdldENhbGwgPSBpbnRlcmNlcHRvcnMucmVkdWNlUmlnaHQoKG5leHRDYWxsLCBuZXh0SW50ZXJjZXB0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPcHRpb25zID0+IG5leHRJbnRlcmNlcHRvcihjdXJyZW50T3B0aW9ucywgbmV4dENhbGwpO1xuICAgIH0sIChmaW5hbE9wdGlvbnMpID0+IGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgZmluYWxPcHRpb25zLCBtZXRob2REZWZpbml0aW9uKSk7XG4gICAgcmV0dXJuIGdldENhbGwoaW50ZXJjZXB0b3JPcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1pbnRlcmNlcHRvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n    var _a;\n    return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\\n').slice(1).join('\\n')) || 'no stack trace available';\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n            options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                isFunction(arg3))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.UNIMPLEMENTED,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\n                }\n                responseMessage = message;\n                call.startRead();\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.UNIMPLEMENTED,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFnRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC5qcz8zNmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfMSA9IHJlcXVpcmUoXCIuL2NhbGxcIik7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5jb25zdCBDSEFOTkVMX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgSU5URVJDRVBUT1JfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IENBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBnZXRFcnJvclN0YWNrU3RyaW5nKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJykpIHx8ICdubyBzdGFjayB0cmFjZSBhdmFpbGFibGUnO1xufVxuLyoqXG4gKiBBIGdlbmVyaWMgZ1JQQyBjbGllbnQuIFByaW1hcmlseSB1c2VmdWwgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ2VuZXJhdGVkXG4gKiBjbGllbnRzLlxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0gPSAoX2EgPSBvcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9ycztcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdID0gKF9iID0gb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnM7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0gPVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gb3B0aW9ucy5jaGFubmVsT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmFjdG9yeU92ZXJyaWRlID0gb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gY2hhbm5lbEZhY3RvcnlPdmVycmlkZShhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG5ldyBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0uY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0hBTk5FTF9TWU1CT0xdO1xuICAgIH1cbiAgICB3YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrU3RhdGUgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBiZWZvcmUgdGhlIGRlYWRsaW5lJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzW0NIQU5ORUxfU1lNQk9MXS5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS53YXRjaENvbm5lY3Rpdml0eVN0YXRlKG5ld1N0YXRlLCBkZWFkbGluZSwgY2hlY2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrU3RhdGUpO1xuICAgIH1cbiAgICBjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IGFyZzEsIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIGFyZzIgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGFyZzMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiBhcmcyLCBjYWxsYmFjazogYXJnMyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VVbmFyeVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50VW5hcnlDYWxsSW1wbCgpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhudWxsLCByZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UoYXJndW1lbnQpO1xuICAgICAgICBjYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgbWFrZUNsaWVudFN0cmVhbVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbChzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfVxuICAgIGNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IGFyZzE7XG4gICAgICAgICAgICBpZiAoYXJnMikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtZXRhZGF0YSwgb3B0aW9ucyB9O1xuICAgIH1cbiAgICBtYWtlU2VydmVyU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja01ldGFkYXRhQW5kT3B0aW9ucyhtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwoZGVzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UoYXJndW1lbnQpO1xuICAgICAgICBjYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICBtYWtlQmlkaVN0cmVhbVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja01ldGFkYXRhQW5kT3B0aW9ucyhtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudER1cGxleFN0cmVhbUltcGwoc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function (CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qiw2QkFBNkIsNkJBQTZCO0FBQ3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbXByZXNzaW9uLWFsZ29yaXRobXMuanM/ODM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSB2b2lkIDA7XG52YXIgQ29tcHJlc3Npb25BbGdvcml0aG1zO1xuKGZ1bmN0aW9uIChDb21wcmVzc2lvbkFsZ29yaXRobXMpIHtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiaWRlbnRpdHlcIl0gPSAwXSA9IFwiaWRlbnRpdHlcIjtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZGVmbGF0ZVwiXSA9IDFdID0gXCJkZWZsYXRlXCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImd6aXBcIl0gPSAyXSA9IFwiZ3ppcFwiO1xufSkoQ29tcHJlc3Npb25BbGdvcml0aG1zIHx8IChleHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IENvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key) => {\n    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createInflate();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createGunzip();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler(maxReceiveMessageSize);\n        case 'gzip':\n            return new GzipHandler(maxReceiveMessageSize);\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig) {\n        var _a, _b, _c;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === void 0 ? void 0 : _c.split(',');\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */\n                if (!serverSupportedEncodings ||\n                    serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\n                }\n            }\n            else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === 'identity') {\n            headers.remove('grpc-encoding');\n        }\n        else {\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader =\n                serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = 'identity';\n            }\n        }\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {\n            throw {\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`\n            };\n        }\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        }\n        else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options) {\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx5QkFBeUI7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlDQUFpQyxtQkFBTyxDQUFDLG1IQUEwQjtBQUNuRSxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsMEJBQTBCO0FBQ3ZILHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcscUJBQXFCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxxQkFBcUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBcUksd0JBQXdCO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsMEJBQTBCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanM/NDE4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1trZXldID09PSAnc3RyaW5nJyk7XG59O1xuY2xhc3MgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBSYXcgdW5jb21wcmVzc2VkIG1lc3NhZ2UgYnl0ZXNcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGNvbXByZXNzZWRcbiAgICAgKiBAcmV0dXJuIEZyYW1lZCBtZXNzYWdlLCBjb21wcmVzc2VkIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoY29tcHJlc3MpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZUJ1ZmZlci5sZW5ndGggKyA1KTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoY29tcHJlc3MgPyAxIDogMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2VCdWZmZXIubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIEZyYW1lZCBtZXNzYWdlLCBwb3NzaWJseSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBVbmNvbXByZXNzZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGRhdGEucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IGRhdGEuc2xpY2UoNSk7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZUJ1ZmZlcjtcbiAgICB9XG59XG5jbGFzcyBJZGVudGl0eUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGFzeW5jIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2UubGVuZ3RoICsgNSk7XG4gICAgICAgIC8qIFdpdGggXCJpZGVudGl0eVwiIGNvbXByZXNzaW9uLCBtZXNzYWdlcyBzaG91bGQgYWx3YXlzIGJlIG1hcmtlZCBhc1xuICAgICAgICAgKiB1bmNvbXByZXNzZWQgKi9cbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2UubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZS5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUmVjZWl2ZWQgY29tcHJlc3NlZCBtZXNzYWdlIGJ1dCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgd2FzIGlkZW50aXR5JykpO1xuICAgIH1cbn1cbmNsYXNzIERlZmxhdGVIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoID0gbWF4UmVjdk1lc3NhZ2VMZW5ndGg7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmRlZmxhdGUobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZSgpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLndyaXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBHemlwSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCA9IG1heFJlY3ZNZXNzYWdlTGVuZ3RoO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5nemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUd1bnppcCgpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLndyaXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBVbmtub3duSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25OYW1lID0gY29tcHJlc3Npb25OYW1lO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2QgJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQ6ICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXByZXNzaW9uSGFuZGxlcihjb21wcmVzc2lvbk5hbWUsIG1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xuICAgIHN3aXRjaCAoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcihtYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xuICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3ppcEhhbmRsZXIobWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxPcHRpb25zLCBzaGFyZWRGaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0gc2hhcmVkRmlsdGVyQ29uZmlnO1xuICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSddO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoID0gKF9hID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aCA9IChfYiA9IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbkFsZ29yaXRobUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleShjb21wcmVzc2lvbkFsZ29yaXRobUtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTZWxlY3RlZEVuY29kaW5nID0gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1tjb21wcmVzc2lvbkFsZ29yaXRobUtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzID0gKF9jID0gc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNpdHVhdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiAxKSBXZSBkb24ndCBoYXZlIGFueSBpbmZvIHlldCBmcm9tIHRoZSBzZXJ2ZXIgYWJvdXQgd2hhdCBjb21wcmVzc2lvbiBpdCBzdXBwb3J0c1xuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBzaG91bGQganVzdCB1c2Ugd2hhdCB0aGUgY2xpZW50IHRlbGxzIHVzIHRvIHVzZVxuICAgICAgICAgICAgICAgICAqIDIpIFdlJ3ZlIHByZXZpb3VzbHkgcmVjZWl2ZWQgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgaW5jbHVkaW5nIGEgZ3JwYy1hY2NlcHQtZW5jb2RpbmcgaGVhZGVyXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGVuY29kaW5nIGNob3NlbiBieSB0aGUgY2xpZW50IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgaXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyB8fFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXMoY2xpZW50U2VsZWN0ZWRFbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSBjbGllbnRTZWxlY3RlZEVuY29kaW5nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcih0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYEludmFsaWQgdmFsdWUgcHJvdmlkZWQgZm9yIGdycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0gb3B0aW9uOiAke2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgbWV0YWRhdGE7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdncnBjLWFjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eSxkZWZsYXRlLGd6aXAnKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScpO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHNlbmQgdGhlIGhlYWRlciBpZiBpdCdzIFwiaWRlbnRpdHlcIiAtICBiZWhhdmlvciBpcyBpZGVudGljYWw7IHNhdmUgdGhlIGJhbmR3aWR0aFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIGhlYWRlcnMucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1lbmNvZGluZycsIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVFbmNvZGluZyA9IG1ldGFkYXRhLmdldCgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBpZiAocmVjZWl2ZUVuY29kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVjZWl2ZUVuY29kaW5nWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcihlbmNvZGluZywgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB0aGUgY29tcHJlc3Npb24gd2UncmUgdXNpbmcgdG8gc2VuZCBtZXNzYWdlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlclxuICAgICAgICAgKiBJZiBub3QsIHJlc2V0IHRoZSBzZW5kQ29tcHJlc3Npb24gZmlsdGVyIGFuZCBoYXZlIGl0IHVzZSB0aGUgZGVmYXVsdCBJZGVudGl0eUhhbmRsZXIgKi9cbiAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyID0gbWV0YWRhdGEuZ2V0KCdncnBjLWFjY2VwdC1lbmNvZGluZycpWzBdO1xuICAgICAgICBpZiAoc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZy5zZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlciA9XG4gICAgICAgICAgICAgICAgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyO1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzID0gc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoIXNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWFjY2VwdC1lbmNvZGluZycpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyB0aGUgYmFyZSBtZXNzYWdlIGJ5dGVzLFxuICAgICAgICAgKiBhbmQgdGhlIG91dHB1dCBpcyBhIGZyYW1lZCBhbmQgcG9zc2libHkgY29tcHJlc3NlZCBtZXNzYWdlLiBGb3IgdGhpc1xuICAgICAgICAgKiByZWFzb24sIHRoaXMgZmlsdGVyIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBmaWx0ZXIgc3RhY2sgKi9cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMubWF4U2VuZE1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHJlc29sdmVkTWVzc2FnZS5tZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4U2VuZE1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBBdHRlbXB0ZWQgdG8gc2VuZCBtZXNzYWdlIHdpdGggYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aH1gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wcmVzcztcbiAgICAgICAgaWYgKHRoaXMuc2VuZENvbXByZXNzaW9uIGluc3RhbmNlb2YgSWRlbnRpdHlIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxuICAgICAgICAgICAgZmxhZ3M6IHJlc29sdmVkTWVzc2FnZS5mbGFncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBhbHNvIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIGZyYW1lZCBhbmQgcG9zc2libHlcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xuICAgICAgICAgKiB0aGlzIGlzIGFub3RoZXIgcmVhc29uIHRoYXQgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAgICAqIGZpbHRlciBzdGFjay4gKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3Npb25GaWx0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2Nvbm5lY3Rpdml0eS1zdGF0ZS5qcz8wNjhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0gdm9pZCAwO1xudmFyIENvbm5lY3Rpdml0eVN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aXZpdHlTdGF0ZSkge1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlJFQURZXCJdID0gMl0gPSBcIlJFQURZXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDNdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiU0hVVERPV05cIl0gPSA0XSA9IFwiU0hVVERPV05cIjtcbn0pKENvbm5lY3Rpdml0eVN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0gQ29ubmVjdGl2aXR5U3RhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGl2aXR5LXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function (Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function (LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */\nvar Propagate;\n(function (Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQ0FBMEMsR0FBRyx1Q0FBdUMsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhLGNBQWMsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwwQ0FBMEM7QUFDMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzPzUxYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuUHJvcGFnYXRlID0gZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBleHBvcnRzLlN0YXR1cyA9IHZvaWQgMDtcbnZhciBTdGF0dXM7XG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xufSkoU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IFN0YXR1cyA9IHt9KSk7XG52YXIgTG9nVmVyYm9zaXR5O1xuKGZ1bmN0aW9uIChMb2dWZXJib3NpdHkpIHtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIk5PTkVcIl0gPSAzXSA9IFwiTk9ORVwiO1xufSkoTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IExvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0gUHJvcGFnYXRlID0ge30pKTtcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxuZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gLTE7XG4vLyA0IE1CIGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS,\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,\n        };\n    }\n    else {\n        return { code, details };\n    }\n}\n//# sourceMappingURL=control-plane-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb250cm9sLXBsYW5lLXN0YXR1cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQztBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanM/MmZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGU7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUyA9IFtcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFCT1JURUQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTLFxuXTtcbmZ1bmN0aW9uIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShjb2RlLCBkZXRhaWxzKSB7XG4gICAgaWYgKElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgZGV0YWlsczogYEludmFsaWQgc3RhdHVzIGZyb20gY29udHJvbCBwbGFuZTogJHtjb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tjb2RlXX0gJHtkZXRhaWxzfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbC1wbGFuZS1zdGF0dXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.minDeadline = minDeadline;\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\nexports.getRelativeTimeout = getRelativeTimeout;\nexports.deadlineToString = deadlineToString;\nexports.formatDateDifference = formatDateDifference;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList) {\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */\nfunction getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    }\n    else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    }\n    else {\n        return timeout;\n    }\n}\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    }\n    else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return '' + deadline;\n        }\n        else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\n/**\n * Calculate the difference between two dates as a number of seconds and format\n * it as a string.\n * @param startDate\n * @param endDate\n * @returns\n */\nfunction formatDateDifference(startDate, endDate) {\n    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';\n}\n//# sourceMappingURL=deadline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kZWFkbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanM/MDliZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taW5EZWFkbGluZSA9IG1pbkRlYWRsaW5lO1xuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XG5leHBvcnRzLmdldFJlbGF0aXZlVGltZW91dCA9IGdldFJlbGF0aXZlVGltZW91dDtcbmV4cG9ydHMuZGVhZGxpbmVUb1N0cmluZyA9IGRlYWRsaW5lVG9TdHJpbmc7XG5leHBvcnRzLmZvcm1hdERhdGVEaWZmZXJlbmNlID0gZm9ybWF0RGF0ZURpZmZlcmVuY2U7XG5mdW5jdGlvbiBtaW5EZWFkbGluZSguLi5kZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0TXMgPSBNYXRoLm1heChkZWFkbGluZSAtIG5vdywgMCk7XG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XG4gICAgICAgIGlmIChhbW91bnQgPCAxZTgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xufVxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCNzZXR0aW1lb3V0Y2FsbGJhY2stZGVsYXktYXJnc1xuICogSW4gcGFydGljdWxhciwgXCJXaGVuIGRlbGF5IGlzIGxhcmdlciB0aGFuIDIxNDc0ODM2NDcgb3IgbGVzcyB0aGFuIDEsIHRoZVxuICogZGVsYXkgd2lsbCBiZSBzZXQgdG8gMS4gTm9uLWludGVnZXIgZGVsYXlzIGFyZSB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cIlxuICogVGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGlzIGFsbW9zdCAyNSBkYXlzLlxuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0Nztcbi8qKlxuICogR2V0IHRoZSB0aW1lb3V0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBzZXRUaW1lb3V0IG5vdyBmb3IgdGhlIHRpbWVyXG4gKiB0byBlbmQgYXQgdGhlIGRlYWRsaW5lLiBGb3IgYW55IGRlYWRsaW5lIGJlZm9yZSBub3csIHRoZSB0aW1lciBzaG91bGQgZW5kXG4gKiBpbW1lZGlhdGVseSwgcmVwcmVzZW50ZWQgYnkgYSB2YWx1ZSBvZiAwLiBGb3IgYW55IGRlYWRsaW5lIG1vcmUgdGhhblxuICogTUFYX1RJTUVPVVRfVElNRSBtaWxsaXNlY29uZHMgaW4gdGhlIGZ1dHVyZSwgYSB0aW1lciBjYW5ub3QgYmUgc2V0IHRoYXQgd2lsbFxuICogZW5kIGF0IHRoYXQgdGltZSwgc28gaXQgaXMgdHJlYXRlZCBhcyBpbmZpbml0ZWx5IGZhciBpbiB0aGUgZnV0dXJlLlxuICogQHBhcmFtIGRlYWRsaW5lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWVvdXQoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBkZWFkbGluZU1zID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZW91dCA9IGRlYWRsaW5lTXMgLSBub3c7XG4gICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aW1lb3V0ID4gTUFYX1RJTUVPVVRfVElNRSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWFkbGluZVRvU3RyaW5nKGRlYWRsaW5lKSB7XG4gICAgaWYgKGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gZGVhZGxpbmUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGVEZWFkbGluZSA9IG5ldyBEYXRlKGRlYWRsaW5lKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihkYXRlRGVhZGxpbmUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZGVhZGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZURlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBkYXRlcyBhcyBhIG51bWJlciBvZiBzZWNvbmRzIGFuZCBmb3JtYXRcbiAqIGl0IGFzIGEgc3RyaW5nLlxuICogQHBhcmFtIHN0YXJ0RGF0ZVxuICogQHBhcmFtIGVuZERhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGVEaWZmZXJlbmNlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICAgIHJldHVybiAoKGVuZERhdGUuZ2V0VGltZSgpIC0gc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwKS50b0ZpeGVkKDMpICsgJ3MnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVhZGxpbmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.durationMessageToDuration = durationMessageToDuration;\nexports.msToDuration = msToDuration;\nexports.durationToMs = durationToMs;\nexports.isDuration = isDuration;\nexports.isDurationMessage = isDurationMessage;\nexports.parseDuration = parseDuration;\nexports.durationToString = durationToString;\nfunction durationMessageToDuration(message) {\n    return {\n        seconds: Number.parseInt(message.seconds),\n        nanos: message.nanos\n    };\n}\nfunction msToDuration(millis) {\n    return {\n        seconds: (millis / 1000) | 0,\n        nanos: ((millis % 1000) * 1000000) | 0,\n    };\n}\nfunction durationToMs(duration) {\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\n}\nfunction isDuration(value) {\n    return typeof value.seconds === 'number' && typeof value.nanos === 'number';\n}\nfunction isDurationMessage(value) {\n    return typeof value.seconds === 'string' && typeof value.nanos === 'number';\n}\nconst durationRegex = /^(\\d+)(?:\\.(\\d+))?s$/;\nfunction parseDuration(value) {\n    const match = value.match(durationRegex);\n    if (!match) {\n        return null;\n    }\n    return {\n        seconds: Number.parseInt(match[1], 10),\n        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, '0'), 10) : 0\n    };\n}\nfunction durationToString(duration) {\n    if (duration.nanos === 0) {\n        return `${duration.seconds}s`;\n    }\n    let scaleFactor;\n    if (duration.nanos % 1000000 === 0) {\n        scaleFactor = 1000000;\n    }\n    else if (duration.nanos % 1000 === 0) {\n        scaleFactor = 1000;\n    }\n    else {\n        scaleFactor = 1;\n    }\n    return `${duration.seconds}.${duration.nanos / scaleFactor}s`;\n}\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kdXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLEdBQUcsNkJBQTZCO0FBQy9EO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanM/MjAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kdXJhdGlvbk1lc3NhZ2VUb0R1cmF0aW9uID0gZHVyYXRpb25NZXNzYWdlVG9EdXJhdGlvbjtcbmV4cG9ydHMubXNUb0R1cmF0aW9uID0gbXNUb0R1cmF0aW9uO1xuZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBkdXJhdGlvblRvTXM7XG5leHBvcnRzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuZXhwb3J0cy5pc0R1cmF0aW9uTWVzc2FnZSA9IGlzRHVyYXRpb25NZXNzYWdlO1xuZXhwb3J0cy5wYXJzZUR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbjtcbmV4cG9ydHMuZHVyYXRpb25Ub1N0cmluZyA9IGR1cmF0aW9uVG9TdHJpbmc7XG5mdW5jdGlvbiBkdXJhdGlvbk1lc3NhZ2VUb0R1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiBOdW1iZXIucGFyc2VJbnQobWVzc2FnZS5zZWNvbmRzKSxcbiAgICAgICAgbmFub3M6IG1lc3NhZ2UubmFub3NcbiAgICB9O1xufVxuZnVuY3Rpb24gbXNUb0R1cmF0aW9uKG1pbGxpcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IChtaWxsaXMgLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkgfCAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBkdXJhdGlvblRvTXMoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gKGR1cmF0aW9uLnNlY29uZHMgKiAxMDAwICsgZHVyYXRpb24ubmFub3MgLyAxMDAwMDAwKSB8IDA7XG59XG5mdW5jdGlvbiBpc0R1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5zZWNvbmRzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUubmFub3MgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNEdXJhdGlvbk1lc3NhZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XG59XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL14oXFxkKykoPzpcXC4oXFxkKykpP3MkLztcbmZ1bmN0aW9uIHBhcnNlRHVyYXRpb24odmFsdWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKGR1cmF0aW9uUmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgICAgICBuYW5vczogbWF0Y2hbMl0gPyBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0ucGFkRW5kKDksICcwJyksIDEwKSA6IDBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHVyYXRpb25Ub1N0cmluZyhkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbi5uYW5vcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7ZHVyYXRpb24uc2Vjb25kc31zYDtcbiAgICB9XG4gICAgbGV0IHNjYWxlRmFjdG9yO1xuICAgIGlmIChkdXJhdGlvbi5uYW5vcyAlIDEwMDAwMDAgPT09IDApIHtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSAxMDAwMDAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdXJhdGlvbi5uYW5vcyAlIDEwMDAgPT09IDApIHtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSAxMDAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZHVyYXRpb24uc2Vjb25kc30uJHtkdXJhdGlvbi5uYW5vcyAvIHNjYWxlRmFjdG9yfXNgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/environment.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/environment.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== void 0 ? _a : 'false') === 'true';\n//# sourceMappingURL=environment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lbnZpcm9ubWVudC5qcz81YmFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI0IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIgPSB2b2lkIDA7XG5leHBvcnRzLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIgPSAoKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1VTRV9BTFRFUk5BVElWRV9SRVNPTFZFUikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2ZhbHNlJykgPT09ICd0cnVlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmlyb25tZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/environment.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorMessage = getErrorMessage;\nexports.getErrorCode = getErrorCode;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    }\n    else {\n        return String(error);\n    }\n}\nfunction getErrorCode(error) {\n    if (typeof error === 'object' &&\n        error !== null &&\n        'code' in error &&\n        typeof error.code === 'number') {\n        return error.code;\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcz8xMTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbmV4cG9ydHMuZ2V0RXJyb3JDb2RlID0gZ2V0RXJyb3JDb2RlO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcnJvckNvZGUoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICAnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5jb2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.statusOrFromError = exports.statusOrFromValue = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.CHANNEL_ARGS_CONFIG_SELECTOR_KEY = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\nObject.defineProperty(exports, \"createResolver\", ({ enumerable: true, get: function () { return resolver_1.createResolver; } }));\nObject.defineProperty(exports, \"CHANNEL_ARGS_CONFIG_SELECTOR_KEY\", ({ enumerable: true, get: function () { return resolver_1.CHANNEL_ARGS_CONFIG_SELECTOR_KEY; } }));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\nObject.defineProperty(exports, \"splitHostPort\", ({ enumerable: true, get: function () { return uri_parser_1.splitHostPort; } }));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\nObject.defineProperty(exports, \"parseDuration\", ({ enumerable: true, get: function () { return duration_1.parseDuration; } }));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\nObject.defineProperty(exports, \"selectLbConfigFromList\", ({ enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } }));\nObject.defineProperty(exports, \"parseLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } }));\nObject.defineProperty(exports, \"isLoadBalancerNameRegistered\", ({ enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } }));\nvar load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nObject.defineProperty(exports, \"LeafLoadBalancer\", ({ enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } }));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\nObject.defineProperty(exports, \"endpointToString\", ({ enumerable: true, get: function () { return subchannel_address_1.endpointToString; } }));\nObject.defineProperty(exports, \"endpointHasAddress\", ({ enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } }));\nObject.defineProperty(exports, \"EndpointMap\", ({ enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } }));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\nvar call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nObject.defineProperty(exports, \"statusOrFromValue\", ({ enumerable: true, get: function () { return call_interface_1.statusOrFromValue; } }));\nObject.defineProperty(exports, \"statusOrFromError\", ({ enumerable: true, get: function () { return call_interface_1.statusOrFromError; } }));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\nvar server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"createServerCredentialsWithInterceptors\", ({ enumerable: true, get: function () { return server_credentials_1.createServerCredentialsWithInterceptors; } }));\nObject.defineProperty(exports, \"createCertificateProviderServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.createCertificateProviderServerCredentials; } }));\nvar certificate_provider_1 = __webpack_require__(/*! ./certificate-provider */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\");\nObject.defineProperty(exports, \"FileWatcherCertificateProvider\", ({ enumerable: true, get: function () { return certificate_provider_1.FileWatcherCertificateProvider; } }));\nvar channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"createCertificateProviderChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.createCertificateProviderChannelCredentials; } }));\nvar internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nObject.defineProperty(exports, \"SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX\", ({ enumerable: true, get: function () { return internal_channel_1.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsbURBQW1ELEdBQUcsc0NBQXNDLEdBQUcsa0RBQWtELEdBQUcsK0NBQStDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsZ0NBQWdDLEdBQUcsbUJBQW1CLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsaUNBQWlDLEdBQUcsd0JBQXdCLEdBQUcsb0NBQW9DLEdBQUcsZ0NBQWdDLEdBQUcsOEJBQThCLEdBQUcsZ0NBQWdDLEdBQUcsdUNBQXVDLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsd0NBQXdDLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsV0FBVyxHQUFHLGFBQWE7QUFDL2pDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRyx1Q0FBc0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDdkcsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7QUFDckMsb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxvRUFBbUUsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDbEssbUJBQW1CLG1CQUFPLENBQUMsMkZBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUNyQyxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILHdCQUF3QixtQkFBTyxDQUFDLHFHQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksc0JBQXNCLG1CQUFPLENBQUMsaUdBQWlCO0FBQy9DLG1FQUFrRSxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUNySyw0REFBMkQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDdkosMERBQXlELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ25KLDREQUEyRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUN2SixnRUFBK0QsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDL0osaUNBQWlDLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3JFLG9EQUFtRCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUNsSiwyQkFBMkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDekQsNkRBQTRELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQzlKLG9EQUFtRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM1SSxzREFBcUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDaEosK0NBQThDLEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ2xJLG9DQUFvQyxtQkFBTyxDQUFDLDZIQUErQjtBQUMzRSw0REFBMkQsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDckssZUFBZSxtQkFBTyxDQUFDLG1GQUFVO0FBQ2pDLHFEQUFvRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNsSSwrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEgsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILHVCQUF1QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNqRCxxREFBb0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDMUkscURBQW9ELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQzFJLGVBQWUsbUJBQU8sQ0FBQyxtRkFBVTtBQUNqQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgscUJBQXFCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQzdDLHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSxjQUFjLG1CQUFPLENBQUMsaUZBQVM7QUFDL0Isd0RBQXVELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3ZJLDZCQUE2QixtQkFBTyxDQUFDLCtHQUF3QjtBQUM3RCx5REFBd0QsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDeEosMkJBQTJCLG1CQUFPLENBQUMsMkdBQXNCO0FBQ3pELDJFQUEwRSxFQUFFLHFDQUFxQyx3RUFBd0UsRUFBQztBQUMxTCw4RUFBNkUsRUFBRSxxQ0FBcUMsMkVBQTJFLEVBQUM7QUFDaE0sNkJBQTZCLG1CQUFPLENBQUMsK0dBQXdCO0FBQzdELGtFQUFpRSxFQUFFLHFDQUFxQyxpRUFBaUUsRUFBQztBQUMxSyw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDM0QsK0VBQThFLEVBQUUscUNBQXFDLDZFQUE2RSxFQUFDO0FBQ25NLHlCQUF5QixtQkFBTyxDQUFDLHVHQUFvQjtBQUNyRCxzRUFBcUUsRUFBRSxxQ0FBcUMsaUVBQWlFLEVBQUM7QUFDOUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzPzAxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVggPSBleHBvcnRzLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHMgPSBleHBvcnRzLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlciA9IGV4cG9ydHMuY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzID0gZXhwb3J0cy5jcmVhdGVTZXJ2ZXJDcmVkZW50aWFsc1dpdGhJbnRlcmNlcHRvcnMgPSBleHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSBleHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlciA9IGV4cG9ydHMuc3RhdHVzT3JGcm9tRXJyb3IgPSBleHBvcnRzLnN0YXR1c09yRnJvbVZhbHVlID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IGV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBleHBvcnRzLkVuZHBvaW50TWFwID0gZXhwb3J0cy5lbmRwb2ludEhhc0FkZHJlc3MgPSBleHBvcnRzLmVuZHBvaW50VG9TdHJpbmcgPSBleHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBleHBvcnRzLkxlYWZMb2FkQmFsYW5jZXIgPSBleHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBleHBvcnRzLnBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuc2VsZWN0TGJDb25maWdGcm9tTGlzdCA9IGV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IGV4cG9ydHMucGFyc2VEdXJhdGlvbiA9IGV4cG9ydHMuZHVyYXRpb25Ub01zID0gZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gZXhwb3J0cy51cmlUb1N0cmluZyA9IGV4cG9ydHMuQ0hBTk5FTF9BUkdTX0NPTkZJR19TRUxFQ1RPUl9LRVkgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gZXhwb3J0cy5sb2cgPSBleHBvcnRzLnRyYWNlID0gdm9pZCAwO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLnRyYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEubG9nOyB9IH0pO1xudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ0hBTk5FTF9BUkdTX0NPTkZJR19TRUxFQ1RPUl9LRVlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEuQ0hBTk5FTF9BUkdTX0NPTkZJR19TRUxFQ1RPUl9LRVk7IH0gfSk7XG52YXIgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaVRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzcGxpdEhvc3RQb3J0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydDsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VEdXJhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb25fMS5wYXJzZUR1cmF0aW9uOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGVjdExiQ29uZmlnRnJvbUxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5zZWxlY3RMYkNvbmZpZ0Zyb21MaXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEucGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7IH0gfSk7XG52YXIgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0XzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMZWFmTG9hZEJhbGFuY2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMS5MZWFmTG9hZEJhbGFuY2VyOyB9IH0pO1xudmFyIHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuZHBvaW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50VG9TdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmRwb2ludEhhc0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50SGFzQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuZHBvaW50TWFwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5FbmRwb2ludE1hcDsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyOyB9IH0pO1xudmFyIHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5hdmFpbGFibGVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVldWVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlF1ZXVlUGlja2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGlja1Jlc3VsdFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlOyB9IH0pO1xudmFyIGNhbGxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9jYWxsLWludGVyZmFjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0YXR1c09yRnJvbVZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsX2ludGVyZmFjZV8xLnN0YXR1c09yRnJvbVZhbHVlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdHVzT3JGcm9tRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxfaW50ZXJmYWNlXzEuc3RhdHVzT3JGcm9tRXJyb3I7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG52YXIgY2VydGlmaWNhdGVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2NlcnRpZmljYXRlLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjZXJ0aWZpY2F0ZV9wcm92aWRlcl8xLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlcjsgfSB9KTtcbnZhciBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF9jcmVkZW50aWFsc18xLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XG52YXIgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX2NoYW5uZWxfMS5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories) {\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([...this.factories]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map(factory => factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory;\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXItc3RhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXItc3RhY2suanM/MDJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBleHBvcnRzLkZpbHRlclN0YWNrID0gdm9pZCAwO1xuY2xhc3MgRmlsdGVyU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZU1ldGFkYXRhKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXR1cztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVUcmFpbGVycyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHB1c2goZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMudW5zaGlmdCguLi5maWx0ZXJzKTtcbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrID0gRmlsdGVyU3RhY2s7XG5jbGFzcyBGaWx0ZXJTdGFja0ZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJGYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMudW5zaGlmdCguLi5maWx0ZXJGYWN0b3JpZXMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFja0ZhY3RvcnkoWy4uLnRoaXMuZmFjdG9yaWVzXSk7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFjayh0aGlzLmZhY3Rvcmllcy5tYXAoZmFjdG9yeSA9PiBmYWN0b3J5LmNyZWF0ZUZpbHRlcigpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBGaWx0ZXJTdGFja0ZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXItc3RhY2suanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter;\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanM/ZDk1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUZpbHRlciA9IEJhc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseCIDR = parseCIDR;\nexports.mapProxyName = mapProxyName;\nexports.getProxiedConnection = getProxiedConnection;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`,\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\n/*\n * The groups correspond to CIDR parts as follows:\n * 1. ip\n * 2. prefixLength\n */\nfunction parseCIDR(cidrString) {\n    const splitRange = cidrString.split('/');\n    if (splitRange.length !== 2) {\n        return null;\n    }\n    const prefixLength = parseInt(splitRange[1], 10);\n    if (!(0, net_1.isIPv4)(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {\n        return null;\n    }\n    return {\n        ip: ipToInt(splitRange[0]),\n        prefixLength: prefixLength\n    };\n}\nfunction ipToInt(ip) {\n    return ip.split(\".\").reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);\n}\nfunction isIpInCIDR(cidr, serverHost) {\n    const ip = cidr.ip;\n    const mask = -1 << (32 - cidr.prefixLength);\n    const hostIP = ipToInt(serverHost);\n    return (hostIP & mask) === (ip & mask);\n}\nfunction hostMatchesNoProxyList(serverHost) {\n    for (const host of getNoProxyHostList()) {\n        const parsedCIDR = parseCIDR(host);\n        // host is a CIDR and serverHost is an IP address\n        if ((0, net_1.isIPv4)(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {\n            return true;\n        }\n        else if (serverHost.endsWith(host)) {\n            // host is a single IP or a domain name suffix\n            return true;\n        }\n    }\n    return false;\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === 'unix') {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    if (hostMatchesNoProxyList(serverHost)) {\n        trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n        return noProxyResult;\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nfunction getProxiedConnection(address, channelOptions) {\n    var _a;\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve(null);\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve(null);\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve(null);\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: 'CONNECT',\n        path: hostPort,\n    };\n    const headers = {\n        Host: hostPort,\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        headers['Proxy-Authorization'] =\n            'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                // The HTTP client may have already read a few bytes of the proxied\n                // connection. If that's the case, put them back into the socket.\n                // See https://github.com/grpc/grpc-node/issues/2744.\n                if (head.length > 0) {\n                    socket.unshift(head);\n                }\n                trace('Successfully established a plaintext connection to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                resolve(socket);\n            }\n            else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', err => {\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsa0JBQWtCLG1CQUFPLENBQUMscUZBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixPQUFPO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLGtCQUFrQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMsR0FBRyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUIsR0FBRyx1RkFBdUY7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcz80NTdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQ0lEUiA9IHBhcnNlQ0lEUjtcbmV4cG9ydHMubWFwUHJveHlOYW1lID0gbWFwUHJveHlOYW1lO1xuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCByZXNvbHZlcl9kbnNfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Byb3h5JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlJbmZvKCkge1xuICAgIGxldCBwcm94eUVudiA9ICcnO1xuICAgIGxldCBlbnZWYXIgPSAnJztcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnaHR0cF9wcm94eScgaWYgaXQgaXMgbm90IHNldC5cbiAgICAgKiBBbHNvIHByZWZlciB1c2luZyAnaHR0cHNfcHJveHknIHdpdGggZmFsbGJhY2sgb24gJ2h0dHBfcHJveHknLiBUaGVcbiAgICAgKiBmYWxsYmFjayBiZWhhdmlvciBjYW4gYmUgcmVtb3ZlZCBpZiB0aGVyZSdzIGEgZGVtYW5kIGZvciBpdC5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuZ3JwY19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnZ3JwY19wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuZ3JwY19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICAgICAgZW52VmFyID0gJ2h0dHBzX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cF9wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHByb3h5VXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChwcm94eUVudik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBcIiR7cHJveHlVcmwucHJvdG9jb2x9XCIgc2NoZW1lIG5vdCBzdXBwb3J0ZWQgaW4gcHJveHkgVVJJYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHVzZXJDcmVkID0gbnVsbDtcbiAgICBpZiAocHJveHlVcmwudXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKHByb3h5VXJsLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sICd1c2VyaW5mbyBmb3VuZCBpbiBwcm94eSBVUkknKTtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gZGVjb2RlVVJJQ29tcG9uZW50KGAke3Byb3h5VXJsLnVzZXJuYW1lfToke3Byb3h5VXJsLnBhc3N3b3JkfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKlxuICogVGhlIGdyb3VwcyBjb3JyZXNwb25kIHRvIENJRFIgcGFydHMgYXMgZm9sbG93czpcbiAqIDEuIGlwXG4gKiAyLiBwcmVmaXhMZW5ndGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VDSURSKGNpZHJTdHJpbmcpIHtcbiAgICBjb25zdCBzcGxpdFJhbmdlID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuICAgIGlmIChzcGxpdFJhbmdlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gcGFyc2VJbnQoc3BsaXRSYW5nZVsxXSwgMTApO1xuICAgIGlmICghKDAsIG5ldF8xLmlzSVB2NCkoc3BsaXRSYW5nZVswXSkgfHwgTnVtYmVyLmlzTmFOKHByZWZpeExlbmd0aCkgfHwgcHJlZml4TGVuZ3RoIDwgMCB8fCBwcmVmaXhMZW5ndGggPiAzMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXA6IGlwVG9JbnQoc3BsaXRSYW5nZVswXSksXG4gICAgICAgIHByZWZpeExlbmd0aDogcHJlZml4TGVuZ3RoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlwVG9JbnQoaXApIHtcbiAgICByZXR1cm4gaXAuc3BsaXQoXCIuXCIpLnJlZHVjZSgoYWNjLCBvY3RldCkgPT4gKGFjYyA8PCA4KSArIHBhcnNlSW50KG9jdGV0LCAxMCksIDApO1xufVxuZnVuY3Rpb24gaXNJcEluQ0lEUihjaWRyLCBzZXJ2ZXJIb3N0KSB7XG4gICAgY29uc3QgaXAgPSBjaWRyLmlwO1xuICAgIGNvbnN0IG1hc2sgPSAtMSA8PCAoMzIgLSBjaWRyLnByZWZpeExlbmd0aCk7XG4gICAgY29uc3QgaG9zdElQID0gaXBUb0ludChzZXJ2ZXJIb3N0KTtcbiAgICByZXR1cm4gKGhvc3RJUCAmIG1hc2spID09PSAoaXAgJiBtYXNrKTtcbn1cbmZ1bmN0aW9uIGhvc3RNYXRjaGVzTm9Qcm94eUxpc3Qoc2VydmVySG9zdCkge1xuICAgIGZvciAoY29uc3QgaG9zdCBvZiBnZXROb1Byb3h5SG9zdExpc3QoKSkge1xuICAgICAgICBjb25zdCBwYXJzZWRDSURSID0gcGFyc2VDSURSKGhvc3QpO1xuICAgICAgICAvLyBob3N0IGlzIGEgQ0lEUiBhbmQgc2VydmVySG9zdCBpcyBhbiBJUCBhZGRyZXNzXG4gICAgICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShzZXJ2ZXJIb3N0KSAmJiBwYXJzZWRDSURSICYmIGlzSXBJbkNJRFIocGFyc2VkQ0lEUiwgc2VydmVySG9zdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlcnZlckhvc3QuZW5kc1dpdGgoaG9zdCkpIHtcbiAgICAgICAgICAgIC8vIGhvc3QgaXMgYSBzaW5nbGUgSVAgb3IgYSBkb21haW4gbmFtZSBzdWZmaXhcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1hcFByb3h5TmFtZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgbm9Qcm94eVJlc3VsdCA9IHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGV4dHJhT3B0aW9uczoge30sXG4gICAgfTtcbiAgICBpZiAoKChfYSA9IG9wdGlvbnNbJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuc2NoZW1lID09PSAndW5peCcpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5SW5mbyA9IGdldFByb3h5SW5mbygpO1xuICAgIGlmICghcHJveHlJbmZvLmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgaWYgKCFob3N0UG9ydCkge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVySG9zdCA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgaWYgKGhvc3RNYXRjaGVzTm9Qcm94eUxpc3Qoc2VydmVySG9zdCkpIHtcbiAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQcm94aWVkQ29ubmVjdGlvbihhZGRyZXNzLCBjaGFubmVsT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgY29uc3QgcmVhbFRhcmdldCA9IGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXTtcbiAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShyZWFsVGFyZ2V0KTtcbiAgICBpZiAocGFyc2VkVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0SG9zdFBvc3QgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhcnNlZFRhcmdldC5wYXRoKTtcbiAgICBpZiAoc3BsaXRIb3N0UG9zdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IGAke3NwbGl0SG9zdFBvc3QuaG9zdH06JHsoX2EgPSBzcGxpdEhvc3RQb3N0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVyX2Ruc18xLkRFRkFVTFRfUE9SVH1gO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBob3N0UG9ydCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IGhvc3RQb3J0LFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgSFRUUCBjbGllbnQgbWF5IGhhdmUgYWxyZWFkeSByZWFkIGEgZmV3IGJ5dGVzIG9mIHRoZSBwcm94aWVkXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbi4gSWYgdGhhdCdzIHRoZSBjYXNlLCBwdXQgdGhlbSBiYWNrIGludG8gdGhlIHNvY2tldC5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8yNzQ0LlxuICAgICAgICAgICAgICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgYSBwbGFpbnRleHQgY29ubmVjdGlvbiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggc3RhdHVzICcgK1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9wcm94eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.experimental = exports.ServerMetricRecorder = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\nconst client_1 = __webpack_require__(/*! ./client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\nconst server_1 = __webpack_require__(/*! ./server */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */\n    combineCallCredentials: (first, ...additional) => {\n        return additional.reduce((acc, other) => acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */\nconst closeClient = (client) => client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n/**** Unimplemented function stubs ****/\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst loadObject = (value, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.load = load;\nconst setLogger = (logger) => {\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity) => {\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client) => {\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\nvar server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\nObject.defineProperty(exports, \"ServerListenerBuilder\", ({ enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } }));\nObject.defineProperty(exports, \"ResponderBuilder\", ({ enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } }));\nObject.defineProperty(exports, \"ServerInterceptingCall\", ({ enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } }));\nvar orca_1 = __webpack_require__(/*! ./orca */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/orca.js\");\nObject.defineProperty(exports, \"ServerMetricRecorder\", ({ enumerable: true, get: function () { return orca_1.ServerMetricRecorder; } }));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst load_balancer_weighted_round_robin = __webpack_require__(/*! ./load-balancer-weighted-round-robin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-weighted-round-robin.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(() => {\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    load_balancer_weighted_round_robin.setup();\n    channelz.setup();\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QixHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLHFDQUFxQyxHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLDZCQUE2QixHQUFHLGNBQWMsR0FBRyw2QkFBNkIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQ3Q3QiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQsbURBQWtELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3hJLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLDJDQUEwQyxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUM3SCxpQ0FBaUMsbUJBQU8sQ0FBQyxtSEFBMEI7QUFDbkUseURBQXdELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQzFKLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxxREFBb0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDOUksOEJBQThCLG1CQUFPLENBQUMsNkdBQXVCO0FBQzdELHNEQUFxRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNqSixpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MseURBQXdELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQy9JLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSxnRUFBK0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDdEosbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxpREFBZ0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDbEk7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDM0QsbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLG9EQUFtRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM3SSxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksaUVBQWdFLEVBQUUscUNBQXFDLCtEQUErRCxFQUFDO0FBQ3ZLLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3JDLGdFQUErRCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUMxSix1REFBc0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDeEksY0FBYyxtQkFBTyxDQUFDLGlGQUFTO0FBQy9CLDREQUEyRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMvSSw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDM0QseURBQXdELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3ZKLG9EQUFtRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM3SSwwREFBeUQsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDekosYUFBYSxtQkFBTyxDQUFDLCtFQUFRO0FBQzdCLHdEQUF1RCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUN0SSxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDN0Msb0JBQW9CO0FBQ3BCLHFCQUFxQixtQkFBTyxDQUFDLCtGQUFnQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsNkZBQWU7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3JFLGtDQUFrQyxtQkFBTyxDQUFDLHlIQUE2QjtBQUN2RSx3Q0FBd0MsbUJBQU8sQ0FBQyxxSUFBbUM7QUFDbkYsMkNBQTJDLG1CQUFPLENBQUMsMklBQXNDO0FBQ3pGLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbmRleC5qcz8zNzIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cG9ydHMuU2VydmVyTWV0cmljUmVjb3JkZXIgPSBleHBvcnRzLlNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlc3BvbmRlckJ1aWxkZXIgPSBleHBvcnRzLlNlcnZlckxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IGV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IGV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IGV4cG9ydHMuU2VydmVyID0gZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMubG9hZE9iamVjdCA9IGV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBleHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IGV4cG9ydHMuY2xvc2VDbGllbnQgPSBleHBvcnRzLkNoYW5uZWwgPSBleHBvcnRzLm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5DbGllbnQgPSBleHBvcnRzLmNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IGV4cG9ydHMucHJvcGFnYXRlID0gZXhwb3J0cy5jb25uZWN0aXZpdHlTdGF0ZSA9IGV4cG9ydHMuc3RhdHVzID0gZXhwb3J0cy5sb2dWZXJib3NpdHkgPSBleHBvcnRzLk1ldGFkYXRhID0gZXhwb3J0cy5jcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbjsgfSB9KTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wcmVzc2lvbkFsZ29yaXRobXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXM7IH0gfSk7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbm5lY3Rpdml0eVN0YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZTsgfSB9KTtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzEuQ2xpZW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dWZXJib3NpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0YXR1c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuU3RhdHVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGFnYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Qcm9wYWdhdGU7IH0gfSk7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRQYWNrYWdlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRhZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWV0YWRhdGFfMS5NZXRhZGF0YTsgfSB9KTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlckNyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IHN0YXR1c19idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0dXMtYnVpbGRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXR1c0J1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXR1c19idWlsZGVyXzEuU3RhdHVzQnVpbGRlcjsgfSB9KTtcbi8qKioqIENsaWVudCBDcmVkZW50aWFscyAqKioqL1xuLy8gVXNpbmcgYXNzaWduIG9ubHkgY29waWVzIGVudW1lcmFibGUgcHJvcGVydGllcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG5leHBvcnRzLmNyZWRlbnRpYWxzID0ge1xuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgd2l0aCBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGFcbiAgICAgKiBzaW5nbGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzIFRoZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjYWxsQ3JlZGVudGlhbHMgQW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzOiAoY2hhbm5lbENyZWRlbnRpYWxzLCAuLi5jYWxsQ3JlZGVudGlhbHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxDcmVkZW50aWFscy5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgY2hhbm5lbENyZWRlbnRpYWxzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhIHNpbmdsZSBDYWxsQ3JlZGVudGlhbHNcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2FsbENyZWRlbnRpYWxzOiAoZmlyc3QsIC4uLmFkZGl0aW9uYWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWwucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGZpcnN0KTtcbiAgICB9LFxuICAgIC8vIGZyb20gY2hhbm5lbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUluc2VjdXJlOiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUluc2VjdXJlLFxuICAgIGNyZWF0ZVNzbDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVTc2wsXG4gICAgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQ6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQsXG4gICAgLy8gZnJvbSBjYWxsLWNyZWRlbnRpYWxzLnRzXG4gICAgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcixcbiAgICBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCxcbiAgICBjcmVhdGVFbXB0eTogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSxcbn07XG4vKipcbiAqIENsb3NlIGEgQ2xpZW50IG9iamVjdC5cbiAqIEBwYXJhbSBjbGllbnQgVGhlIGNsaWVudCB0byBjbG9zZS5cbiAqL1xuY29uc3QgY2xvc2VDbGllbnQgPSAoY2xpZW50KSA9PiBjbGllbnQuY2xvc2UoKTtcbmV4cG9ydHMuY2xvc2VDbGllbnQgPSBjbG9zZUNsaWVudDtcbmNvbnN0IHdhaXRGb3JDbGllbnRSZWFkeSA9IChjbGllbnQsIGRlYWRsaW5lLCBjYWxsYmFjaykgPT4gY2xpZW50LndhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spO1xuZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSB3YWl0Rm9yQ2xpZW50UmVhZHk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGxvYWRPYmplY3QgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZE9iamVjdCA9IGxvYWRPYmplY3Q7XG5jb25zdCBsb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXIobG9nZ2VyKTtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbmNvbnN0IHNldExvZ1ZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcbiAgICBsb2dnaW5nLnNldExvZ2dlclZlcmJvc2l0eSh2ZXJib3NpdHkpO1xufTtcbmV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gc2V0TG9nVmVyYm9zaXR5O1xuY29uc3QgZ2V0Q2xpZW50Q2hhbm5lbCA9IChjbGllbnQpID0+IHtcbiAgICByZXR1cm4gY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5nZXRDaGFubmVsLmNhbGwoY2xpZW50KTtcbn07XG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBnZXRDbGllbnRDaGFubmVsO1xudmFyIGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdGluZ0NhbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRpbmdDYWxsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLmFkZEFkbWluU2VydmljZXNUb1NlcnZlcjsgfSB9KTtcbnZhciBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItaW50ZXJjZXB0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuU2VydmVyTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uZGVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2ludGVyY2VwdG9yc18xLlJlc3BvbmRlckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuU2VydmVySW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcbnZhciBvcmNhXzEgPSByZXF1aXJlKFwiLi9vcmNhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyTWV0cmljUmVjb3JkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yY2FfMS5TZXJ2ZXJNZXRyaWNSZWNvcmRlcjsgfSB9KTtcbmNvbnN0IGV4cGVyaW1lbnRhbCA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgcmVzb2x2ZXJfdWRzID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItdWRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3dlaWdodGVkX3JvdW5kX3JvYmluID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci13ZWlnaHRlZC1yb3VuZC1yb2JpblwiKTtcbmNvbnN0IGNoYW5uZWx6ID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG4oKCkgPT4ge1xuICAgIHJlc29sdmVyX2Rucy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX3Vkcy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX2lwLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0LnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2Jpbi5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24uc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX3dlaWdodGVkX3JvdW5kX3JvYmluLnNldHVwKCk7XG4gICAgY2hhbm5lbHouc2V0dXAoKTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InternalChannel = exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel) {\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n            channel.throttleKeepalive(keepaliveTime);\n        };\n    }\n    ref() {\n        if (this.refCount === 0) {\n            this.child.addConnectivityStateListener(this.subchannelStateListener);\n            this.channel.addWrappedSubchannel(this);\n        }\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass ShutdownPicker {\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.DROP,\n            status: {\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Channel closed before call started',\n                metadata: new metadata_1.Metadata()\n            },\n            subchannel: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = 'grpc.internal.no_subchannel';\nclass ChannelzInfoTracker {\n    constructor(target) {\n        this.target = target;\n        this.trace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.state = connectivity_state_1.ConnectivityState.IDLE;\n    }\n    getChannelzInfoCallback() {\n        return () => {\n            return {\n                target: this.target,\n                state: this.state,\n                trace: this.trace,\n                callTracker: this.callTracker,\n                children: this.childrenTracker.getChildLists()\n            };\n        };\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        /**\n         * This timer does not do anything on its own. Its purpose is to hold the\n         * event loop open while there are any pending calls for the channel that\n         * have not yet been assigned to specific subchannels. In other words,\n         * the invariant is that callRefTimer is reffed if and only if pickQueue\n         * is non-empty. In addition, the timer is null while the state is IDLE or\n         * SHUTDOWN and there are no pending calls.\n         */\n        this.callRefTimer = null;\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */\n        this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        /**\n         * Randomly generated ID to be passed to the config selector, for use by\n         * ring_hash in xDS. An integer distributed approximately uniformly between\n         * 0 and MAX_SAFE_INTEGER.\n         */\n        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.channelzInfoTracker = new ChannelzInfoTracker(target);\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Channel created');\n        }\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a = this.options['grpc.use_local_subchannel_pool']) !== null && _a !== void 0 ? _a : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b = this.options['grpc.retry_buffer_size']) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c = this.options['grpc.per_rpc_retry_buffer_size']) !== null && _c !== void 0 ? _c : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : -1;\n        this.idleTimeoutMs = Math.max((_e = this.options['grpc.client_idle_timeout_ms']) !== null && _e !== void 0 ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const finalSubchannelArgs = {};\n                for (const [key, value] of Object.entries(subchannelArgs)) {\n                    if (!key.startsWith(exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {\n                        finalSubchannelArgs[key] = value;\n                    }\n                }\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, finalSubchannelArgs, this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                if (queueCopy.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of queueCopy) {\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n            addChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.childrenTracker.unrefChild(child);\n                }\n            },\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, this.options, (serviceConfig, configSelector) => {\n            var _a;\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            }\n            else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Address resolution succeeded');\n            }\n            (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                if (localQueue.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of localQueue) {\n                    call.getConfig();\n                }\n            });\n        }, status => {\n            if (this.channelzEnabled) {\n                this.channelzInfoTracker.trace.addTrace('CT_WARNING', 'Address resolution failed with code ' +\n                    status.code +\n                    ' and details \"' +\n                    status.details +\n                    '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace('Name resolution failed with calls queued for config selection');\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            if (localQueue.length > 0) {\n                this.callRefTimerUnref();\n            }\n            for (const call of localQueue) {\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\n        ]);\n        this.trace('Channel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        if ((0, logging_1.isTracerEnabled)('channel_stacktrace')) {\n            (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +\n                this.channelzRef.id +\n                ') ' +\n                'Channel constructed \\n' +\n                ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf('\\n') + 1)));\n        }\n        this.lastActivityTimestamp = new Date();\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        if (!this.callRefTimer) {\n            this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        }\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b, _c;\n        // If the timer or the hasRef function does not exist, always run the code\n        if (!((_a = this.callRefTimer) === null || _a === void 0 ? void 0 : _a.hasRef) || this.callRefTimer.hasRef()) {\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_c = (_b = this.callRefTimer) === null || _b === void 0 ? void 0 : _b.unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +\n            this.channelzRef.id +\n            ') ' +\n            (0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        this.channelzInfoTracker.state = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels) {\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    addWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.add(wrappedSubchannel);\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo,\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        if (this.configSelector) {\n            return {\n                type: 'SUCCESS',\n                config: this.configSelector.invoke(method, metadata, this.randomChannelId),\n            };\n        }\n        else {\n            if (this.currentResolutionError) {\n                return {\n                    type: 'ERROR',\n                    error: this.currentResolutionError,\n                };\n            }\n            else {\n                return {\n                    type: 'NONE',\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n        if (this.callRefTimer) {\n            clearInterval(this.callRefTimer);\n            this.callRefTimer = null;\n        }\n    }\n    startIdleTimeout(timeoutMs) {\n        var _a, _b;\n        this.idleTimer = setTimeout(() => {\n            if (this.callCount > 0) {\n                /* If there is currently a call, the channel will not go idle for a\n                 * period of at least idleTimeoutMs, so check again after that time.\n                 */\n                this.startIdleTimeout(this.idleTimeoutMs);\n                return;\n            }\n            const now = new Date();\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\n                this.trace('Idle timer triggered after ' +\n                    this.idleTimeoutMs +\n                    'ms of inactivity');\n                this.enterIdle();\n            }\n            else {\n                /* Whenever the timer fires with the latest activity being too recent,\n                 * set the timer again for the time when the time since the last\n                 * activity is equal to the timeout. This should result in the timer\n                 * firing no more than once every idleTimeoutMs/2 on average. */\n                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n            }\n        }, timeoutMs);\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    maybeStartIdleTimer() {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&\n            !this.idleTimer) {\n            this.startIdleTimeout(this.idleTimeoutMs);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.channelzInfoTracker.callTracker.addCallSucceeded();\n            }\n            else {\n                this.channelzInfoTracker.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.lastActivityTimestamp = new Date();\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createResolvingCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher(status => {\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        var _a;\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        this.currentPicker = new ShutdownPicker();\n        for (const call of this.configSelectionQueue) {\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\n        }\n        this.configSelectionQueue = [];\n        for (const call of this.pickQueue) {\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\n        }\n        this.pickQueue = [];\n        if (this.callRefTimer) {\n            clearInterval(this.callRefTimer);\n        }\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n        (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n        this.configSelector = null;\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.lastActivityTimestamp = new Date();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer,\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n    getOptions() {\n        return this.options;\n    }\n}\nexports.InternalChannel = InternalChannel;\n//# sourceMappingURL=internal-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbnRlcm5hbC1jaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsMENBQTBDO0FBQ3BFLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQyxxSEFBMkI7QUFDckUsMEJBQTBCLG1CQUFPLENBQUMscUdBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUZBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBa0I7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9ELHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRCwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsOEZBQThGLDJCQUEyQjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbnRlcm5hbC1jaGFubmVsLmpzP2NjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJuYWxDaGFubmVsID0gZXhwb3J0cy5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfcG9vbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1wb29sXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuY29uc3QgY29tcHJlc3Npb25fZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1maWx0ZXJcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jaW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jaW5nLWNhbGxcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCByZXNvbHZpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vcmVzb2x2aW5nLWNhbGxcIik7XG5jb25zdCBjYWxsX251bWJlcl8xID0gcmVxdWlyZShcIi4vY2FsbC1udW1iZXJcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCByZXRyeWluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXRyeWluZy1jYWxsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lcnNfc2V0aW50ZXJ2YWxfY2FsbGJhY2tfZGVsYXlfYXJnc1xuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0NztcbmNvbnN0IE1JTl9JRExFX1RJTUVPVVRfTVMgPSAxMDAwO1xuLy8gMzAgbWludXRlc1xuY29uc3QgREVGQVVMVF9JRExFX1RJTUVPVVRfTVMgPSAzMCAqIDYwICogMTAwMDtcbmNvbnN0IFJFVFJZX1RIUk9UVExFUl9NQVAgPSBuZXcgTWFwKCk7XG5jb25zdCBERUZBVUxUX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyNDsgLy8gMTYgTUJcbmNvbnN0IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyA9IDEgPDwgMjA7IC8vIDEgTUJcbmNsYXNzIENoYW5uZWxTdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZFN1YmNoYW5uZWwsIGNoYW5uZWwpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcbiAgICAgICAgICAgIGNoYW5uZWwudGhyb3R0bGVLZWVwYWxpdmUoa2VlcGFsaXZlVGltZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5hZGRXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnJlbW92ZVdyYXBwZWRTdWJjaGFubmVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2h1dGRvd25QaWNrZXIge1xuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5EUk9QLFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDaGFubmVsIGNsb3NlZCBiZWZvcmUgY2FsbCBzdGFydGVkJyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVggPSAnZ3JwYy5pbnRlcm5hbC5ub19zdWJjaGFubmVsJztcbmNsYXNzIENoYW5uZWx6SW5mb1RyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50cmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvQ2FsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhY2U6IHRoaXMudHJhY2UsXG4gICAgICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBJbnRlcm5hbENoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgcXVldWVkIHVwIHRvIGdldCBhIGNhbGwgY29uZmlnLiBTaG91bGQgb25seSBiZSBwb3B1bGF0ZWQgYmVmb3JlIHRoZVxuICAgICAgICAgKiBmaXJzdCB0aW1lIHRoZSByZXNvbHZlciByZXR1cm5zIGEgcmVzdWx0LCB3aGljaCBpbmNsdWRlcyB0aGUgQ29uZmlnU2VsZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB0aW1lciBkb2VzIG5vdCBkbyBhbnl0aGluZyBvbiBpdHMgb3duLiBJdHMgcHVycG9zZSBpcyB0byBob2xkIHRoZVxuICAgICAgICAgKiBldmVudCBsb29wIG9wZW4gd2hpbGUgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGNhbGxzIGZvciB0aGUgY2hhbm5lbCB0aGF0XG4gICAgICAgICAqIGhhdmUgbm90IHlldCBiZWVuIGFzc2lnbmVkIHRvIHNwZWNpZmljIHN1YmNoYW5uZWxzLiBJbiBvdGhlciB3b3JkcyxcbiAgICAgICAgICogdGhlIGludmFyaWFudCBpcyB0aGF0IGNhbGxSZWZUaW1lciBpcyByZWZmZWQgaWYgYW5kIG9ubHkgaWYgcGlja1F1ZXVlXG4gICAgICAgICAqIGlzIG5vbi1lbXB0eS4gSW4gYWRkaXRpb24sIHRoZSB0aW1lciBpcyBudWxsIHdoaWxlIHRoZSBzdGF0ZSBpcyBJRExFIG9yXG4gICAgICAgICAqIFNIVVRET1dOIGFuZCB0aGVyZSBhcmUgbm8gcGVuZGluZyBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBlcnJvciBmcm9tIHRoZSBuYW1lIHJlc29sdmVyIGlmIGl0IGZhaWxlZCBtb3N0IHJlY2VudGx5LiBJdFxuICAgICAgICAgKiBpcyBvbmx5IHVzZWQgdG8gZW5kIGNhbGxzIHRoYXQgc3RhcnQgd2hpbGUgdGhlcmUgaXMgbm8gY29uZmlnIHNlbGVjdG9yXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXG4gICAgICAgICAqIGNvbmZpZ1NlbGVjdG9yIGJlY29tZXMgc2V0IG9yIHRoZSBjaGFubmVsIHN0YXRlIGJlY29tZXMgYW55dGhpbmcgb3RoZXJcbiAgICAgICAgICogdGhhbiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYW5kb21seSBnZW5lcmF0ZWQgSUQgdG8gYmUgcGFzc2VkIHRvIHRoZSBjb25maWcgc2VsZWN0b3IsIGZvciB1c2UgYnlcbiAgICAgICAgICogcmluZ19oYXNoIGluIHhEUy4gQW4gaW50ZWdlciBkaXN0cmlidXRlZCBhcHByb3hpbWF0ZWx5IHVuaWZvcm1seSBiZXR3ZWVuXG4gICAgICAgICAqIDAgYW5kIE1BWF9TQUZFX0lOVEVHRVIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhbmRvbUNoYW5uZWxJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyID0gbmV3IENoYW5uZWx6SW5mb1RyYWNrZXIodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9ICgwLCByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUpKG9yaWdpbmFsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgdGFyZ2V0IG5hbWUgXCIke3RhcmdldH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKSh0YXJnZXQsIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5nZXRDaGFubmVsekluZm9DYWxsYmFjaygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0NoYW5uZWwgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gdGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBdXRob3JpdHkgPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KShkZWZhdWx0U2NoZW1lTWFwUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm94eU1hcFJlc3VsdCA9ICgwLCBodHRwX3Byb3h5XzEubWFwUHJveHlOYW1lKShkZWZhdWx0U2NoZW1lTWFwUmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBwcm94eU1hcFJlc3VsdC50YXJnZXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcHJveHlNYXBSZXN1bHQuZXh0cmFPcHRpb25zKTtcbiAgICAgICAgLyogVGhlIGdsb2JhbCBib29sZWFuIHBhcmFtZXRlciB0byBnZXRTdWJjaGFubmVsUG9vbCBoYXMgdGhlIGludmVyc2UgbWVhbmluZyB0byB3aGF0XG4gICAgICAgICAqIHRoZSBncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wgY2hhbm5lbCBvcHRpb24gbWVhbnMuICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFBvb2wgPSAoMCwgc3ViY2hhbm5lbF9wb29sXzEuZ2V0U3ViY2hhbm5lbFBvb2wpKCgoX2EgPSB0aGlzLm9wdGlvbnNbJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA9PT0gMCk7XG4gICAgICAgIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyID0gbmV3IHJldHJ5aW5nX2NhbGxfMS5NZXNzYWdlQnVmZmVyVHJhY2tlcigoX2IgPSB0aGlzLm9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9jID0gdGhpcy5vcHRpb25zWydncnBjLnBlcl9ycGNfcmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gKF9kID0gdGhpcy5vcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IC0xO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgPSBNYXRoLm1heCgoX2UgPSB0aGlzLm9wdGlvbnNbJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBERUZBVUxUX0lETEVfVElNRU9VVF9NUywgTUlOX0lETEVfVElNRU9VVF9NUyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU3ViY2hhbm5lbEFyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdWJjaGFubmVsQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aChleHBvcnRzLlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFN1YmNoYW5uZWxBcmdzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsUG9vbC5nZXRPckNyZWF0ZVN1YmNoYW5uZWwodGhpcy50YXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBmaW5hbFN1YmNoYW5uZWxBcmdzLCB0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci50cmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkU3ViY2hhbm5lbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVDb3B5ID0gdGhpcy5waWNrUXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUNvcHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gbmV3IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEuUmVzb2x2aW5nTG9hZEJhbGFuY2VyKHRoaXMudGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgdGhpcy5vcHRpb25zLCAoc2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xuICAgICAgICAgICAgICAgIFJFVFJZX1RIUk9UVExFUl9NQVAuc2V0KHRoaXMuZ2V0VGFyZ2V0KCksIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlUaHJvdHRsZXIoc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcubWF4VG9rZW5zLCBzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy50b2tlblJhdGlvLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5kZWxldGUodGhpcy5nZXRUYXJnZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIudHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5jb25maWdTZWxlY3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdG9yID0gY29uZmlnU2VsZWN0b3I7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLyogV2UgcHJvY2VzcyB0aGUgcXVldWUgYXN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICAgICAqIGxvYWQgYmFsYW5jZXIgdXBkYXRlIGhhcyBjb21wbGV0ZWQuICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBsb2NhbFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIudHJhY2UuYWRkVHJhY2UoJ0NUX1dBUk5JTkcnLCAnQWRkcmVzcyByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNvZGUgJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAgICAgJyBhbmQgZGV0YWlscyBcIicgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05hbWUgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjYWxscyBxdWV1ZWQgZm9yIGNvbmZpZyBzZWxlY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscykpLCB7IG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGlmIChsb2NhbFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGNhbGwucmVwb3J0UmVzb2x2ZXJFcnJvcihzdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkgPSBuZXcgZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5KFtcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGlmICgoMCwgbG9nZ2luZ18xLmlzVHJhY2VyRW5hYmxlZCkoJ2NoYW5uZWxfc3RhY2t0cmFjZScpKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsX3N0YWNrdHJhY2UnLCAnKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgICAgICdDaGFubmVsIGNvbnN0cnVjdGVkIFxcbicgK1xuICAgICAgICAgICAgICAgICgoX2YgPSBlcnJvci5zdGFjaykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnN1YnN0cmluZyhlcnJvci5zdGFjay5pbmRleE9mKCdcXG4nKSArIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0LCB2ZXJib3NpdHlPdmVycmlkZSkge1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKSh2ZXJib3NpdHlPdmVycmlkZSAhPT0gbnVsbCAmJiB2ZXJib3NpdHlPdmVycmlkZSAhPT0gdm9pZCAwID8gdmVyYm9zaXR5T3ZlcnJpZGUgOiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgY2FsbFJlZlRpbWVyUmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghdGhpcy5jYWxsUmVmVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCBNQVhfVElNRU9VVF9USU1FKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghKChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS5oYXNSZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYWxsUmVmVGltZXIpLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgLy8gSWYgdGhlIHRpbWVyIG9yIHRoZSBoYXNSZWYgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QsIGFsd2F5cyBydW4gdGhlIGNvZGVcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXNSZWYpIHx8IHRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZigpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIudW5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9jID0gKF9iID0gdGhpcy5jYWxsUmVmVGltZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPT09IHdhdGNoZXJPYmplY3QpO1xuICAgICAgICBpZiAod2F0Y2hlckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlcnNDb3B5ID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlck9iamVjdCBvZiB3YXRjaGVyc0NvcHkpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gd2F0Y2hlck9iamVjdC5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlck9iamVjdC50aW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2F0Y2hlck9iamVjdC50aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgIHdhdGNoZXJPYmplY3QuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdyYXBwZWRTdWJjaGFubmVsIG9mIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFN1YmNoYW5uZWwudGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV3JhcHBlZFN1YmNoYW5uZWwod3JhcHBlZFN1YmNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMuYWRkKHdyYXBwZWRTdWJjaGFubmVsKTtcbiAgICB9XG4gICAgcmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwod3JhcHBlZFN1YmNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMuZGVsZXRlKHdyYXBwZWRTdWJjaGFubmVsKTtcbiAgICB9XG4gICAgZG9QaWNrKG1ldGFkYXRhLCBleHRyYVBpY2tJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQaWNrZXIucGljayh7XG4gICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICBleHRyYVBpY2tJbmZvOiBleHRyYVBpY2tJbmZvLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVldWVDYWxsRm9yUGljayhjYWxsKSB7XG4gICAgICAgIHRoaXMucGlja1F1ZXVlLnB1c2goY2FsbCk7XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgfVxuICAgIGdldENvbmZpZyhtZXRob2QsIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU1VDQ0VTUycsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ1NlbGVjdG9yLmludm9rZShtZXRob2QsIG1ldGFkYXRhLCB0aGlzLnJhbmRvbUNoYW5uZWxJZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFUlJPUicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOT05FJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlQ2FsbEZvckNvbmZpZyhjYWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUucHVzaChjYWxsKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgZW50ZXJJZGxlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlcik7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWxsUmVmVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYWxsUmVmVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0SWRsZVRpbWVvdXQodGltZW91dE1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgY3VycmVudGx5IGEgY2FsbCwgdGhlIGNoYW5uZWwgd2lsbCBub3QgZ28gaWRsZSBmb3IgYVxuICAgICAgICAgICAgICAgICAqIHBlcmlvZCBvZiBhdCBsZWFzdCBpZGxlVGltZW91dE1zLCBzbyBjaGVjayBhZ2FpbiBhZnRlciB0aGF0IHRpbWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA9IG5vdy52YWx1ZU9mKCkgLSB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdEFjdGl2aXR5ID49IHRoaXMuaWRsZVRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0lkbGUgdGltZXIgdHJpZ2dlcmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgb2YgaW5hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJZGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBXaGVuZXZlciB0aGUgdGltZXIgZmlyZXMgd2l0aCB0aGUgbGF0ZXN0IGFjdGl2aXR5IGJlaW5nIHRvbyByZWNlbnQsXG4gICAgICAgICAgICAgICAgICogc2V0IHRoZSB0aW1lciBhZ2FpbiBmb3IgdGhlIHRpbWUgd2hlbiB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAqIGFjdGl2aXR5IGlzIGVxdWFsIHRvIHRoZSB0aW1lb3V0LiBUaGlzIHNob3VsZCByZXN1bHQgaW4gdGhlIHRpbWVyXG4gICAgICAgICAgICAgICAgICogZmlyaW5nIG5vIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGlkbGVUaW1lb3V0TXMvMiBvbiBhdmVyYWdlLiAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJZGxlVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0TXMgLSB0aW1lU2luY2VMYXN0QWN0aXZpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmlkbGVUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydElkbGVUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOICYmXG4gICAgICAgICAgICAhdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJZGxlVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0TXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2FsbFN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50ICs9IDE7XG4gICAgfVxuICAgIG9uQ2FsbEVuZChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50IC09IDE7XG4gICAgICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XG4gICAgfVxuICAgIGNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKSB7XG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcbiAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICByZXR1cm4gbmV3IGxvYWRfYmFsYW5jaW5nX2NhbGxfMS5Mb2FkQmFsYW5jaW5nQ2FsbCh0aGlzLCBjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSwgY2FsbE51bWJlcik7XG4gICAgfVxuICAgIGNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJldHJ5aW5nQ2FsbCBbJyArIGNhbGxOdW1iZXIgKyAnXSBtZXRob2Q9XCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIHJldHVybiBuZXcgcmV0cnlpbmdfY2FsbF8xLlJldHJ5aW5nQ2FsbCh0aGlzLCBjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSwgY2FsbE51bWJlciwgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIsIFJFVFJZX1RIUk9UVExFUl9NQVAuZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpKTtcbiAgICB9XG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJlc29sdmluZ0NhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykoZGVhZGxpbmUpKTtcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxuICAgICAgICAgICAgZmxhZ3M6IHByb3BhZ2F0ZUZsYWdzICE9PSBudWxsICYmIHByb3BhZ2F0ZUZsYWdzICE9PSB2b2lkIDAgPyBwcm9wYWdhdGVGbGFncyA6IGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUZBVUxUUyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eSxcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgcmVzb2x2aW5nX2NhbGxfMS5SZXNvbHZpbmdDYWxsKHRoaXMsIG1ldGhvZCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jbG9uZSgpLCBjYWxsTnVtYmVyKTtcbiAgICAgICAgdGhpcy5vbkNhbGxTdGFydCgpO1xuICAgICAgICBjYWxsLmFkZFN0YXR1c1dhdGNoZXIoc3RhdHVzID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DYWxsRW5kKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IFNodXRkb3duUGlja2VyKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlKSB7XG4gICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCAnQ2hhbm5lbCBjbG9zZWQgYmVmb3JlIGNhbGwgc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMucGlja1F1ZXVlKSB7XG4gICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCAnQ2hhbm5lbCBjbG9zZWQgYmVmb3JlIGNhbGwgc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgIGlmICh0aGlzLmNhbGxSZWZUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbGxSZWZUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25maWdTZWxlY3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVmKCk7XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICBnZXRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aXZpdHlTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIGlmICh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRJZGxlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIHdhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5uZWwgaGFzIGJlZW4gc2h1dCBkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKGRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVhZGxpbmVEYXRlID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUgOiBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGRlYWRsaW5lID09PSAtSW5maW5pdHkgfHwgZGVhZGxpbmVEYXRlIDw9IG5vdykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgIH0sIGRlYWRsaW5lRGF0ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXRjaGVyT2JqZWN0ID0ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB0aW1lcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnB1c2god2F0Y2hlck9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHlwZW9mIGRlYWRsaW5lID09PSAnbnVtYmVyJyB8fCBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlc29sdmluZ0NhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJuYWxDaGFubmVsID0gSW50ZXJuYWxDaGFubmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwtY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = 'child_load_balancer_helper';\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent) {\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker, errorMessage) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                }\n                else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker, errorMessage);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param endpointList\n     * @param lbConfig\n     * @param attributes\n     */\n    updateAddressList(endpointList, lbConfig, options, resolutionNote) {\n        let childToUpdate;\n        if (this.currentChild === null ||\n            this.latestConfig === null ||\n            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            }\n            else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        }\n        else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            }\n            else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        return childToUpdate.updateAddressList(endpointList, lbConfig, options, resolutionNote);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlci5qcz9mYWMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IFRZUEVfTkFNRSA9ICdjaGlsZF9sb2FkX2JhbGFuY2VyX2hlbHBlcic7XG5jbGFzcyBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5DaGlsZFBvbGljeUhlbHBlciA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q2hpbGQgPSAoX2EgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZCA9PT0gbGF0ZXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENoaWxkKG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5Q3VycmVudENoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbmZpZ1VwZGF0ZVJlcXVpcmVzTmV3UG9saWN5SW5zdGFuY2Uob2xkQ29uZmlnLCBuZXdDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG9sZENvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgIT09IG5ld0NvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXJlcXVpc2l0ZXM6IGxiQ29uZmlnICE9PSBudWxsIGFuZCBsYkNvbmZpZy5uYW1lIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0gZW5kcG9pbnRMaXN0XG4gICAgICogQHBhcmFtIGxiQ29uZmlnXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSkge1xuICAgICAgICBsZXQgY2hpbGRUb1VwZGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5jb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKHRoaXMubGF0ZXN0Q29uZmlnLCBsYkNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlbHBlciA9IG5ldyB0aGlzLkNoaWxkUG9saWN5SGVscGVyKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUxvYWRCYWxhbmNlcikobGJDb25maWcsIG5ld0hlbHBlcik7XG4gICAgICAgICAgICBuZXdIZWxwZXIuc2V0Q2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xuICAgICAgICByZXR1cm4gY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLnJlc2V0QmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8qIE5vdGU6IHN0YXRlIHVwZGF0ZXMgYXJlIG9ubHkgcHJvcGFnYXRlZCBmcm9tIHRoZSBjaGlsZCBiYWxhbmNlciBpZiB0aGF0XG4gICAgICAgICAqIG9iamVjdCBpcyBlcXVhbCB0byB0aGlzLmN1cnJlbnRDaGlsZCBvciB0aGlzLnBlbmRpbmdDaGlsZC4gU2luY2UgdGhpc1xuICAgICAgICAgKiBmdW5jdGlvbiBzZXRzIGJvdGggb2YgdGhvc2UgdG8gbnVsbCwgbm8gZnVydGhlciBzdGF0ZSB1cGRhdGVzIHdpbGxcbiAgICAgICAgICogb2NjdXIgYWZ0ZXIgdGhpcyBmdW5jdGlvbiByZXR1cm5zLiAqL1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IENoaWxkTG9hZEJhbGFuY2VySGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nexports.setup = setup;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100,\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50,\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj &&\n        obj[fieldName] !== undefined &&\n        typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj && obj[fieldName] !== undefined) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 &&\n            obj[fieldName].seconds <= 315576000000 &&\n            obj[fieldName].nanos >= 0 &&\n            obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, 'number', objectName);\n    if (fieldName in obj &&\n        obj[fieldName] !== undefined &&\n        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n        this.childPolicy = childPolicy;\n        if (childPolicy.getLoadBalancerName() === 'pick_first') {\n            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection\n            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection\n            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        var _a, _b;\n        return {\n            outlier_detection: {\n                interval: (0, duration_1.msToDuration)(this.intervalMs),\n                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n                max_ejection_percent: this.maxEjectionPercent,\n                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== void 0 ? _a : undefined,\n                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== void 0 ? _b : undefined,\n                child_policy: [this.childPolicy.toJsonObject()],\n            },\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, 'interval');\n        validatePositiveDuration(obj, 'base_ejection_time');\n        validatePositiveDuration(obj, 'max_ejection_time');\n        validatePercentage(obj, 'max_ejection_percent');\n        if ('success_rate_ejection' in obj &&\n            obj.success_rate_ejection !== undefined) {\n            if (typeof obj.success_rate_ejection !== 'object') {\n                throw new Error('outlier detection config success_rate_ejection must be an object');\n            }\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n        }\n        if ('failure_percentage_ejection' in obj &&\n            obj.failure_percentage_ejection !== undefined) {\n            if (typeof obj.failure_percentage_ejection !== 'object') {\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\n            }\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n        }\n        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {\n            throw new Error('outlier detection config child_policy must be an array');\n        }\n        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);\n        if (!childPolicy) {\n            throw new Error('outlier detection config child_policy: no valid recognized policy found');\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry) {\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.refCount = 0;\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.setHealthy(false);\n    }\n    uneject() {\n        this.setHealthy(true);\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0,\n    };\n}\nclass CallCounter {\n    constructor() {\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls) {\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = (statusCode, details, metadata) => {\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        }\n                        else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode, details, metadata);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });\n            }\n            else {\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper) {\n        this.entryMap = new subchannel_address_1.EndpointMap();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker, errorMessage) => {\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()), errorMessage);\n                }\n                else {\n                    channelControlHelper.updateState(connectivityState, picker, errorMessage);\n                }\n            },\n        }));\n        this.ejectionTimer = setInterval(() => { }, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return (this.latestConfig !== null &&\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null));\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.entryMap.values()) {\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return (ejectionCount * 100) / this.entryMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace('Running success rate check');\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [endpoint, mapEntry] of this.entryMap.entries()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Stats for ' +\n                (0, subchannel_address_1.endpointToString)(endpoint) +\n                ': successes=' +\n                successes +\n                ' failures=' +\n                failures +\n                ' targetRequestVolume=' +\n                targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace('Found ' +\n            addresesWithTargetVolume +\n            ' success rate candidates; currentEjectionPercent=' +\n            this.getCurrentEjectionPercent() +\n            ' successRates=[' +\n            successRates +\n            ']');\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates) {\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean -\n            successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.entryMap.entries()) {\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace('Running failure percentage check. threshold=' +\n            failurePercentageConfig.threshold +\n            ' request volume threshold=' +\n            failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.entryMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.entryMap.entries()) {\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Candidate successes=' + successes + ' failures=' + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = (failures * 100) / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.entryMap.values()) {\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace('Ejection timer running');\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.entryMap.entries()) {\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            }\n            else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() +\n                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace('Unejecting ' + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(endpointList, lbConfig, options, resolutionNote) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return false;\n        }\n        trace('Received update with config: ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));\n        if (endpointList.ok) {\n            for (const endpoint of endpointList.value) {\n                if (!this.entryMap.has(endpoint)) {\n                    trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));\n                    this.entryMap.set(endpoint, {\n                        counter: new CallCounter(),\n                        currentEjectionTimestamp: null,\n                        ejectionTimeMultiplier: 0,\n                        subchannelWrappers: [],\n                    });\n                }\n            }\n            this.entryMap.deleteMissing(endpointList.value);\n        }\n        const childPolicy = lbConfig.getChildPolicy();\n        this.childBalancer.updateAddressList(endpointList, childPolicy, options, resolutionNote);\n        if (lbConfig.getSuccessRateEjectionConfig() ||\n            lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace('Previous timer existed. Replacing timer');\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() -\n                    (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            }\n            else {\n                trace('Starting new timer');\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        }\n        else {\n            trace('Counting disabled. Cancelling timer.');\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.entryMap.values()) {\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n        return true;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRywyQ0FBMkM7QUFDbEYsYUFBYTtBQUNiLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELHNDQUFzQyxtQkFBTyxDQUFDLDZIQUErQjtBQUM3RSxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsR0FBRyxVQUFVO0FBQ3RFLG9EQUFvRCxlQUFlLHdCQUF3QixhQUFhLFFBQVEsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsVUFBVTtBQUNsRTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsc0NBQXNDLHNCQUFzQjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxHQUFHLFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLGdGQUFnRjtBQUN2SjtBQUNBO0FBQ0EscURBQXFELGtCQUFrQixzREFBc0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Qsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzP2UyNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xuY29uc3QgZXhwZXJpbWVudGFsXzEgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5jb25zdCBPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEID0gKChfYSA9IHByb2Nlc3MuZW52LkdSUENfRVhQRVJJTUVOVEFMX0VOQUJMRV9PVVRMSUVSX0RFVEVDVElPTikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RydWUnKSA9PT0gJ3RydWUnO1xuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XG4gICAgc3RkZXZfZmFjdG9yOiAxOTAwLFxuICAgIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U6IDEwMCxcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxuICAgIHJlcXVlc3Rfdm9sdW1lOiAxMDAsXG59O1xuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XG4gICAgdGhyZXNob2xkOiA4NSxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogNTAsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmXG4gICAgICAgIG9ialtmaWVsZE5hbWVdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9ialtmaWVsZE5hbWVdICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiYgb2JqW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoISgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb24pKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJlxuICAgICAgICBvYmpbZmllbGROYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICEob2JqW2ZpZWxkTmFtZV0gPj0gMCAmJiBvYmpbZmllbGROYW1lXSA8PSAxMDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZSBmb3IgcGVyY2VudGFnZSAoMC0xMDApYCk7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGludGVydmFsTXMsIGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uUGVyY2VudCwgc3VjY2Vzc1JhdGVFamVjdGlvbiwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgdGhpcy5jaGlsZFBvbGljeSA9IGNoaWxkUG9saWN5O1xuICAgICAgICBpZiAoY2hpbGRQb2xpY3kuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpID09PSAncGlja19maXJzdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllcl9kZXRlY3Rpb24gTEIgcG9saWN5IGNhbm5vdCBoYXZlIGEgcGlja19maXJzdCBjaGlsZCBwb2xpY3knKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsTXMgPSBpbnRlcnZhbE1zICE9PSBudWxsICYmIGludGVydmFsTXMgIT09IHZvaWQgMCA/IGludGVydmFsTXMgOiAxMDAwMDtcbiAgICAgICAgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMgPSBiYXNlRWplY3Rpb25UaW1lTXMgIT09IG51bGwgJiYgYmFzZUVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBiYXNlRWplY3Rpb25UaW1lTXMgOiAzMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQgPSBtYXhFamVjdGlvblBlcmNlbnQgIT09IG51bGwgJiYgbWF4RWplY3Rpb25QZXJjZW50ICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblBlcmNlbnQgOiAxMDtcbiAgICAgICAgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uID0gc3VjY2Vzc1JhdGVFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xuICAgICAgICB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24gPSBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcpLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSA6IG51bGw7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG91dGxpZXJfZGV0ZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5pbnRlcnZhbE1zKSxcbiAgICAgICAgICAgICAgICBiYXNlX2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5iYXNlRWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgICAgIG1heF9lamVjdGlvbl9wZXJjZW50OiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzX3JhdGVfZWplY3Rpb246IChfYSA9IHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbjogKF9iID0gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY2hpbGRfcG9saWN5OiBbdGhpcy5jaGlsZFBvbGljeS50b0pzb25PYmplY3QoKV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRJbnRlcnZhbE1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbE1zO1xuICAgIH1cbiAgICBnZXRCYXNlRWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFamVjdGlvblRpbWVNcztcbiAgICB9XG4gICAgZ2V0TWF4RWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudDtcbiAgICB9XG4gICAgZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0Q2hpbGRQb2xpY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkUG9saWN5O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ2ludGVydmFsJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ21heF9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmosICdtYXhfZWplY3Rpb25fcGVyY2VudCcpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqICYmXG4gICAgICAgICAgICBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBzdWNjZXNzX3JhdGVfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdzdGRldl9mYWN0b3InLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicgaW4gb2JqICYmXG4gICAgICAgICAgICBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnY2hpbGRfcG9saWN5JyBpbiBvYmopIHx8ICFBcnJheS5pc0FycmF5KG9iai5jaGlsZF9wb2xpY3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBjaGlsZF9wb2xpY3kgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkUG9saWN5ID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5zZWxlY3RMYkNvbmZpZ0Zyb21MaXN0KShvYmouY2hpbGRfcG9saWN5KTtcbiAgICAgICAgaWYgKCFjaGlsZFBvbGljeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgY2hpbGRfcG9saWN5OiBubyB2YWxpZCByZWNvZ25pemVkIHBvbGljeSBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG59XG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBtYXBFbnRyeSkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLm1hcEVudHJ5ID0gbWFwRW50cnk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KGZhbHNlKTtcbiAgICB9XG4gICAgdW5lamVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KHRydWUpO1xuICAgIH1cbiAgICBnZXRNYXBFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRW50cnk7XG4gICAgfVxuICAgIGdldFdyYXBwZWRTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUJ1Y2tldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiAwLFxuICAgICAgICBmYWlsdXJlOiAwLFxuICAgIH07XG59XG5jbGFzcyBDYWxsQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGFkZFN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LnN1Y2Nlc3MgKz0gMTtcbiAgICB9XG4gICAgYWRkRmFpbHVyZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuZmFpbHVyZSArPSAxO1xuICAgIH1cbiAgICBzd2l0Y2hCdWNrZXRzKCkge1xuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gdGhpcy5hY3RpdmVCdWNrZXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICB9XG4gICAgZ2V0TGFzdFN1Y2Nlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuc3VjY2VzcztcbiAgICB9XG4gICAgZ2V0TGFzdEZhaWx1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5mYWlsdXJlO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWRQaWNrZXIsIGNvdW50Q2FsbHMpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkUGlja2VyID0gd3JhcHBlZFBpY2tlcjtcbiAgICAgICAgdGhpcy5jb3VudENhbGxzID0gY291bnRDYWxscztcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCB3cmFwcGVkUGljayA9IHRoaXMud3JhcHBlZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcbiAgICAgICAgaWYgKHdyYXBwZWRQaWNrLnBpY2tSZXN1bHRUeXBlID09PSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSB3cmFwcGVkUGljay5zdWJjaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdWJjaGFubmVsV3JhcHBlci5nZXRNYXBFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uQ2FsbEVuZGVkID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBvbkNhbGxFbmRlZCA9IChzdGF0dXNDb2RlLCBkZXRhaWxzLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5hZGRGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB3cmFwcGVkUGljay5vbkNhbGxFbmRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod3JhcHBlZFBpY2ssIHN0YXR1c0NvZGUsIGRldGFpbHMsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCksIG9uQ2FsbEVuZGVkOiBvbkNhbGxFbmRlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5lbnRyeU1hcCA9IG5ldyBzdWJjaGFubmVsX2FkZHJlc3NfMS5FbmRwb2ludE1hcCgpO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKCgwLCBleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3ViY2hhbm5lbCA9IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuZW50cnlNYXAuZ2V0Rm9yU3ViY2hhbm5lbEFkZHJlc3Moc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gbmV3IE91dGxpZXJEZXRlY3Rpb25TdWJjaGFubmVsV3JhcHBlcihvcmlnaW5hbFN1YmNoYW5uZWwsIG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoKG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXApICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhZGRyZXNzIGlzIGVqZWN0ZWQsIHByb3BhZ2F0ZSB0aGF0IHRvIHRoZSBuZXcgc3ViY2hhbm5lbCB3cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMucHVzaChzdWJjaGFubmVsV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxXcmFwcGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgbmV3IE91dGxpZXJEZXRlY3Rpb25QaWNrZXIocGlja2VyLCB0aGlzLmlzQ291bnRpbmdFbmFibGVkKCkpLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICB9XG4gICAgaXNDb3VudGluZ0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sYXRlc3RDb25maWcgIT09IG51bGwgJiZcbiAgICAgICAgICAgICh0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwpKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgbGV0IGVqZWN0aW9uQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuZW50cnlNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlamVjdGlvbkNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlamVjdGlvbkNvdW50ICogMTAwKSAvIHRoaXMuZW50cnlNYXAuc2l6ZTtcbiAgICB9XG4gICAgcnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludCwgbWFwRW50cnldIG9mIHRoaXMuZW50cnlNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdTdGF0cyBmb3IgJyArXG4gICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50VG9TdHJpbmcpKGVuZHBvaW50KSArXG4gICAgICAgICAgICAgICAgJzogc3VjY2Vzc2VzPScgK1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArXG4gICAgICAgICAgICAgICAgJyBmYWlsdXJlcz0nICtcbiAgICAgICAgICAgICAgICBmYWlsdXJlcyArXG4gICAgICAgICAgICAgICAgJyB0YXJnZXRSZXF1ZXN0Vm9sdW1lPScgK1xuICAgICAgICAgICAgICAgIHRhcmdldFJlcXVlc3RWb2x1bWUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnRm91bmQgJyArXG4gICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgK1xuICAgICAgICAgICAgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICtcbiAgICAgICAgICAgICcgc3VjY2Vzc1JhdGVzPVsnICtcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcyArXG4gICAgICAgICAgICAnXScpO1xuICAgICAgICBpZiAoYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgc3VjY2Vzc1JhdGVDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJhdGUgb2Ygc3VjY2Vzc1JhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGhyZXNob2xkID0gc3VjY2Vzc1JhdGVNZWFuIC1cbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmVudHJ5TWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gU3RlcCAzLmlcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSA+PVxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uUGVyY2VudCgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpaVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGUgPSBzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgdHJhY2UoJ0NoZWNraW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyArICcgc3VjY2Vzc1JhdGU9JyArIHN1Y2Nlc3NSYXRlKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzUmF0ZSA8IGVqZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzICtcbiAgICAgICAgICAgICAgICAgICAgJyByYW5kb21OdW1iZXI9JyArXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbU51bWJlciArXG4gICAgICAgICAgICAgICAgICAgICcgZW5mb3JjZW1lbnRfcGVyY2VudGFnZT0nICtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmRvbU51bWJlciA8IHN1Y2Nlc3NSYXRlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0VqZWN0aW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWplY3QobWFwRW50cnksIGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBmYWlsdXJlIHBlcmNlbnRhZ2UgY2hlY2suIHRocmVzaG9sZD0nICtcbiAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCArXG4gICAgICAgICAgICAnIHJlcXVlc3Qgdm9sdW1lIHRocmVzaG9sZD0nICtcbiAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGxldCBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmVudHJ5TWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuZW50cnlNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDIuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paWlcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KG1hcEVudHJ5KSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci51bmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQWxsQnVja2V0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmVudHJ5TWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLnN3aXRjaEJ1Y2tldHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFRpbWVyKGRlbGF5TXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bkNoZWNrcygpLCBkZWxheU1zKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5lamVjdGlvblRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICBydW5DaGVja3MoKSB7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdHJhY2UoJ0VqZWN0aW9uIHRpbWVyIHJ1bm5pbmcnKTtcbiAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gZWplY3Rpb25UaW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lcih0aGlzLmxhdGVzdENvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xuICAgICAgICB0aGlzLnJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICB0aGlzLnJ1bkZhaWx1cmVQZXJjZW50YWdlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5lbnRyeU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEJhc2VFamVjdGlvblRpbWVNcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5UaW1lID0gbmV3IERhdGUobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVGltZS5zZXRNaWxsaXNlY29uZHMocmV0dXJuVGltZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJhc2VFamVjdGlvblRpbWVNcyAqIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIsIE1hdGgubWF4KGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRpbWUgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdVbmVqZWN0aW5nICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmVqZWN0KG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsYkNvbmZpZywgb3B0aW9ucywgcmVzb2x1dGlvbk5vdGUpIHtcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgdXBkYXRlIHdpdGggY29uZmlnOiAnICsgSlNPTi5zdHJpbmdpZnkobGJDb25maWcudG9Kc29uT2JqZWN0KCksIHVuZGVmaW5lZCwgMikpO1xuICAgICAgICBpZiAoZW5kcG9pbnRMaXN0Lm9rKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50TGlzdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbnRyeU1hcC5oYXMoZW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdBZGRpbmcgbWFwIGVudHJ5IGZvciAnICsgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50VG9TdHJpbmcpKGVuZHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50cnlNYXAuc2V0KGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiBuZXcgQ2FsbENvdW50ZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVqZWN0aW9uVGltZU11bHRpcGxpZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudHJ5TWFwLmRlbGV0ZU1pc3NpbmcoZW5kcG9pbnRMaXN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZFBvbGljeSA9IGxiQ29uZmlnLmdldENoaWxkUG9saWN5KCk7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci51cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGNoaWxkUG9saWN5LCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSk7XG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgfHxcbiAgICAgICAgICAgIGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUHJldmlvdXMgdGltZXIgZXhpc3RlZC4gUmVwbGFjaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLVxuICAgICAgICAgICAgICAgICAgICAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVyU3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIobGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuZW50cnlNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbGJDb25maWc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGlmIChPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEKSB7XG4gICAgICAgICgwLCBleHBlcmltZW50YWxfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nexports.shuffled = shuffled;\nexports.setup = setup;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_2 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList) {\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList,\n            },\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if ('shuffleAddressList' in obj &&\n            !(typeof obj.shuffleAddressList === 'boolean')) {\n            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n    const result = list.slice();\n    for (let i = result.length - 1; i > 1; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(addressList) {\n    if (addressList.length === 0) {\n        return [];\n    }\n    const result = [];\n    const ipv6Addresses = [];\n    const ipv4Addresses = [];\n    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\n    for (const address of addressList) {\n        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\n            ipv6Addresses.push(address);\n        }\n        else {\n            ipv4Addresses.push(address);\n        }\n    }\n    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n        if (i < firstList.length) {\n            result.push(firstList[i]);\n        }\n        if (i < secondList.length) {\n            result.push(secondList[i]);\n        }\n    }\n    return result;\n}\nconst REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */\n        this.stickyTransientFailureMode = false;\n        this.reportHealthStatus = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */\n        this.lastError = null;\n        this.latestAddressList = null;\n        this.latestOptions = {};\n        this.latestResolutionNote = '';\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every(child => child.hasReportedTransientFailure);\n    }\n    resetChildrenReportedTF() {\n        this.children.every(child => child.hasReportedTransientFailure = false);\n    }\n    calculateAndReportNewState() {\n        var _a;\n        if (this.currentPick) {\n            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n                const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: errorMessage,\n                }), errorMessage);\n            }\n            else {\n                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick), null);\n            }\n        }\n        else if (((_a = this.latestAddressList) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n            const errorMessage = `No connection established. Last error: ${this.lastError}. Resolution note: ${this.latestResolutionNote}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: errorMessage,\n            }), errorMessage);\n        }\n        else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        }\n        else {\n            if (this.stickyTransientFailureMode) {\n                const errorMessage = `No connection established. Last error: ${this.lastError}. Resolution note: ${this.latestResolutionNote}`;\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: errorMessage,\n                }), errorMessage);\n            }\n            else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n            }\n        }\n    }\n    requestReresolution() {\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        this.requestReresolution();\n        this.resetChildrenReportedTF();\n        if (this.stickyTransientFailureMode) {\n            this.calculateAndReportNewState();\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children) {\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\n            // Unref last, to avoid triggering listeners\n            this.currentPick.unref();\n            this.currentPick = null;\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()) {\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        for (const [index, child] of this.children.entries()) {\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===\n            connectivity_state_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(() => {\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(() => {\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS);\n        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Declare that the specified subchannel should be used to make requests.\n     * This functions the same independent of whether subchannel is a member of\n     * this.children and whether it is equal to this.currentPick.\n     * Prerequisite: subchannel.getConnectivityState() === READY.\n     * @param subchannel\n     */\n    pickSubchannel(subchannel) {\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n         * refcount dropping to 0 during this process. */\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.removeCurrentPick();\n        this.resetSubchannelList();\n        subchannel.addConnectivityStateListener(this.subchannelStateListener);\n        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n        this.currentPick = subchannel;\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker, errorMessage) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\n    }\n    resetSubchannelList() {\n        for (const child of this.children) {\n            /* Always remoev the connectivity state listener. If the subchannel is\n               getting picked, it will be re-added then. */\n            child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */\n            child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n    }\n    connectToAddressList(addressList, options) {\n        trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n        const newChildrenList = addressList.map(address => ({\n            subchannel: this.channelControlHelper.createSubchannel(address, options),\n            hasReportedTransientFailure: false,\n        }));\n        for (const { subchannel } of newChildrenList) {\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */\n        for (const { subchannel } of newChildrenList) {\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n        }\n        for (const child of this.children) {\n            if (child.subchannel.getConnectivityState() ===\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(maybeEndpointList, lbConfig, options, resolutionNote) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return false;\n        }\n        if (!maybeEndpointList.ok) {\n            if (this.children.length === 0 && this.currentPick === null) {\n                this.channelControlHelper.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(maybeEndpointList.error), maybeEndpointList.error.details);\n            }\n            return true;\n        }\n        let endpointList = maybeEndpointList.value;\n        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */\n        if (lbConfig.getShuffleAddressList()) {\n            endpointList = shuffled(endpointList);\n        }\n        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n        trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n        const addressList = interleaveAddressFamilies(rawAddressList);\n        this.latestAddressList = addressList;\n        this.latestOptions = options;\n        this.connectToAddressList(addressList, options);\n        this.latestResolutionNote = resolutionNote;\n        if (rawAddressList.length > 0) {\n            return true;\n        }\n        else {\n            this.lastError = 'No addresses resolved';\n            return false;\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&\n            this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList, this.latestOptions);\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nclass LeafLoadBalancer {\n    constructor(endpoint, channelControlHelper, options, resolutionNote) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this.resolutionNote = resolutionNote;\n        this.latestState = connectivity_state_1.ConnectivityState.IDLE;\n        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n            updateState: (connectivityState, picker, errorMessage) => {\n                this.latestState = connectivityState;\n                this.latestPicker = picker;\n                channelControlHelper.updateState(connectivityState, picker, errorMessage);\n            },\n        });\n        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper);\n        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\n    }\n    startConnecting() {\n        this.pickFirstBalancer.updateAddressList((0, call_interface_1.statusOrFromValue)([this.endpoint]), LEAF_CONFIG, Object.assign(Object.assign({}, this.options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }), this.resolutionNote);\n    }\n    /**\n     * Update the endpoint associated with this LeafLoadBalancer to a new\n     * endpoint. Does not trigger connection establishment if a connection\n     * attempt is not already in progress.\n     * @param newEndpoint\n     */\n    updateEndpoint(newEndpoint, newOptions) {\n        this.options = newOptions;\n        this.endpoint = newEndpoint;\n        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\n            this.startConnecting();\n        }\n    }\n    getConnectivityState() {\n        return this.latestState;\n    }\n    getPicker() {\n        return this.latestPicker;\n    }\n    getEndpoint() {\n        return this.endpoint;\n    }\n    exitIdle() {\n        this.pickFirstBalancer.exitIdle();\n    }\n    destroy() {\n        this.pickFirstBalancer.destroy();\n    }\n}\nexports.LeafLoadBalancer = LeafLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyxvQ0FBb0M7QUFDL0YsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYix3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxlQUFlLHFCQUFxQiwwQkFBMEI7QUFDekk7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZSxxQkFBcUIsMEJBQTBCO0FBQzdJO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNKQUFzSixtQkFBbUIsMENBQTBDO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcz9iMWJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxlYWZMb2FkQmFsYW5jZXIgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IGV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZvaWQgMDtcbmV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzIgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdwaWNrX2ZpcnN0JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgVFlQRV9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuLyoqXG4gKiBEZWxheSBhZnRlciBzdGFydGluZyBhIGNvbm5lY3Rpb24gb24gYSBzdWJjaGFubmVsIGJlZm9yZSBzdGFydGluZyBhXG4gKiBjb25uZWN0aW9uIG9uIHRoZSBuZXh0IHN1YmNoYW5uZWwgaW4gdGhlIGxpc3QsIGZvciBIYXBweSBFeWViYWxscyBhbGdvcml0aG0uXG4gKi9cbmNvbnN0IENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMgPSAyNTA7XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihzaHVmZmxlQWRkcmVzc0xpc3QpIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3QgPSBzaHVmZmxlQWRkcmVzc0xpc3Q7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7XG4gICAgICAgICAgICAgICAgc2h1ZmZsZUFkZHJlc3NMaXN0OiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNodWZmbGVBZGRyZXNzTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgaWYgKCdzaHVmZmxlQWRkcmVzc0xpc3QnIGluIG9iaiAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwaWNrX2ZpcnN0IGNvbmZpZyBmaWVsZCBzaHVmZmxlQWRkcmVzc0xpc3QgbXVzdCBiZSBhIGJvb2xlYW4gaWYgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcob2JqLnNodWZmbGVBZGRyZXNzTGlzdCA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZztcbi8qKlxuICogUGlja2VyIGZvciBhIGBQaWNrRmlyc3RMb2FkQmFsYW5jZXJgIGluIHRoZSBSRUFEWSBzdGF0ZS4gQWx3YXlzIHJldHVybnMgdGhlXG4gKiBwaWNrZWQgc3ViY2hhbm5lbC5cbiAqL1xuY2xhc3MgUGlja0ZpcnN0UGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuc3ViY2hhbm5lbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5wdXQgYXJyYXkgaW4gYSByYW5kb20gb3JkZXJcbiAqIEBwYXJhbSBsaXN0IFRoZSBpbnB1dCBhcnJheVxuICogQHJldHVybnMgQSBzaHVmZmxlZCBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgbGlzdFxuICovXG5mdW5jdGlvbiBzaHVmZmxlZChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbGlzdC5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+IDE7IGktLSkge1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIGNvbnN0IHRlbXAgPSByZXN1bHRbaV07XG4gICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcbiAgICAgICAgcmVzdWx0W2pdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW50ZXJsZWF2ZSBhZGRyZXNzZXMgaW4gYWRkcmVzc0xpc3QgYnkgZmFtaWx5IGluIGFjY29yZGFuY2Ugd2l0aCBSRkMtODMwNCBzZWN0aW9uIDRcbiAqIEBwYXJhbSBhZGRyZXNzTGlzdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaW50ZXJsZWF2ZUFkZHJlc3NGYW1pbGllcyhhZGRyZXNzTGlzdCkge1xuICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBpcHY2QWRkcmVzc2VzID0gW107XG4gICAgY29uc3QgaXB2NEFkZHJlc3NlcyA9IFtdO1xuICAgIGNvbnN0IGlwdjZGaXJzdCA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMi5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzTGlzdFswXSkgJiYgKDAsIG5ldF8xLmlzSVB2NikoYWRkcmVzc0xpc3RbMF0uaG9zdCk7XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NMaXN0KSB7XG4gICAgICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzIuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzcykgJiYgKDAsIG5ldF8xLmlzSVB2NikoYWRkcmVzcy5ob3N0KSkge1xuICAgICAgICAgICAgaXB2NkFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXB2NEFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TGlzdCA9IGlwdjZGaXJzdCA/IGlwdjZBZGRyZXNzZXMgOiBpcHY0QWRkcmVzc2VzO1xuICAgIGNvbnN0IHNlY29uZExpc3QgPSBpcHY2Rmlyc3QgPyBpcHY0QWRkcmVzc2VzIDogaXB2NkFkZHJlc3NlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KGZpcnN0TGlzdC5sZW5ndGgsIHNlY29uZExpc3QubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgZmlyc3RMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZmlyc3RMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHNlY29uZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzZWNvbmRMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgUkVQT1JUX0hFQUxUSF9TVEFUVVNfT1BUSU9OX05BTUUgPSAnZ3JwYy1ub2RlLmludGVybmFsLnBpY2stZmlyc3QucmVwb3J0X2hlYWx0aF9zdGF0dXMnO1xuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHtcbiAgICAvKipcbiAgICAgKiBMb2FkIGJhbGFuY2VyIHRoYXQgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBlYWNoIGJhY2tlbmQgaW4gdGhlIGFkZHJlc3MgbGlzdFxuICAgICAqIGluIG9yZGVyLCBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGNvbm5lY3RzLCB1c2luZyBpdCBmb3IgZXZlcnlcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHN1YmNoYW5uZWxzIHRoaXMgbG9hZCBiYWxhbmNlciBpcyBjdXJyZW50bHkgYXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBjb25uZWN0IHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlIG9mIHRoZSBsb2FkIGJhbGFuY2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IHdpdGhpbiB0aGUgYHN1YmNoYW5uZWxzYCBhcnJheSBvZiB0aGUgc3ViY2hhbm5lbCB3aXRoIHRoZSBtb3N0XG4gICAgICAgICAqIHJlY2VudGx5IHN0YXJ0ZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgcGlja2VkIHN1YmNoYW5uZWwgdXNlZCBmb3IgbWFraW5nIGNhbGxzLiBQb3B1bGF0ZWQgaWZcbiAgICAgICAgICogYW5kIG9ubHkgaWYgdGhlIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IHN0YXRlIGlzIFJFQURZLiBJbiB0aGF0IGNhc2UsXG4gICAgICAgICAqIHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBzdGF0ZSBpcyBhbHNvIFJFQURZLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBjYWxsYmFjayBhdHRhY2hlZCB0byBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIGBzdWJjaGFubmVsc2AgbGlzdFxuICAgICAgICAgKiB3aGlsZSBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uU3ViY2hhbm5lbFN0YXRlVXBkYXRlKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBpY2tlZFN1YmNoYW5uZWxIZWFsdGhMaXN0ZW5lciA9ICgpID0+IHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBMQiBwb2xpY3kgZW50ZXJzIHN0aWNreSBUUkFOU0lFTlRfRkFJTFVSRSBtb2RlIHdoZW4gYWxsXG4gICAgICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgZmFpbGVkIHRvIGNvbm5lY3QgYXQgbGVhc3Qgb25jZSwgYW5kIGl0IHN0YXlzIGluIHRoYXRcbiAgICAgICAgICogbW9kZSB1bnRpbCBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBpcyBzdWNjZXNzZnVsLiBXaGlsZSBpbiBzdGlja3kgVEYgbW9kZSxcbiAgICAgICAgICogdGhlIExCIHBvbGljeSBjb250aW51b3VzbHkgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBhbGwgb2YgaXRzIHN1YmNoYW5uZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcG9ydEhlYWx0aFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGVycm9yIHJlcG9ydGVkIGJ5IGFueSBzdWJjaGFubmVsIGFzIGl0IHRyYW5zaXRpb25lZCB0b1xuICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0T3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmxhdGVzdFJlc29sdXRpb25Ob3RlID0gJyc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgfVxuICAgIGFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSk7XG4gICAgfVxuICAgIHJlc2V0Q2hpbGRyZW5SZXBvcnRlZFRGKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IGZhbHNlKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcG9ydEhlYWx0aFN0YXR1cyAmJiAhdGhpcy5jdXJyZW50UGljay5pc0hlYWx0aHkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBQaWNrZWQgc3ViY2hhbm5lbCAke3RoaXMuY3VycmVudFBpY2suZ2V0QWRkcmVzcygpfSBpcyB1bmhlYWx0aHlgO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBQaWNrRmlyc3RQaWNrZXIodGhpcy5jdXJyZW50UGljayksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2EgPSB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9LiBSZXNvbHV0aW9uIG5vdGU6ICR7dGhpcy5sYXRlc3RSZXNvbHV0aW9uTm90ZX1gO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn0uIFJlc29sdXRpb24gbm90ZTogJHt0aGlzLmxhdGVzdFJlc29sdXRpb25Ob3RlfWA7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgIH1cbiAgICBtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxDaGlsZHJlbkhhdmVSZXBvcnRlZFRGKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgdGhpcy5yZXNldENoaWxkcmVuUmVwb3J0ZWRURigpO1xuICAgICAgICBpZiAodGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50UGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZCh0aGlzLmN1cnJlbnRQaWNrLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay5yZW1vdmVIZWFsdGhTdGF0ZVdhdGNoZXIodGhpcy5waWNrZWRTdWJjaGFubmVsSGVhbHRoTGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gVW5yZWYgbGFzdCwgdG8gYXZvaWQgdHJpZ2dlcmluZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sudW5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU3ViY2hhbm5lbFN0YXRlVXBkYXRlKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5jdXJyZW50UGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWxTdWJjaGFubmVsRXF1YWxzKHN1YmNoYW5uZWwpKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyhjaGlsZC5zdWJjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChjaGlsZC5zdWJjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0YXRlID0gY2hpbGQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXZlIGEgc2luZ2xlIHN1YmNoYW5uZWwgaW4gdGhlIGBzdWJjaGFubmVsc2AgbGlzdCBzdGFydCBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsSW5kZXggVGhlIGluZGV4IGludG8gdGhlIGBzdWJjaGFubmVsc2AgbGlzdC5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSBzdWJjaGFubmVsSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0uc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PVxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0IGNvbm5lY3RpbmcgdG8gc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCArIDEpO1xuICAgICAgICB9LCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIHRoYXQgdGhlIHNwZWNpZmllZCBzdWJjaGFubmVsIHNob3VsZCBiZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuXG4gICAgICogVGhpcyBmdW5jdGlvbnMgdGhlIHNhbWUgaW5kZXBlbmRlbnQgb2Ygd2hldGhlciBzdWJjaGFubmVsIGlzIGEgbWVtYmVyIG9mXG4gICAgICogdGhpcy5jaGlsZHJlbiBhbmQgd2hldGhlciBpdCBpcyBlcXVhbCB0byB0aGlzLmN1cnJlbnRQaWNrLlxuICAgICAqIFByZXJlcXVpc2l0ZTogc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBSRUFEWS5cbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbFxuICAgICAqL1xuICAgIHBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpIHtcbiAgICAgICAgdHJhY2UoJ1BpY2sgc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArIHN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IGZhbHNlO1xuICAgICAgICAvKiBSZWYgYmVmb3JlIHJlbW92ZUN1cnJlbnRQaWNrIGFuZCByZXNldFN1YmNoYW5uZWxMaXN0IHRvIGF2b2lkIHRoZVxuICAgICAgICAgKiByZWZjb3VudCBkcm9wcGluZyB0byAwIGR1cmluZyB0aGlzIHByb2Nlc3MuICovXG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgIHN1YmNoYW5uZWwuYWRkSGVhbHRoU3RhdGVXYXRjaGVyKHRoaXMucGlja2VkU3ViY2hhbm5lbEhlYWx0aExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IHN1YmNoYW5uZWw7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAvKiBBbHdheXMgcmVtb2V2IHRoZSBjb25uZWN0aXZpdHkgc3RhdGUgbGlzdGVuZXIuIElmIHRoZSBzdWJjaGFubmVsIGlzXG4gICAgICAgICAgICAgICBnZXR0aW5nIHBpY2tlZCwgaXQgd2lsbCBiZSByZS1hZGRlZCB0aGVuLiAqL1xuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgLyogUmVmcyBhcmUgY291bnRlZCBpbmRlcGVuZGVudGx5IGZvciB0aGUgY2hpbGRyZW4gbGlzdCBhbmQgdGhlXG4gICAgICAgICAgICAgKiBjdXJyZW50UGljaywgc28gd2UgY2FsbCB1bnJlZiB3aGV0aGVyIG9yIG5vdCB0aGUgY2hpbGQgaXMgdGhlXG4gICAgICAgICAgICAgKiBjdXJyZW50UGljay4gQ2hhbm5lbHogY2hpbGQgcmVmZXJlbmNlcyBhcmUgYWxzbyByZWZjb3VudGVkLCBzb1xuICAgICAgICAgICAgICogcmVtb3ZlQ2hhbm5lbHpDaGlsZCBjYW4gYmUgaGFuZGxlZCB0aGUgc2FtZSB3YXkuICovXG4gICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHRyYWNlKCdjb25uZWN0VG9BZGRyZXNzTGlzdChbJyArIGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkgKyAnXSknKTtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW5MaXN0ID0gYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gKHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChhZGRyZXNzLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZTogZmFsc2UsXG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiBuZXdDaGlsZHJlbkxpc3QpIHtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogUmVmIGVhY2ggc3ViY2hhbm5lbCBiZWZvcmUgcmVzZXR0aW5nIHRoZSBsaXN0LCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgKiBzdWJjaGFubmVscyBzaGFyZWQgYmV0d2VlbiB0aGUgbGlzdCBkb24ndCBkcm9wIHRvIDAgcmVmcyBkdXJpbmcgdGhlXG4gICAgICAgICAqIHRyYW5zaXRpb24uICovXG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgbmV3Q2hpbGRyZW5MaXN0KSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbkxpc3Q7XG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygwKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChtYXliZUVuZHBvaW50TGlzdCwgbGJDb25maWcsIG9wdGlvbnMsIHJlc29sdXRpb25Ob3RlKSB7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1heWJlRW5kcG9pbnRMaXN0Lm9rKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgdGhpcy5jdXJyZW50UGljayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcihtYXliZUVuZHBvaW50TGlzdC5lcnJvciksIG1heWJlRW5kcG9pbnRMaXN0LmVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZHBvaW50TGlzdCA9IG1heWJlRW5kcG9pbnRMaXN0LnZhbHVlO1xuICAgICAgICB0aGlzLnJlcG9ydEhlYWx0aFN0YXR1cyA9IG9wdGlvbnNbUkVQT1JUX0hFQUxUSF9TVEFUVVNfT1BUSU9OX05BTUVdO1xuICAgICAgICAvKiBQcmV2aW91c2x5LCBhbiB1cGRhdGUgd291bGQgYmUgZGlzY2FyZGVkIGlmIGl0IHdhcyBpZGVudGljYWwgdG8gdGhlXG4gICAgICAgICAqIHByZXZpb3VzIHVwZGF0ZSwgdG8gbWluaW1pemUgY2h1cm4uIE5vdyB0aGUgRE5TIHJlc29sdmVyIGlzXG4gICAgICAgICAqIHJhdGUtbGltaXRlZCwgc28gdGhhdCBpcyBsZXNzIG9mIGEgY29uY2Vybi4gKi9cbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFNodWZmbGVBZGRyZXNzTGlzdCgpKSB7XG4gICAgICAgICAgICBlbmRwb2ludExpc3QgPSBzaHVmZmxlZChlbmRwb2ludExpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0FkZHJlc3NMaXN0ID0gW10uY29uY2F0KC4uLmVuZHBvaW50TGlzdC5tYXAoZW5kcG9pbnQgPT4gZW5kcG9pbnQuYWRkcmVzc2VzKSk7XG4gICAgICAgIHRyYWNlKCd1cGRhdGVBZGRyZXNzTGlzdChbJyArIHJhd0FkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkgKyAnXSknKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBpbnRlcmxlYXZlQWRkcmVzc0ZhbWlsaWVzKHJhd0FkZHJlc3NMaXN0KTtcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IGFkZHJlc3NMaXN0O1xuICAgICAgICB0aGlzLmxhdGVzdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sYXRlc3RSZXNvbHV0aW9uTm90ZSA9IHJlc29sdXRpb25Ob3RlO1xuICAgICAgICBpZiAocmF3QWRkcmVzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9ICdObyBhZGRyZXNzZXMgcmVzb2x2ZWQnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgJiZcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QodGhpcy5sYXRlc3RBZGRyZXNzTGlzdCwgdGhpcy5sYXRlc3RPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBQaWNrRmlyc3RMb2FkQmFsYW5jZXI7XG5jb25zdCBMRUFGX0NPTkZJRyA9IG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKGZhbHNlKTtcbi8qKlxuICogVGhpcyBjbGFzcyBoYW5kbGVzIHRoZSBsZWFmIGxvYWQgYmFsYW5jaW5nIG9wZXJhdGlvbnMgZm9yIGEgc2luZ2xlIGVuZHBvaW50LlxuICogSXQgaXMgYSB0aGluIHdyYXBwZXIgYXJvdW5kIGEgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHdpdGggYSBkaWZmZXJlbnQgQVBJXG4gKiB0aGF0IG1vcmUgY2xvc2VseSByZWZsZWN0cyBob3cgaXQgd2lsbCBiZSB1c2VkIGFzIGEgbGVhZiBiYWxhbmNlci5cbiAqL1xuY2xhc3MgTGVhZkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoZW5kcG9pbnQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSkge1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbk5vdGUgPSByZXNvbHV0aW9uTm90ZTtcbiAgICAgICAgdGhpcy5sYXRlc3RTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpKGNoYW5uZWxDb250cm9sSGVscGVyLCB7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIgPSBuZXcgUGlja0ZpcnN0TG9hZEJhbGFuY2VyKGNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpO1xuICAgICAgICB0aGlzLmxhdGVzdFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzLnBpY2tGaXJzdEJhbGFuY2VyKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB0aGlzLnBpY2tGaXJzdEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KCgwLCBjYWxsX2ludGVyZmFjZV8xLnN0YXR1c09yRnJvbVZhbHVlKShbdGhpcy5lbmRwb2ludF0pLCBMRUFGX0NPTkZJRywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IFtSRVBPUlRfSEVBTFRIX1NUQVRVU19PUFRJT05fTkFNRV06IHRydWUgfSksIHRoaXMucmVzb2x1dGlvbk5vdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlYWZMb2FkQmFsYW5jZXIgdG8gYSBuZXdcbiAgICAgKiBlbmRwb2ludC4gRG9lcyBub3QgdHJpZ2dlciBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgaWYgYSBjb25uZWN0aW9uXG4gICAgICogYXR0ZW1wdCBpcyBub3QgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcGFyYW0gbmV3RW5kcG9pbnRcbiAgICAgKi9cbiAgICB1cGRhdGVFbmRwb2ludChuZXdFbmRwb2ludCwgbmV3T3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3RW5kcG9pbnQ7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdFN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RTdGF0ZTtcbiAgICB9XG4gICAgZ2V0UGlja2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RQaWNrZXI7XG4gICAgfVxuICAgIGdldEVuZHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRwb2ludDtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5waWNrRmlyc3RCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5MZWFmTG9hZEJhbGFuY2VyID0gTGVhZkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFBpY2tGaXJzdExvYWRCYWxhbmNlciwgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyk7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RoundRobinLoadBalancer = void 0;\nexports.setup = setup;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(children, nextIndex = 0) {\n        this.children = children;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const childPicker = this.children[this.nextIndex].picker;\n        this.nextIndex = (this.nextIndex + 1) % this.children.length;\n        return childPicker.pick(pickArgs);\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextEndpoint() {\n        return this.children[this.nextIndex].endpoint;\n    }\n}\nfunction rotateArray(list, startIndex) {\n    return [...list.slice(startIndex), ...list.slice(0, startIndex)];\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.children = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.updatesPaused = false;\n        this.lastError = null;\n        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n            updateState: (connectivityState, picker, errorMessage) => {\n                /* Ensure that name resolution is requested again after active\n                 * connections are dropped. This is more aggressive than necessary to\n                 * accomplish that, so we are counting on resolvers to have\n                 * reasonable rate limits. */\n                if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n                    this.channelControlHelper.requestReresolution();\n                }\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.calculateAndUpdateState();\n            },\n        });\n    }\n    countChildrenWithState(state) {\n        return this.children.filter(child => child.getConnectivityState() === state)\n            .length;\n    }\n    calculateAndUpdateState() {\n        if (this.updatesPaused) {\n            return;\n        }\n        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();\n                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({\n                endpoint: child.getEndpoint(),\n                picker: child.getPicker(),\n            })), index), null);\n        }\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n        }\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            const errorMessage = `round_robin: No connection established. Last error: ${this.lastError}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: errorMessage,\n            }), errorMessage);\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        }\n        /* round_robin should keep all children connected, this is how we do that.\n         * We can't do this more efficiently in the individual child's updateState\n         * callback because that doesn't have a reference to which child the state\n         * change is associated with. */\n        for (const child of this.children) {\n            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n                child.exitIdle();\n            }\n        }\n    }\n    updateState(newState, picker, errorMessage) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\n    }\n    resetSubchannelList() {\n        for (const child of this.children) {\n            child.destroy();\n        }\n        this.children = [];\n    }\n    updateAddressList(maybeEndpointList, lbConfig, options, resolutionNote) {\n        if (!(lbConfig instanceof RoundRobinLoadBalancingConfig)) {\n            return false;\n        }\n        if (!maybeEndpointList.ok) {\n            if (this.children.length === 0) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(maybeEndpointList.error), maybeEndpointList.error.details);\n            }\n            return true;\n        }\n        const startIndex = (Math.random() * maybeEndpointList.value.length) | 0;\n        const endpointList = rotateArray(maybeEndpointList.value, startIndex);\n        this.resetSubchannelList();\n        if (endpointList.length === 0) {\n            const errorMessage = `No addresses resolved. Resolution note: ${resolutionNote}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: errorMessage }), errorMessage);\n        }\n        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));\n        this.updatesPaused = true;\n        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, options, resolutionNote));\n        for (const child of this.children) {\n            child.startConnecting();\n        }\n        this.updatesPaused = false;\n        this.calculateAndUpdateState();\n        return true;\n    }\n    exitIdle() {\n        /* The round_robin LB policy is only in the IDLE state if it has no\n         * addresses to try to connect to and it has no picked subchannel.\n         * In that case, there is no meaningful action that can be taken here. */\n    }\n    resetBackoff() {\n        // This LB policy has no backoff to reset\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCLGFBQWE7QUFDYix3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxtQ0FBbUMsbUJBQU8sQ0FBQyx1SEFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsZUFBZTtBQUN2RztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRix3SEFBd0gsdUJBQXVCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcz9kZDdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIgPSB2b2lkIDA7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncm91bmRfcm9iaW4nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBuZXh0SW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQaWNrZXIgPSB0aGlzLmNoaWxkcmVuW3RoaXMubmV4dEluZGV4XS5waWNrZXI7XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gKHRoaXMubmV4dEluZGV4ICsgMSkgJSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNoaWxkUGlja2VyLnBpY2socGlja0FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0RW5kcG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMubmV4dEluZGV4XS5lbmRwb2ludDtcbiAgICB9XG59XG5mdW5jdGlvbiByb3RhdGVBcnJheShsaXN0LCBzdGFydEluZGV4KSB7XG4gICAgcmV0dXJuIFsuLi5saXN0LnNsaWNlKHN0YXJ0SW5kZXgpLCAuLi5saXN0LnNsaWNlKDAsIHN0YXJ0SW5kZXgpXTtcbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBFbnN1cmUgdGhhdCBuYW1lIHJlc29sdXRpb24gaXMgcmVxdWVzdGVkIGFnYWluIGFmdGVyIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAqIGNvbm5lY3Rpb25zIGFyZSBkcm9wcGVkLiBUaGlzIGlzIG1vcmUgYWdncmVzc2l2ZSB0aGFuIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgICAgICAqIGFjY29tcGxpc2ggdGhhdCwgc28gd2UgYXJlIGNvdW50aW5nIG9uIHJlc29sdmVycyB0byBoYXZlXG4gICAgICAgICAgICAgICAgICogcmVhc29uYWJsZSByYXRlIGxpbWl0cy4gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZICYmIGNvbm5lY3Rpdml0eVN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IHN0YXRlKVxuICAgICAgICAgICAgLmxlbmd0aDtcbiAgICB9XG4gICAgY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlYWR5UGlja2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBpY2tlZEVuZHBvaW50ID0gdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIucGVla05leHRFbmRwb2ludCgpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVhZHlDaGlsZHJlbi5maW5kSW5kZXgoY2hpbGQgPT4gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50RXF1YWwpKGNoaWxkLmdldEVuZHBvaW50KCksIG5leHRQaWNrZWRFbmRwb2ludCkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBSb3VuZFJvYmluUGlja2VyKHJlYWR5Q2hpbGRyZW4ubWFwKGNoaWxkID0+ICh7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGNoaWxkLmdldEVuZHBvaW50KCksXG4gICAgICAgICAgICAgICAgcGlja2VyOiBjaGlsZC5nZXRQaWNrZXIoKSxcbiAgICAgICAgICAgIH0pKSwgaW5kZXgpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGByb3VuZF9yb2JpbjogTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvKiByb3VuZF9yb2JpbiBzaG91bGQga2VlcCBhbGwgY2hpbGRyZW4gY29ubmVjdGVkLCB0aGlzIGlzIGhvdyB3ZSBkbyB0aGF0LlxuICAgICAgICAgKiBXZSBjYW4ndCBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHkgaW4gdGhlIGluZGl2aWR1YWwgY2hpbGQncyB1cGRhdGVTdGF0ZVxuICAgICAgICAgKiBjYWxsYmFjayBiZWNhdXNlIHRoYXQgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHdoaWNoIGNoaWxkIHRoZSBzdGF0ZVxuICAgICAgICAgKiBjaGFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QobWF5YmVFbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSkge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF5YmVFbmRwb2ludExpc3Qub2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcihtYXliZUVuZHBvaW50TGlzdC5lcnJvciksIG1heWJlRW5kcG9pbnRMaXN0LmVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChNYXRoLnJhbmRvbSgpICogbWF5YmVFbmRwb2ludExpc3QudmFsdWUubGVuZ3RoKSB8IDA7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50TGlzdCA9IHJvdGF0ZUFycmF5KG1heWJlRW5kcG9pbnRMaXN0LnZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIGlmIChlbmRwb2ludExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gYWRkcmVzc2VzIHJlc29sdmVkLiBSZXNvbHV0aW9uIG5vdGU6ICR7cmVzb2x1dGlvbk5vdGV9YDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGVycm9yTWVzc2FnZSB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnQ29ubmVjdCB0byBlbmRwb2ludCBsaXN0ICcgKyBlbmRwb2ludExpc3QubWFwKHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50VG9TdHJpbmcpKTtcbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGVuZHBvaW50TGlzdC5tYXAoZW5kcG9pbnQgPT4gbmV3IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xLkxlYWZMb2FkQmFsYW5jZXIoZW5kcG9pbnQsIHRoaXMuY2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciwgb3B0aW9ucywgcmVzb2x1dGlvbk5vdGUpKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIC8qIFRoZSByb3VuZF9yb2JpbiBMQiBwb2xpY3kgaXMgb25seSBpbiB0aGUgSURMRSBzdGF0ZSBpZiBpdCBoYXMgbm9cbiAgICAgICAgICogYWRkcmVzc2VzIHRvIHRyeSB0byBjb25uZWN0IHRvIGFuZCBpdCBoYXMgbm8gcGlja2VkIHN1YmNoYW5uZWwuXG4gICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm8gbWVhbmluZ2Z1bCBhY3Rpb24gdGhhdCBjYW4gYmUgdGFrZW4gaGVyZS4gKi9cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvLyBUaGlzIExCIHBvbGljeSBoYXMgbm8gYmFja29mZiB0byByZXNldFxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gUm91bmRSb2JpbkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-weighted-round-robin.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-weighted-round-robin.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2025 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WeightedRoundRobinLoadBalancingConfig = void 0;\nexports.setup = setup;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst orca_1 = __webpack_require__(/*! ./orca */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/orca.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst priority_queue_1 = __webpack_require__(/*! ./priority-queue */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/priority-queue.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst TRACER_NAME = 'weighted_round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'weighted_round_robin';\nconst DEFAULT_OOB_REPORTING_PERIOD_MS = 10000;\nconst DEFAULT_BLACKOUT_PERIOD_MS = 10000;\nconst DEFAULT_WEIGHT_EXPIRATION_PERIOD_MS = 3 * 60000;\nconst DEFAULT_WEIGHT_UPDATE_PERIOD_MS = 1000;\nconst DEFAULT_ERROR_UTILIZATION_PENALTY = 1;\nfunction validateFieldType(obj, fieldName, expectedType) {\n    if (fieldName in obj &&\n        obj[fieldName] !== undefined &&\n        typeof obj[fieldName] !== expectedType) {\n        throw new Error(`weighted round robin config ${fieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction parseDurationField(obj, fieldName) {\n    if (fieldName in obj && obj[fieldName] !== undefined && obj[fieldName] !== null) {\n        let durationObject;\n        if ((0, duration_1.isDuration)(obj[fieldName])) {\n            durationObject = obj[fieldName];\n        }\n        else if ((0, duration_1.isDurationMessage)(obj[fieldName])) {\n            durationObject = (0, duration_1.durationMessageToDuration)(obj[fieldName]);\n        }\n        else if (typeof obj[fieldName] === 'string') {\n            const parsedDuration = (0, duration_1.parseDuration)(obj[fieldName]);\n            if (!parsedDuration) {\n                throw new Error(`weighted round robin config ${fieldName}: failed to parse duration string ${obj[fieldName]}`);\n            }\n            durationObject = parsedDuration;\n        }\n        else {\n            throw new Error(`weighted round robin config ${fieldName}: expected duration, got ${typeof obj[fieldName]}`);\n        }\n        return (0, duration_1.durationToMs)(durationObject);\n    }\n    return null;\n}\nclass WeightedRoundRobinLoadBalancingConfig {\n    constructor(enableOobLoadReport, oobLoadReportingPeriodMs, blackoutPeriodMs, weightExpirationPeriodMs, weightUpdatePeriodMs, errorUtilizationPenalty) {\n        this.enableOobLoadReport = enableOobLoadReport !== null && enableOobLoadReport !== void 0 ? enableOobLoadReport : false;\n        this.oobLoadReportingPeriodMs = oobLoadReportingPeriodMs !== null && oobLoadReportingPeriodMs !== void 0 ? oobLoadReportingPeriodMs : DEFAULT_OOB_REPORTING_PERIOD_MS;\n        this.blackoutPeriodMs = blackoutPeriodMs !== null && blackoutPeriodMs !== void 0 ? blackoutPeriodMs : DEFAULT_BLACKOUT_PERIOD_MS;\n        this.weightExpirationPeriodMs = weightExpirationPeriodMs !== null && weightExpirationPeriodMs !== void 0 ? weightExpirationPeriodMs : DEFAULT_WEIGHT_EXPIRATION_PERIOD_MS;\n        this.weightUpdatePeriodMs = Math.max(weightUpdatePeriodMs !== null && weightUpdatePeriodMs !== void 0 ? weightUpdatePeriodMs : DEFAULT_WEIGHT_UPDATE_PERIOD_MS, 100);\n        this.errorUtilizationPenalty = errorUtilizationPenalty !== null && errorUtilizationPenalty !== void 0 ? errorUtilizationPenalty : DEFAULT_ERROR_UTILIZATION_PENALTY;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            enable_oob_load_report: this.enableOobLoadReport,\n            oob_load_reporting_period: (0, duration_1.durationToString)((0, duration_1.msToDuration)(this.oobLoadReportingPeriodMs)),\n            blackout_period: (0, duration_1.durationToString)((0, duration_1.msToDuration)(this.blackoutPeriodMs)),\n            weight_expiration_period: (0, duration_1.durationToString)((0, duration_1.msToDuration)(this.weightExpirationPeriodMs)),\n            weight_update_period: (0, duration_1.durationToString)((0, duration_1.msToDuration)(this.weightUpdatePeriodMs)),\n            error_utilization_penalty: this.errorUtilizationPenalty\n        };\n    }\n    static createFromJson(obj) {\n        validateFieldType(obj, 'enable_oob_load_report', 'boolean');\n        validateFieldType(obj, 'error_utilization_penalty', 'number');\n        if (obj.error_utilization_penalty < 0) {\n            throw new Error('weighted round robin config error_utilization_penalty < 0');\n        }\n        return new WeightedRoundRobinLoadBalancingConfig(obj.enable_oob_load_report, parseDurationField(obj, 'oob_load_reporting_period'), parseDurationField(obj, 'blackout_period'), parseDurationField(obj, 'weight_expiration_period'), parseDurationField(obj, 'weight_update_period'), obj.error_utilization_penalty);\n    }\n    getEnableOobLoadReport() {\n        return this.enableOobLoadReport;\n    }\n    getOobLoadReportingPeriodMs() {\n        return this.oobLoadReportingPeriodMs;\n    }\n    getBlackoutPeriodMs() {\n        return this.blackoutPeriodMs;\n    }\n    getWeightExpirationPeriodMs() {\n        return this.weightExpirationPeriodMs;\n    }\n    getWeightUpdatePeriodMs() {\n        return this.weightUpdatePeriodMs;\n    }\n    getErrorUtilizationPenalty() {\n        return this.errorUtilizationPenalty;\n    }\n}\nexports.WeightedRoundRobinLoadBalancingConfig = WeightedRoundRobinLoadBalancingConfig;\nclass WeightedRoundRobinPicker {\n    constructor(children, metricsHandler) {\n        this.metricsHandler = metricsHandler;\n        this.queue = new priority_queue_1.PriorityQueue((a, b) => a.deadline < b.deadline);\n        const positiveWeight = children.filter(picker => picker.weight > 0);\n        let averageWeight;\n        if (positiveWeight.length < 2) {\n            averageWeight = 1;\n        }\n        else {\n            let weightSum = 0;\n            for (const { weight } of positiveWeight) {\n                weightSum += weight;\n            }\n            averageWeight = weightSum / positiveWeight.length;\n        }\n        for (const child of children) {\n            const period = child.weight > 0 ? 1 / child.weight : averageWeight;\n            this.queue.push({\n                endpointName: child.endpointName,\n                picker: child.picker,\n                period: period,\n                deadline: Math.random() * period\n            });\n        }\n    }\n    pick(pickArgs) {\n        const entry = this.queue.pop();\n        this.queue.push(Object.assign(Object.assign({}, entry), { deadline: entry.deadline + entry.period }));\n        const childPick = entry.picker.pick(pickArgs);\n        if (childPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            if (this.metricsHandler) {\n                return Object.assign(Object.assign({}, childPick), { onCallEnded: (0, orca_1.createMetricsReader)(loadReport => this.metricsHandler(loadReport, entry.endpointName), childPick.onCallEnded) });\n            }\n            else {\n                const subchannelWrapper = childPick.subchannel;\n                return Object.assign(Object.assign({}, childPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return childPick;\n        }\n    }\n}\nclass WeightedRoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.latestConfig = null;\n        this.children = new Map();\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.updatesPaused = false;\n        this.lastError = null;\n        this.weightUpdateTimer = null;\n    }\n    countChildrenWithState(state) {\n        let count = 0;\n        for (const entry of this.children.values()) {\n            if (entry.child.getConnectivityState() === state) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    updateWeight(entry, loadReport) {\n        var _a, _b;\n        const qps = loadReport.rps_fractional;\n        let utilization = loadReport.application_utilization;\n        if (utilization > 0 && qps > 0) {\n            utilization += (loadReport.eps / qps) * ((_b = (_a = this.latestConfig) === null || _a === void 0 ? void 0 : _a.getErrorUtilizationPenalty()) !== null && _b !== void 0 ? _b : 0);\n        }\n        const newWeight = utilization === 0 ? 0 : qps / utilization;\n        if (newWeight === 0) {\n            return;\n        }\n        const now = new Date();\n        if (entry.nonEmptySince === null) {\n            entry.nonEmptySince = now;\n        }\n        entry.lastUpdated = now;\n        entry.weight = newWeight;\n    }\n    getWeight(entry) {\n        if (!this.latestConfig) {\n            return 0;\n        }\n        const now = new Date().getTime();\n        if (now - entry.lastUpdated.getTime() >= this.latestConfig.getWeightExpirationPeriodMs()) {\n            entry.nonEmptySince = null;\n            return 0;\n        }\n        const blackoutPeriod = this.latestConfig.getBlackoutPeriodMs();\n        if (blackoutPeriod > 0 && (entry.nonEmptySince === null || now - entry.nonEmptySince.getTime() < blackoutPeriod)) {\n            return 0;\n        }\n        return entry.weight;\n    }\n    calculateAndUpdateState() {\n        if (this.updatesPaused || !this.latestConfig) {\n            return;\n        }\n        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const weightedPickers = [];\n            for (const [endpoint, entry] of this.children) {\n                if (entry.child.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                    continue;\n                }\n                weightedPickers.push({\n                    endpointName: endpoint,\n                    picker: entry.child.getPicker(),\n                    weight: this.getWeight(entry)\n                });\n            }\n            trace('Created picker with weights: ' + weightedPickers.map(entry => entry.endpointName + ':' + entry.weight).join(','));\n            let metricsHandler;\n            if (!this.latestConfig.getEnableOobLoadReport()) {\n                metricsHandler = (loadReport, endpointName) => {\n                    const childEntry = this.children.get(endpointName);\n                    if (childEntry) {\n                        this.updateWeight(childEntry, loadReport);\n                    }\n                };\n            }\n            else {\n                metricsHandler = null;\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new WeightedRoundRobinPicker(weightedPickers, metricsHandler), null);\n        }\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n        }\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            const errorMessage = `weighted_round_robin: No connection established. Last error: ${this.lastError}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: errorMessage,\n            }), errorMessage);\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        }\n        /* round_robin should keep all children connected, this is how we do that.\n          * We can't do this more efficiently in the individual child's updateState\n          * callback because that doesn't have a reference to which child the state\n          * change is associated with. */\n        for (const { child } of this.children.values()) {\n            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n                child.exitIdle();\n            }\n        }\n    }\n    updateState(newState, picker, errorMessage) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\n    }\n    updateAddressList(maybeEndpointList, lbConfig, options, resolutionNote) {\n        var _a, _b;\n        if (!(lbConfig instanceof WeightedRoundRobinLoadBalancingConfig)) {\n            return false;\n        }\n        if (!maybeEndpointList.ok) {\n            if (this.children.size === 0) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(maybeEndpointList.error), maybeEndpointList.error.details);\n            }\n            return true;\n        }\n        if (maybeEndpointList.value.length === 0) {\n            const errorMessage = `No addresses resolved. Resolution note: ${resolutionNote}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: errorMessage }), errorMessage);\n            return false;\n        }\n        trace('Connect to endpoint list ' + maybeEndpointList.value.map(subchannel_address_1.endpointToString));\n        const now = new Date();\n        const seenEndpointNames = new Set();\n        this.updatesPaused = true;\n        this.latestConfig = lbConfig;\n        for (const endpoint of maybeEndpointList.value) {\n            const name = (0, subchannel_address_1.endpointToString)(endpoint);\n            seenEndpointNames.add(name);\n            let entry = this.children.get(name);\n            if (!entry) {\n                entry = {\n                    child: new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, (0, load_balancer_1.createChildChannelControlHelper)(this.channelControlHelper, {\n                        updateState: (connectivityState, picker, errorMessage) => {\n                            /* Ensure that name resolution is requested again after active\n                              * connections are dropped. This is more aggressive than necessary to\n                              * accomplish that, so we are counting on resolvers to have\n                              * reasonable rate limits. */\n                            if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n                                this.channelControlHelper.requestReresolution();\n                            }\n                            if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                                entry.nonEmptySince = null;\n                            }\n                            if (errorMessage) {\n                                this.lastError = errorMessage;\n                            }\n                            this.calculateAndUpdateState();\n                        },\n                        createSubchannel: (subchannelAddress, subchannelArgs) => {\n                            const subchannel = this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                            if (entry === null || entry === void 0 ? void 0 : entry.oobMetricsListener) {\n                                return new orca_1.OrcaOobMetricsSubchannelWrapper(subchannel, entry.oobMetricsListener, this.latestConfig.getOobLoadReportingPeriodMs());\n                            }\n                            else {\n                                return subchannel;\n                            }\n                        }\n                    }), options, resolutionNote),\n                    lastUpdated: now,\n                    nonEmptySince: null,\n                    weight: 0,\n                    oobMetricsListener: null\n                };\n                this.children.set(name, entry);\n            }\n            if (lbConfig.getEnableOobLoadReport()) {\n                entry.oobMetricsListener = loadReport => {\n                    this.updateWeight(entry, loadReport);\n                };\n            }\n            else {\n                entry.oobMetricsListener = null;\n            }\n        }\n        for (const [endpointName, entry] of this.children) {\n            if (seenEndpointNames.has(endpointName)) {\n                entry.child.startConnecting();\n            }\n            else {\n                entry.child.destroy();\n                this.children.delete(endpointName);\n            }\n        }\n        this.updatesPaused = false;\n        this.calculateAndUpdateState();\n        if (this.weightUpdateTimer) {\n            clearInterval(this.weightUpdateTimer);\n        }\n        this.weightUpdateTimer = (_b = (_a = setInterval(() => {\n            if (this.currentState === connectivity_state_1.ConnectivityState.READY) {\n                this.calculateAndUpdateState();\n            }\n        }, lbConfig.getWeightUpdatePeriodMs())).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return true;\n    }\n    exitIdle() {\n        /* The weighted_round_robin LB policy is only in the IDLE state if it has\n         * no addresses to try to connect to and it has no picked subchannel.\n         * In that case, there is no meaningful action that can be taken here. */\n    }\n    resetBackoff() {\n        // This LB policy has no backoff to reset\n    }\n    destroy() {\n        for (const entry of this.children.values()) {\n            entry.child.destroy();\n        }\n        this.children.clear();\n        if (this.weightUpdateTimer) {\n            clearInterval(this.weightUpdateTimer);\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, WeightedRoundRobinLoadBalancer, WeightedRoundRobinLoadBalancingConfig);\n}\n//# sourceMappingURL=load-balancer-weighted-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXdlaWdodGVkLXJvdW5kLXJvYmluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkNBQTZDO0FBQzdDLGFBQWE7QUFDYiw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELG1DQUFtQyxtQkFBTyxDQUFDLHVIQUE0QjtBQUN2RSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMsK0VBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsbUZBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMsbUdBQWtCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsd0JBQXdCLGFBQWEsUUFBUSxzQkFBc0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVLG9DQUFvQyxlQUFlO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVUsMkJBQTJCLHNCQUFzQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWSx5Q0FBeUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQix3SUFBd0k7QUFDN007QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQixzREFBc0Q7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGLHdIQUF3SCx1QkFBdUI7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItd2VpZ2h0ZWQtcm91bmQtcm9iaW4uanM/NjNjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyNSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWlnaHRlZFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgb3JjYV8xID0gcmVxdWlyZShcIi4vb3JjYVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgcHJpb3JpdHlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5LXF1ZXVlXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICd3ZWlnaHRlZF9yb3VuZF9yb2Jpbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICd3ZWlnaHRlZF9yb3VuZF9yb2Jpbic7XG5jb25zdCBERUZBVUxUX09PQl9SRVBPUlRJTkdfUEVSSU9EX01TID0gMTAwMDA7XG5jb25zdCBERUZBVUxUX0JMQUNLT1VUX1BFUklPRF9NUyA9IDEwMDAwO1xuY29uc3QgREVGQVVMVF9XRUlHSFRfRVhQSVJBVElPTl9QRVJJT0RfTVMgPSAzICogNjAwMDA7XG5jb25zdCBERUZBVUxUX1dFSUdIVF9VUERBVEVfUEVSSU9EX01TID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfRVJST1JfVVRJTElaQVRJT05fUEVOQUxUWSA9IDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkVHlwZShvYmosIGZpZWxkTmFtZSwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiZcbiAgICAgICAgb2JqW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb2JqW2ZpZWxkTmFtZV0gIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdlaWdodGVkIHJvdW5kIHJvYmluIGNvbmZpZyAke2ZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRHVyYXRpb25GaWVsZChvYmosIGZpZWxkTmFtZSkge1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmIG9ialtmaWVsZE5hbWVdICE9PSB1bmRlZmluZWQgJiYgb2JqW2ZpZWxkTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGR1cmF0aW9uT2JqZWN0O1xuICAgICAgICBpZiAoKDAsIGR1cmF0aW9uXzEuaXNEdXJhdGlvbikob2JqW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBkdXJhdGlvbk9iamVjdCA9IG9ialtmaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb25NZXNzYWdlKShvYmpbZmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uT2JqZWN0ID0gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25NZXNzYWdlVG9EdXJhdGlvbikob2JqW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmpbZmllbGROYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZER1cmF0aW9uID0gKDAsIGR1cmF0aW9uXzEucGFyc2VEdXJhdGlvbikob2JqW2ZpZWxkTmFtZV0pO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWREdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2VpZ2h0ZWQgcm91bmQgcm9iaW4gY29uZmlnICR7ZmllbGROYW1lfTogZmFpbGVkIHRvIHBhcnNlIGR1cmF0aW9uIHN0cmluZyAke29ialtmaWVsZE5hbWVdfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb25PYmplY3QgPSBwYXJzZWREdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2VpZ2h0ZWQgcm91bmQgcm9iaW4gY29uZmlnICR7ZmllbGROYW1lfTogZXhwZWN0ZWQgZHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShkdXJhdGlvbk9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgV2VpZ2h0ZWRSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZW5hYmxlT29iTG9hZFJlcG9ydCwgb29iTG9hZFJlcG9ydGluZ1BlcmlvZE1zLCBibGFja291dFBlcmlvZE1zLCB3ZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMsIHdlaWdodFVwZGF0ZVBlcmlvZE1zLCBlcnJvclV0aWxpemF0aW9uUGVuYWx0eSkge1xuICAgICAgICB0aGlzLmVuYWJsZU9vYkxvYWRSZXBvcnQgPSBlbmFibGVPb2JMb2FkUmVwb3J0ICE9PSBudWxsICYmIGVuYWJsZU9vYkxvYWRSZXBvcnQgIT09IHZvaWQgMCA/IGVuYWJsZU9vYkxvYWRSZXBvcnQgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5vb2JMb2FkUmVwb3J0aW5nUGVyaW9kTXMgPSBvb2JMb2FkUmVwb3J0aW5nUGVyaW9kTXMgIT09IG51bGwgJiYgb29iTG9hZFJlcG9ydGluZ1BlcmlvZE1zICE9PSB2b2lkIDAgPyBvb2JMb2FkUmVwb3J0aW5nUGVyaW9kTXMgOiBERUZBVUxUX09PQl9SRVBPUlRJTkdfUEVSSU9EX01TO1xuICAgICAgICB0aGlzLmJsYWNrb3V0UGVyaW9kTXMgPSBibGFja291dFBlcmlvZE1zICE9PSBudWxsICYmIGJsYWNrb3V0UGVyaW9kTXMgIT09IHZvaWQgMCA/IGJsYWNrb3V0UGVyaW9kTXMgOiBERUZBVUxUX0JMQUNLT1VUX1BFUklPRF9NUztcbiAgICAgICAgdGhpcy53ZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMgPSB3ZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMgIT09IG51bGwgJiYgd2VpZ2h0RXhwaXJhdGlvblBlcmlvZE1zICE9PSB2b2lkIDAgPyB3ZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMgOiBERUZBVUxUX1dFSUdIVF9FWFBJUkFUSU9OX1BFUklPRF9NUztcbiAgICAgICAgdGhpcy53ZWlnaHRVcGRhdGVQZXJpb2RNcyA9IE1hdGgubWF4KHdlaWdodFVwZGF0ZVBlcmlvZE1zICE9PSBudWxsICYmIHdlaWdodFVwZGF0ZVBlcmlvZE1zICE9PSB2b2lkIDAgPyB3ZWlnaHRVcGRhdGVQZXJpb2RNcyA6IERFRkFVTFRfV0VJR0hUX1VQREFURV9QRVJJT0RfTVMsIDEwMCk7XG4gICAgICAgIHRoaXMuZXJyb3JVdGlsaXphdGlvblBlbmFsdHkgPSBlcnJvclV0aWxpemF0aW9uUGVuYWx0eSAhPT0gbnVsbCAmJiBlcnJvclV0aWxpemF0aW9uUGVuYWx0eSAhPT0gdm9pZCAwID8gZXJyb3JVdGlsaXphdGlvblBlbmFsdHkgOiBERUZBVUxUX0VSUk9SX1VUSUxJWkFUSU9OX1BFTkFMVFk7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuYWJsZV9vb2JfbG9hZF9yZXBvcnQ6IHRoaXMuZW5hYmxlT29iTG9hZFJlcG9ydCxcbiAgICAgICAgICAgIG9vYl9sb2FkX3JlcG9ydGluZ19wZXJpb2Q6ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9TdHJpbmcpKCgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5vb2JMb2FkUmVwb3J0aW5nUGVyaW9kTXMpKSxcbiAgICAgICAgICAgIGJsYWNrb3V0X3BlcmlvZDogKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub1N0cmluZykoKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLmJsYWNrb3V0UGVyaW9kTXMpKSxcbiAgICAgICAgICAgIHdlaWdodF9leHBpcmF0aW9uX3BlcmlvZDogKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub1N0cmluZykoKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLndlaWdodEV4cGlyYXRpb25QZXJpb2RNcykpLFxuICAgICAgICAgICAgd2VpZ2h0X3VwZGF0ZV9wZXJpb2Q6ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9TdHJpbmcpKCgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy53ZWlnaHRVcGRhdGVQZXJpb2RNcykpLFxuICAgICAgICAgICAgZXJyb3JfdXRpbGl6YXRpb25fcGVuYWx0eTogdGhpcy5lcnJvclV0aWxpemF0aW9uUGVuYWx0eVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgJ2VuYWJsZV9vb2JfbG9hZF9yZXBvcnQnLCAnYm9vbGVhbicpO1xuICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmosICdlcnJvcl91dGlsaXphdGlvbl9wZW5hbHR5JywgJ251bWJlcicpO1xuICAgICAgICBpZiAob2JqLmVycm9yX3V0aWxpemF0aW9uX3BlbmFsdHkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dlaWdodGVkIHJvdW5kIHJvYmluIGNvbmZpZyBlcnJvcl91dGlsaXphdGlvbl9wZW5hbHR5IDwgMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2VpZ2h0ZWRSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyhvYmouZW5hYmxlX29vYl9sb2FkX3JlcG9ydCwgcGFyc2VEdXJhdGlvbkZpZWxkKG9iaiwgJ29vYl9sb2FkX3JlcG9ydGluZ19wZXJpb2QnKSwgcGFyc2VEdXJhdGlvbkZpZWxkKG9iaiwgJ2JsYWNrb3V0X3BlcmlvZCcpLCBwYXJzZUR1cmF0aW9uRmllbGQob2JqLCAnd2VpZ2h0X2V4cGlyYXRpb25fcGVyaW9kJyksIHBhcnNlRHVyYXRpb25GaWVsZChvYmosICd3ZWlnaHRfdXBkYXRlX3BlcmlvZCcpLCBvYmouZXJyb3JfdXRpbGl6YXRpb25fcGVuYWx0eSk7XG4gICAgfVxuICAgIGdldEVuYWJsZU9vYkxvYWRSZXBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZU9vYkxvYWRSZXBvcnQ7XG4gICAgfVxuICAgIGdldE9vYkxvYWRSZXBvcnRpbmdQZXJpb2RNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub29iTG9hZFJlcG9ydGluZ1BlcmlvZE1zO1xuICAgIH1cbiAgICBnZXRCbGFja291dFBlcmlvZE1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibGFja291dFBlcmlvZE1zO1xuICAgIH1cbiAgICBnZXRXZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodEV4cGlyYXRpb25QZXJpb2RNcztcbiAgICB9XG4gICAgZ2V0V2VpZ2h0VXBkYXRlUGVyaW9kTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodFVwZGF0ZVBlcmlvZE1zO1xuICAgIH1cbiAgICBnZXRFcnJvclV0aWxpemF0aW9uUGVuYWx0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JVdGlsaXphdGlvblBlbmFsdHk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWlnaHRlZFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnID0gV2VpZ2h0ZWRSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZztcbmNsYXNzIFdlaWdodGVkUm91bmRSb2JpblBpY2tlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIG1ldHJpY3NIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWV0cmljc0hhbmRsZXIgPSBtZXRyaWNzSGFuZGxlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBwcmlvcml0eV9xdWV1ZV8xLlByaW9yaXR5UXVldWUoKGEsIGIpID0+IGEuZGVhZGxpbmUgPCBiLmRlYWRsaW5lKTtcbiAgICAgICAgY29uc3QgcG9zaXRpdmVXZWlnaHQgPSBjaGlsZHJlbi5maWx0ZXIocGlja2VyID0+IHBpY2tlci53ZWlnaHQgPiAwKTtcbiAgICAgICAgbGV0IGF2ZXJhZ2VXZWlnaHQ7XG4gICAgICAgIGlmIChwb3NpdGl2ZVdlaWdodC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBhdmVyYWdlV2VpZ2h0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB3ZWlnaHRTdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHdlaWdodCB9IG9mIHBvc2l0aXZlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0U3VtICs9IHdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2ZXJhZ2VXZWlnaHQgPSB3ZWlnaHRTdW0gLyBwb3NpdGl2ZVdlaWdodC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgcGVyaW9kID0gY2hpbGQud2VpZ2h0ID4gMCA/IDEgLyBjaGlsZC53ZWlnaHQgOiBhdmVyYWdlV2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGNoaWxkLmVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgICAgICBwaWNrZXI6IGNoaWxkLnBpY2tlcixcbiAgICAgICAgICAgICAgICBwZXJpb2Q6IHBlcmlvZCxcbiAgICAgICAgICAgICAgICBkZWFkbGluZTogTWF0aC5yYW5kb20oKSAqIHBlcmlvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBkZWFkbGluZTogZW50cnkuZGVhZGxpbmUgKyBlbnRyeS5wZXJpb2QgfSkpO1xuICAgICAgICBjb25zdCBjaGlsZFBpY2sgPSBlbnRyeS5waWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIGlmIChjaGlsZFBpY2sucGlja1Jlc3VsdFR5cGUgPT09IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRyaWNzSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoaWxkUGljayksIHsgb25DYWxsRW5kZWQ6ICgwLCBvcmNhXzEuY3JlYXRlTWV0cmljc1JlYWRlcikobG9hZFJlcG9ydCA9PiB0aGlzLm1ldHJpY3NIYW5kbGVyKGxvYWRSZXBvcnQsIGVudHJ5LmVuZHBvaW50TmFtZSksIGNoaWxkUGljay5vbkNhbGxFbmRlZCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsV3JhcHBlciA9IGNoaWxkUGljay5zdWJjaGFubmVsO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoaWxkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFBpY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBXZWlnaHRlZFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMudXBkYXRlc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMud2VpZ2h0VXBkYXRlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBjb3VudENoaWxkcmVuV2l0aFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5jaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIHVwZGF0ZVdlaWdodChlbnRyeSwgbG9hZFJlcG9ydCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBxcHMgPSBsb2FkUmVwb3J0LnJwc19mcmFjdGlvbmFsO1xuICAgICAgICBsZXQgdXRpbGl6YXRpb24gPSBsb2FkUmVwb3J0LmFwcGxpY2F0aW9uX3V0aWxpemF0aW9uO1xuICAgICAgICBpZiAodXRpbGl6YXRpb24gPiAwICYmIHFwcyA+IDApIHtcbiAgICAgICAgICAgIHV0aWxpemF0aW9uICs9IChsb2FkUmVwb3J0LmVwcyAvIHFwcykgKiAoKF9iID0gKF9hID0gdGhpcy5sYXRlc3RDb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRFcnJvclV0aWxpemF0aW9uUGVuYWx0eSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdXZWlnaHQgPSB1dGlsaXphdGlvbiA9PT0gMCA/IDAgOiBxcHMgLyB1dGlsaXphdGlvbjtcbiAgICAgICAgaWYgKG5ld1dlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChlbnRyeS5ub25FbXB0eVNpbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbnRyeS5ub25FbXB0eVNpbmNlID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lmxhc3RVcGRhdGVkID0gbm93O1xuICAgICAgICBlbnRyeS53ZWlnaHQgPSBuZXdXZWlnaHQ7XG4gICAgfVxuICAgIGdldFdlaWdodChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKG5vdyAtIGVudHJ5Lmxhc3RVcGRhdGVkLmdldFRpbWUoKSA+PSB0aGlzLmxhdGVzdENvbmZpZy5nZXRXZWlnaHRFeHBpcmF0aW9uUGVyaW9kTXMoKSkge1xuICAgICAgICAgICAgZW50cnkubm9uRW1wdHlTaW5jZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibGFja291dFBlcmlvZCA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEJsYWNrb3V0UGVyaW9kTXMoKTtcbiAgICAgICAgaWYgKGJsYWNrb3V0UGVyaW9kID4gMCAmJiAoZW50cnkubm9uRW1wdHlTaW5jZSA9PT0gbnVsbCB8fCBub3cgLSBlbnRyeS5ub25FbXB0eVNpbmNlLmdldFRpbWUoKSA8IGJsYWNrb3V0UGVyaW9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndlaWdodDtcbiAgICB9XG4gICAgY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZXNQYXVzZWQgfHwgIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnRDaGlsZHJlbldpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHRlZFBpY2tlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VuZHBvaW50LCBlbnRyeV0gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRQaWNrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBwaWNrZXI6IGVudHJ5LmNoaWxkLmdldFBpY2tlcigpLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXMuZ2V0V2VpZ2h0KGVudHJ5KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0NyZWF0ZWQgcGlja2VyIHdpdGggd2VpZ2h0czogJyArIHdlaWdodGVkUGlja2Vycy5tYXAoZW50cnkgPT4gZW50cnkuZW5kcG9pbnROYW1lICsgJzonICsgZW50cnkud2VpZ2h0KS5qb2luKCcsJykpO1xuICAgICAgICAgICAgbGV0IG1ldHJpY3NIYW5kbGVyO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZy5nZXRFbmFibGVPb2JMb2FkUmVwb3J0KCkpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzSGFuZGxlciA9IChsb2FkUmVwb3J0LCBlbmRwb2ludE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFbnRyeSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVdlaWdodChjaGlsZEVudHJ5LCBsb2FkUmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgV2VpZ2h0ZWRSb3VuZFJvYmluUGlja2VyKHdlaWdodGVkUGlja2VycywgbWV0cmljc0hhbmRsZXIpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGB3ZWlnaHRlZF9yb3VuZF9yb2JpbjogTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvKiByb3VuZF9yb2JpbiBzaG91bGQga2VlcCBhbGwgY2hpbGRyZW4gY29ubmVjdGVkLCB0aGlzIGlzIGhvdyB3ZSBkbyB0aGF0LlxuICAgICAgICAgICogV2UgY2FuJ3QgZG8gdGhpcyBtb3JlIGVmZmljaWVudGx5IGluIHRoZSBpbmRpdmlkdWFsIGNoaWxkJ3MgdXBkYXRlU3RhdGVcbiAgICAgICAgICAqIGNhbGxiYWNrIGJlY2F1c2UgdGhhdCBkb2Vzbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gd2hpY2ggY2hpbGQgdGhlIHN0YXRlXG4gICAgICAgICAgKiBjaGFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IHsgY2hpbGQgfSBvZiB0aGlzLmNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChtYXliZUVuZHBvaW50TGlzdCwgbGJDb25maWcsIG9wdGlvbnMsIHJlc29sdXRpb25Ob3RlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgV2VpZ2h0ZWRSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1heWJlRW5kcG9pbnRMaXN0Lm9rKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKG1heWJlRW5kcG9pbnRMaXN0LmVycm9yKSwgbWF5YmVFbmRwb2ludExpc3QuZXJyb3IuZGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVFbmRwb2ludExpc3QudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gYWRkcmVzc2VzIHJlc29sdmVkLiBSZXNvbHV0aW9uIG5vdGU6ICR7cmVzb2x1dGlvbk5vdGV9YDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGVycm9yTWVzc2FnZSB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnQ29ubmVjdCB0byBlbmRwb2ludCBsaXN0ICcgKyBtYXliZUVuZHBvaW50TGlzdC52YWx1ZS5tYXAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWVuRW5kcG9pbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICAgICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBtYXliZUVuZHBvaW50TGlzdC52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5lbmRwb2ludFRvU3RyaW5nKShlbmRwb2ludCk7XG4gICAgICAgICAgICBzZWVuRW5kcG9pbnROYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLmNoaWxkcmVuLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQ6IG5ldyBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMS5MZWFmTG9hZEJhbGFuY2VyKGVuZHBvaW50LCAoMCwgbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpKHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRW5zdXJlIHRoYXQgbmFtZSByZXNvbHV0aW9uIGlzIHJlcXVlc3RlZCBhZ2FpbiBhZnRlciBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbnMgYXJlIGRyb3BwZWQuIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gbmVjZXNzYXJ5IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFjY29tcGxpc2ggdGhhdCwgc28gd2UgYXJlIGNvdW50aW5nIG9uIHJlc29sdmVycyB0byBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHJlYXNvbmFibGUgcmF0ZSBsaW1pdHMuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSAmJiBjb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubm9uRW1wdHlTaW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkub29iTWV0cmljc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb3JjYV8xLk9yY2FPb2JNZXRyaWNzU3ViY2hhbm5lbFdyYXBwZXIoc3ViY2hhbm5lbCwgZW50cnkub29iTWV0cmljc0xpc3RlbmVyLCB0aGlzLmxhdGVzdENvbmZpZy5nZXRPb2JMb2FkUmVwb3J0aW5nUGVyaW9kTXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLCBvcHRpb25zLCByZXNvbHV0aW9uTm90ZSksXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBub3csXG4gICAgICAgICAgICAgICAgICAgIG5vbkVtcHR5U2luY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgb29iTWV0cmljc0xpc3RlbmVyOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChuYW1lLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGJDb25maWcuZ2V0RW5hYmxlT29iTG9hZFJlcG9ydCgpKSB7XG4gICAgICAgICAgICAgICAgZW50cnkub29iTWV0cmljc0xpc3RlbmVyID0gbG9hZFJlcG9ydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlV2VpZ2h0KGVudHJ5LCBsb2FkUmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50cnkub29iTWV0cmljc0xpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludE5hbWUsIGVudHJ5XSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoc2VlbkVuZHBvaW50TmFtZXMuaGFzKGVuZHBvaW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5jaGlsZC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudHJ5LmNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShlbmRwb2ludE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIGlmICh0aGlzLndlaWdodFVwZGF0ZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMud2VpZ2h0VXBkYXRlVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2VpZ2h0VXBkYXRlVGltZXIgPSAoX2IgPSAoX2EgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBsYkNvbmZpZy5nZXRXZWlnaHRVcGRhdGVQZXJpb2RNcygpKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICAvKiBUaGUgd2VpZ2h0ZWRfcm91bmRfcm9iaW4gTEIgcG9saWN5IGlzIG9ubHkgaW4gdGhlIElETEUgc3RhdGUgaWYgaXQgaGFzXG4gICAgICAgICAqIG5vIGFkZHJlc3NlcyB0byB0cnkgdG8gY29ubmVjdCB0byBhbmQgaXQgaGFzIG5vIHBpY2tlZCBzdWJjaGFubmVsLlxuICAgICAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZXJlIGlzIG5vIG1lYW5pbmdmdWwgYWN0aW9uIHRoYXQgY2FuIGJlIHRha2VuIGhlcmUuICovXG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgLy8gVGhpcyBMQiBwb2xpY3kgaGFzIG5vIGJhY2tvZmYgdG8gcmVzZXRcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBlbnRyeS5jaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy53ZWlnaHRVcGRhdGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLndlaWdodFVwZGF0ZVRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBXZWlnaHRlZFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIsIFdlaWdodGVkUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci13ZWlnaHRlZC1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-weighted-round-robin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nexports.registerLoadBalancerType = registerLoadBalancerType;\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nexports.createLoadBalancer = createLoadBalancer;\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nexports.parseLoadBalancingConfig = parseLoadBalancingConfig;\nexports.getDefaultConfig = getDefaultConfig;\nexports.selectLbConfigFromList = selectLbConfigFromList;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */\nfunction createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),\n    };\n}\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType,\n    };\n}\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    }\n    else {\n        return null;\n    }\n}\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nfunction parseLoadBalancingConfig(rawConfig) {\n    const keys = Object.keys(rawConfig);\n    if (keys.length !== 1) {\n        throw new Error('Provided load balancing config has multiple conflicting entries');\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        try {\n            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);\n        }\n        catch (e) {\n            throw new Error(`${typeName}: ${e.message}`);\n        }\n    }\n    else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nfunction getDefaultConfig() {\n    if (!defaultLoadBalancerType) {\n        throw new Error('No default load balancer type registered');\n    }\n    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n}\nfunction selectLbConfigFromList(configs, fallbackTodefault = false) {\n    for (const config of configs) {\n        try {\n            return parseLoadBalancingConfig(config);\n        }\n        catch (e) {\n            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);\n            continue;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDO0FBQ3ZDLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkMsMEJBQTBCO0FBQzFCLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLDhCQUE4QjtBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLElBQUksVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLmpzPzhmMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGU7XG5leHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGNyZWF0ZUxvYWRCYWxhbmNlcjtcbmV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7XG5leHBvcnRzLnBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZztcbmV4cG9ydHMuZ2V0RGVmYXVsdENvbmZpZyA9IGdldERlZmF1bHRDb25maWc7XG5leHBvcnRzLnNlbGVjdExiQ29uZmlnRnJvbUxpc3QgPSBzZWxlY3RMYkNvbmZpZ0Zyb21MaXN0O1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBDaGFubmVsQ29udHJvbEhlbHBlciB0aGF0IG92ZXJyaWRlcyBzb21lIG1ldGhvZHMgb2YgdGhlXG4gKiBwYXJlbnQgd2hpbGUgbGV0dGluZyBvdGhlcnMgcGFzcyB0aHJvdWdoIHRvIHRoZSBwYXJlbnQgdW5tb2RpZmllZC4gVGhpc1xuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XG4gKiBhbGwgb2YgdGhlIG1ldGhvZHMgdG8gYmUgcGFzc2VkIHRocm91Z2guXG4gKiBAcGFyYW0gcGFyZW50XG4gKiBAcGFyYW0gb3ZlcnJpZGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKF9iID0gKF9hID0gb3ZlcnJpZGVzLmNyZWF0ZVN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBhcmVudC5jcmVhdGVTdWJjaGFubmVsLmJpbmQocGFyZW50KSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKF9mID0gKF9lID0gb3ZlcnJpZGVzLnJlcXVlc3RSZXJlc29sdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcmVudC5yZXF1ZXN0UmVyZXNvbHV0aW9uLmJpbmQocGFyZW50KSxcbiAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKF9oID0gKF9nID0gb3ZlcnJpZGVzLmFkZENoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHBhcmVudC5hZGRDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICB9O1xufVxuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XG5sZXQgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBudWxsO1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lLCBsb2FkQmFsYW5jZXJUeXBlLCBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSkge1xuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIExvYWRCYWxhbmNlcjogbG9hZEJhbGFuY2VyVHlwZSxcbiAgICAgICAgTG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUpIHtcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9hZEJhbGFuY2VyKGNvbmZpZywgY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2VyKGNoYW5uZWxDb250cm9sSGVscGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xufVxuZnVuY3Rpb24gcGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnKHJhd0NvbmZpZykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyYXdDb25maWcpO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBoYXMgbXVsdGlwbGUgY29uZmxpY3RpbmcgZW50cmllcycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IGtleXNbMF07XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2luZ0NvbmZpZy5jcmVhdGVGcm9tSnNvbihyYXdDb25maWdbdHlwZU5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGVOYW1lfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBuYW1lICR7dHlwZU5hbWV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICBpZiAoIWRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVmYXVsdCBsb2FkIGJhbGFuY2VyIHR5cGUgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xufVxuZnVuY3Rpb24gc2VsZWN0TGJDb25maWdGcm9tTGlzdChjb25maWdzLCBmYWxsYmFja1RvZGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyhjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnQ29uZmlnIHBhcnNpbmcgZmFpbGVkIHdpdGggZXJyb3InLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrVG9kZWZhdWx0KSB7XG4gICAgICAgIGlmIChkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbZGVmYXVsdExvYWRCYWxhbmNlclR5cGVdLkxvYWRCYWxhbmNpbmdDb25maWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        this.childStartTime = null;\n        const splitPath = this.methodName.split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n        this.startTime = new Date();\n    }\n    getDeadlineInfo() {\n        var _a, _b;\n        const deadlineInfo = [];\n        if (this.childStartTime) {\n            if (this.childStartTime > this.startTime) {\n                if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n                    deadlineInfo.push('wait_for_ready');\n                }\n                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);\n            }\n            deadlineInfo.push(...this.child.getDeadlineInfo());\n            return deadlineInfo;\n        }\n        else {\n            if ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.getOptions().waitForReady) {\n                deadlineInfo.push('wait_for_ready');\n            }\n            deadlineInfo.push('Waiting for LB pick');\n        }\n        return deadlineInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace('ended with status: code=' +\n                status.code +\n                ' details=\"' +\n                status.details +\n                '\" start time=' +\n                this.startTime.toISOString());\n            const finalStatus = Object.assign(Object.assign({}, status), { progress });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code, finalStatus.details, finalStatus.metadata);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error('doPick called before start');\n        }\n        this.trace('Pick called');\n        const finalMetadata = this.metadata.clone();\n        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel\n            ? '(' +\n                pickResult.subchannel.getChannelzRef().id +\n                ') ' +\n                pickResult.subchannel.getAddress()\n            : '' + pickResult.subchannel;\n        this.trace('Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' +\n            subchannelString +\n            ' status: ' +\n            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\n            ' ' +\n            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                const combinedCallCredentials = this.credentials.compose(pickResult.subchannel.getCallCredentials());\n                combinedCallCredentials\n                    .generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl })\n                    .then(credsMetadata => {\n                    var _a;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */\n                    if (this.ended) {\n                        this.trace('Credentials metadata generation finished after call ended');\n                        return;\n                    }\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get('authorization').length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata(),\n                        }, 'PROCESSED');\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        connectivity_state_1.ConnectivityState.READY) {\n                        this.trace('Picked subchannel ' +\n                            subchannelString +\n                            ' has state ' +\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +\n                            ' after getting credentials metadata. Retrying pick');\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult\n                            .subchannel.getRealSubchannel()\n                            .createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: metadata => {\n                                this.trace('Received metadata');\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: message => {\n                                this.trace('Received message');\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: status => {\n                                this.trace('Received status');\n                                if (status.rstCode ===\n                                    http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, 'REFUSED');\n                                }\n                                else {\n                                    this.outputStatus(status, 'PROCESSED');\n                                }\n                            },\n                        });\n                        this.childStartTime = new Date();\n                    }\n                    catch (error) {\n                        this.trace('Failed to start call on picked subchannel ' +\n                            subchannelString +\n                            ' with error ' +\n                            error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'Failed to start HTTP/2 stream with error ' +\n                                error.message,\n                            metadata: new metadata_1.Metadata(),\n                        }, 'NOT_STARTED');\n                        return;\n                    }\n                    (_a = pickResult.onCallStarted) === null || _a === void 0 ? void 0 : _a.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace('Created child call [' + this.child.getCallNumber() + ']');\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error) => {\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata(),\n                    }, 'PROCESSED');\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(() => {\n                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                }\n                else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(() => {\n                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error('Method not implemented.');\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    getAuthContext() {\n        if (this.child) {\n            return this.child.getAuthContext();\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall;\n//# sourceMappingURL=load-balancing-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2luZy1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQywrR0FBd0I7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVksRUFBRSxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUyxHQUFHLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEVBQTBFO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNERBQTREO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEIsZ0JBQWdCLDBMQUEwTCxjQUFjO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLHdDQUF3QyxxREFBcUQ7QUFDN0YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSw0Q0FBNEMscURBQXFEO0FBQ2pHLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBcUU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jaW5nLWNhbGwuanM/ZWY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2FkQmFsYW5jaW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnbG9hZF9iYWxhbmNpbmdfY2FsbCc7XG5jbGFzcyBMb2FkQmFsYW5jaW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZFN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IHRoaXMubWV0aG9kTmFtZS5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgc2VydmljZU5hbWUgPSAnJztcbiAgICAgICAgLyogVGhlIHN0YW5kYXJkIHBhdGggZm9ybWF0IGlzIFwiL3tzZXJ2aWNlTmFtZX0ve21ldGhvZE5hbWV9XCIsIHNvIGlmIHdlIHNwbGl0XG4gICAgICAgICAqIGJ5ICcvJywgdGhlIGZpcnN0IGl0ZW0gc2hvdWxkIGJlIGVtcHR5IGFuZCB0aGUgc2Vjb25kIHNob3VsZCBiZSB0aGVcbiAgICAgICAgICogc2VydmljZSBuYW1lICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHNlcnZpY2VOYW1lID0gc3BsaXRQYXRoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gKF9iID0gKF9hID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0aGlzLmhvc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2xvY2FsaG9zdCc7XG4gICAgICAgIC8qIEN1cnJlbnRseSwgY2FsbCBjcmVkZW50aWFscyBhcmUgb25seSBhbGxvd2VkIG9uIEhUVFBTIGNvbm5lY3Rpb25zLCBzbyB3ZVxuICAgICAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHNjaGVtZSBpcyBcImh0dHBzXCIgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlVXJsID0gYGh0dHBzOi8vJHtob3N0bmFtZX0vJHtzZXJ2aWNlTmFtZX1gO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lSW5mbygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZGVhZGxpbmVJbmZvID0gW107XG4gICAgICAgIGlmICh0aGlzLmNoaWxkU3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSA+IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMubWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0X2Zvcl9yZWFkeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgTEIgcGljazogJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5zdGFydFRpbWUsIHRoaXMuY2hpbGRTdGFydFRpbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goLi4udGhpcy5jaGlsZC5nZXREZWFkbGluZUluZm8oKSk7XG4gICAgICAgICAgICByZXR1cm4gZGVhZGxpbmVJbmZvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChfYiA9IHRoaXMubWV0YWRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goJ3dhaXRfZm9yX3JlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnV2FpdGluZyBmb3IgTEIgcGljaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWFkbGluZUluZm87XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMsIHByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIiBzdGFydCB0aW1lPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdGF0dXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXR1cyksIHsgcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGZpbmFsU3RhdHVzLmNvZGUsIGZpbmFsU3RhdHVzLmRldGFpbHMsIGZpbmFsU3RhdHVzLm1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1BpY2soKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvUGljayBjYWxsZWQgYmVmb3JlIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnUGljayBjYWxsZWQnKTtcbiAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgcGlja1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5kb1BpY2soZmluYWxNZXRhZGF0YSwgdGhpcy5jYWxsQ29uZmlnLnBpY2tJbmZvcm1hdGlvbik7XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdHJpbmcgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWxcbiAgICAgICAgICAgID8gJygnICtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKS5pZCArXG4gICAgICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgOiAnJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbDtcbiAgICAgICAgdGhpcy50cmFjZSgnUGljayByZXN1bHQ6ICcgK1xuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xuICAgICAgICAgICAgJyBzdWJjaGFubmVsOiAnICtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgJyBzdGF0dXM6ICcgK1xuICAgICAgICAgICAgKChfYSA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICgoX2IgPSBwaWNrUmVzdWx0LnN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldGFpbHMpKTtcbiAgICAgICAgc3dpdGNoIChwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscy5jb21wb3NlKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDYWxsQ3JlZGVudGlhbHMoKSk7XG4gICAgICAgICAgICAgICAgY29tYmluZWRDYWxsQ3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICAgICAgLmdlbmVyYXRlTWV0YWRhdGEoeyBtZXRob2RfbmFtZTogdGhpcy5tZXRob2ROYW1lLCBzZXJ2aWNlX3VybDogdGhpcy5zZXJ2aWNlVXJsIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNyZWRzTWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoaXMgY2FsbCB3YXMgY2FuY2VsbGVkIChlLmcuIGJ5IHRoZSBkZWFkbGluZSkgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAqIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAqIGl0LiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlZGVudGlhbHMgbWV0YWRhdGEgZ2VuZXJhdGlvbiBmaW5pc2hlZCBhZnRlciBjYWxsIGVuZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5tZXJnZShjcmVkc01ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsTWV0YWRhdGEuZ2V0KCdhdXRob3JpemF0aW9uJykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnXCJhdXRob3JpemF0aW9uXCIgbWV0YWRhdGEgY2Fubm90IGhhdmUgbXVsdGlwbGUgdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGFmdGVyIGdldHRpbmcgY3JlZGVudGlhbHMgbWV0YWRhdGEuIFJldHJ5aW5nIHBpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE1ldGFkYXRhLnNldCgnZ3JwYy10aW1lb3V0JywgKDAsIGRlYWRsaW5lXzEuZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBwaWNrUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YmNoYW5uZWwuZ2V0UmVhbFN1YmNoYW5uZWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVDYWxsKGZpbmFsTWV0YWRhdGEsIHRoaXMuaG9zdCwgdGhpcy5tZXRob2ROYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnJzdENvZGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUkVGVVNFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBzdGFydCBjYWxsIG9uIHBpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ0ZhaWxlZCB0byBzdGFydCBIVFRQLzIgc3RyZWFtIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnTk9UX1NUQVJURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHBpY2tSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gcGlja1Jlc3VsdC5vbkNhbGxFbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBjYWxsIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgZXJyb3IgY29kZSBpc24ndCAwIChTdGF0dXMuT0spXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKSh0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgPyBlcnJvci5jb2RlIDogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sIGBHZXR0aW5nIG1ldGFkYXRhIGZyb20gcGx1Z2luIGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuRFJPUDpcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogcGlja1Jlc3VsdC5zdGF0dXMubWV0YWRhdGEgfSwgJ0RST1AnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShwaWNrUmVzdWx0LnN0YXR1cy5jb2RlLCBwaWNrUmVzdWx0LnN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5RVUVVRTpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGU6IHN0YXR1cywgZGV0YWlsczogZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgJ1BST0NFU1NFRCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IHsgY29udGV4dCwgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEF1dGhDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTG9hZEJhbGFuY2luZ0NhbGwgPSBMb2FkQmFsYW5jaW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jaW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nexports.trace = trace;\nexports.isTracerEnabled = isTracerEnabled;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(action-browser)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams) => {\n        console.error('E ' + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams) => {\n        console.error('I ' + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams) => {\n        console.error('D ' + message, ...optionalParams);\n    },\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\nswitch (verbosityString.toUpperCase()) {\n    case 'DEBUG':\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case 'INFO':\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case 'ERROR':\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case 'NONE':\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n    // Ignore any other values\n}\nconst getLogger = () => {\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger) => {\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity) => {\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args) => {\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch (severity) {\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */\n        if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(',')) {\n    if (tracerName.startsWith('-')) {\n        disabledTracers.add(tracerName.substring(1));\n    }\n    else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has('all');\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() +\n            ' | v' +\n            clientVersion +\n            ' ' +\n            process_1.pid +\n            ' | ' +\n            tracer +\n            ' | ' +\n            text);\n    }\n}\nfunction isTracerEnabled(tracer) {\n    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));\n}\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ2hGLGFBQWE7QUFDYix1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsd0JBQVM7QUFDbkMsc0JBQXNCLHFIQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvZ2dpbmcuanM/MTVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2cgPSBleHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5nZXRMb2dnZXIgPSB2b2lkIDA7XG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGlzVHJhY2VyRW5hYmxlZDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgcHJvY2Vzc18xID0gcmVxdWlyZShcInByb2Nlc3NcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IERFRkFVTFRfTE9HR0VSID0ge1xuICAgIGVycm9yOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0kgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRCAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG59O1xubGV0IF9sb2dnZXIgPSBERUZBVUxUX0xPR0dFUjtcbmxldCBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuY29uc3QgdmVyYm9zaXR5U3RyaW5nID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2Vzcy5lbnYuR1JQQ19WRVJCT1NJVFkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuc3dpdGNoICh2ZXJib3NpdHlTdHJpbmcudG9VcHBlckNhc2UoKSkge1xuICAgIGNhc2UgJ0RFQlVHJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSU5GTyc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRVJST1InOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdOT05FJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5OT05FO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIC8vIElnbm9yZSBhbnkgb3RoZXIgdmFsdWVzXG59XG5jb25zdCBnZXRMb2dnZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9sb2dnZXI7XG59O1xuZXhwb3J0cy5nZXRMb2dnZXIgPSBnZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XG4gICAgX2xvZ2dlciA9IGxvZ2dlcjtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbmNvbnN0IHNldExvZ2dlclZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcbiAgICBfbG9nVmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gc2V0TG9nZ2VyVmVyYm9zaXR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxvZyA9IChzZXZlcml0eSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBsb2dGdW5jdGlvbjtcbiAgICBpZiAoc2V2ZXJpdHkgPj0gX2xvZ1ZlcmJvc2l0eSkge1xuICAgICAgICBzd2l0Y2ggKHNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZGVidWc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5pbmZvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIEZhbGwgYmFjayB0byBfbG9nZ2VyLmVycm9yIHdoZW4gb3RoZXIgbWV0aG9kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3JcbiAgICAgICAgICogY29tcGF0aWJsaXR5IHdpdGggb2xkZXIgYmVoYXZpb3IgdGhhdCBhbHdheXMgbG9nZ2VkIHRvIF9sb2dnZXIuZXJyb3IgKi9cbiAgICAgICAgaWYgKCFsb2dGdW5jdGlvbikge1xuICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dGdW5jdGlvbikge1xuICAgICAgICAgICAgbG9nRnVuY3Rpb24uYmluZChfbG9nZ2VyKSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmxvZyA9IGxvZztcbmNvbnN0IHRyYWNlcnNTdHJpbmcgPSAoX2QgPSAoX2MgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVFJBQ0UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHByb2Nlc3MuZW52LkdSUENfVFJBQ0UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnO1xuY29uc3QgZW5hYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5jb25zdCBkaXNhYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5mb3IgKGNvbnN0IHRyYWNlck5hbWUgb2YgdHJhY2Vyc1N0cmluZy5zcGxpdCgnLCcpKSB7XG4gICAgaWYgKHRyYWNlck5hbWUuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgIGRpc2FibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZS5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5hYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUpO1xuICAgIH1cbn1cbmNvbnN0IGFsbEVuYWJsZWQgPSBlbmFibGVkVHJhY2Vycy5oYXMoJ2FsbCcpO1xuZnVuY3Rpb24gdHJhY2Uoc2V2ZXJpdHksIHRyYWNlciwgdGV4dCkge1xuICAgIGlmIChpc1RyYWNlckVuYWJsZWQodHJhY2VyKSkge1xuICAgICAgICAoMCwgZXhwb3J0cy5sb2cpKHNldmVyaXR5LCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgJyB8IHYnICtcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb24gK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHByb2Nlc3NfMS5waWQgK1xuICAgICAgICAgICAgJyB8ICcgK1xuICAgICAgICAgICAgdHJhY2VyICtcbiAgICAgICAgICAgICcgfCAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcbiAgICByZXR1cm4gKCFkaXNhYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikgJiYgKGFsbEVuYWJsZWQgfHwgZW5hYmxlZFRyYWNlcnMuaGFzKHRyYWNlcikpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeClientConstructor = makeClientConstructor;\nexports.loadPackageDefinition = loadPackageDefinition;\nconst client_1 = __webpack_require__(/*! ./client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key) {\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach(name => {\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === 'string' && name.charAt(0) === '$') {\n            throw new Error('Method names cannot start with $');\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = 'bidi';\n            }\n            else {\n                methodType = 'client_stream';\n            }\n        }\n        else {\n            if (attrs.responseStream) {\n                methodType = 'server_stream';\n            }\n            else {\n                methodType = 'unary';\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] =\n                ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function (...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n    const result = {};\n    for (const serviceFqn in packageDef) {\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split('.');\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)) {\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            }\n            else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsbUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcz8yODVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcjtcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG4vKipcbiAqIE1hcCB3aXRoIHNob3J0IG5hbWVzIGZvciBlYWNoIG9mIHRoZSByZXF1ZXN0ZXIgbWFrZXIgZnVuY3Rpb25zLiBVc2VkIGluXG4gKiBtYWtlQ2xpZW50Q29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlcXVlc3RlckZ1bmNzID0ge1xuICAgIHVuYXJ5OiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VVbmFyeVJlcXVlc3QsXG4gICAgc2VydmVyX3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlU2VydmVyU3RyZWFtUmVxdWVzdCxcbiAgICBjbGllbnRfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0LFxuICAgIGJpZGk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUJpZGlTdHJlYW1SZXF1ZXN0LFxufTtcbi8qKlxuICogUmV0dXJucyB0cnVlLCBpZiBnaXZlbiBrZXkgaXMgaW5jbHVkZWQgaW4gdGhlIGJsYWNrbGlzdGVkXG4gKiBrZXlzLlxuICogQHBhcmFtIGtleSBrZXkgZm9yIGNoZWNrLCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluY2x1ZGVzKGtleSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdHJ1Y3RvciBmb3IgYSBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kcywgYXMgc3BlY2lmaWVkIGluXG4gKiB0aGUgbWV0aG9kcyBhcmd1bWVudC4gVGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGhhdmUgYW4gaW5zdGFuY2UgbWV0aG9kIGZvclxuICogZWFjaCBtZXRob2QgaW4gdGhlIHNlcnZpY2UsIHdoaWNoIGlzIGEgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBvbmUgb2YgdGhlXG4gKiBbQ2xpZW50XXtAbGluayBncnBjLkNsaWVudH0gcmVxdWVzdCBtZXRob2RzLCBkZXBlbmRpbmcgb24gYHJlcXVlc3RTZXJpYWxpemVgXG4gKiBhbmQgYHJlc3BvbnNlU2VyaWFsaXplYCwgd2l0aCB0aGUgYG1ldGhvZGAsIGBzZXJpYWxpemVgLCBhbmQgYGRlc2VyaWFsaXplYFxuICogYXJndW1lbnRzIHByZWRlZmluZWQuXG4gKiBAcGFyYW0gbWV0aG9kcyBBbiBvYmplY3QgbWFwcGluZyBtZXRob2QgbmFtZXMgdG9cbiAqICAgICBtZXRob2QgYXR0cmlidXRlc1xuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc2VydmljZVxuICogQHBhcmFtIGNsYXNzT3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm4gTmV3IGNsaWVudCBjb25zdHJ1Y3Rvciwgd2hpY2ggaXMgYSBzdWJjbGFzcyBvZlxuICogICAgIHtAbGluayBncnBjLkNsaWVudH0sIGFuZCBoYXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoYXQgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIG1ha2VDbGllbnRDb25zdHJ1Y3RvcihtZXRob2RzLCBzZXJ2aWNlTmFtZSwgY2xhc3NPcHRpb25zKSB7XG4gICAgaWYgKCFjbGFzc09wdGlvbnMpIHtcbiAgICAgICAgY2xhc3NPcHRpb25zID0ge307XG4gICAgfVxuICAgIGNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIGV4dGVuZHMgY2xpZW50XzEuQ2xpZW50IHtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGlzUHJvdG90eXBlUG9sbHV0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRycyA9IG1ldGhvZHNbbmFtZV07XG4gICAgICAgIGxldCBtZXRob2RUeXBlO1xuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IFZlcmlmeSB0aGF0IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggJCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2JpZGknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdjbGllbnRfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnc2VydmVyX3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemUgPSBhdHRycy5yZXF1ZXN0U2VyaWFsaXplO1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZSA9IGF0dHJzLnJlc3BvbnNlRGVzZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IG1ldGhvZEZ1bmMgPSBwYXJ0aWFsKHJlcXVlc3RlckZ1bmNzW21ldGhvZFR5cGVdLCBhdHRycy5wYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKTtcbiAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdID0gbWV0aG9kRnVuYztcbiAgICAgICAgLy8gQXNzb2NpYXRlIGFsbCBwcm92aWRlZCBhdHRyaWJ1dGVzIHdpdGggdGhlIG1ldGhvZFxuICAgICAgICBPYmplY3QuYXNzaWduKFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSwgYXR0cnMpO1xuICAgICAgICBpZiAoYXR0cnMub3JpZ2luYWxOYW1lICYmICFpc1Byb3RvdHlwZVBvbGx1dGVkKGF0dHJzLm9yaWdpbmFsTmFtZSkpIHtcbiAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVthdHRycy5vcmlnaW5hbE5hbWVdID1cbiAgICAgICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlID0gbWV0aG9kcztcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgIHJldHVybiBTZXJ2aWNlQ2xpZW50SW1wbDtcbn1cbmZ1bmN0aW9uIHBhcnRpYWwoZm4sIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKG9iaikge1xuICAgIHJldHVybiAnZm9ybWF0JyBpbiBvYmo7XG59XG4vKipcbiAqIExvYWQgYSBnUlBDIHBhY2thZ2UgZGVmaW5pdGlvbiBhcyBhIGdSUEMgb2JqZWN0IGhpZXJhcmNoeS5cbiAqIEBwYXJhbSBwYWNrYWdlRGVmIFRoZSBwYWNrYWdlIGRlZmluaXRpb24gb2JqZWN0LlxuICogQHJldHVybiBUaGUgcmVzdWx0aW5nIGdSUEMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc2VydmljZUZxbiBpbiBwYWNrYWdlRGVmKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZURlZiwgc2VydmljZUZxbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwYWNrYWdlRGVmW3NlcnZpY2VGcW5dO1xuICAgICAgICAgICAgY29uc3QgbmFtZUNvbXBvbmVudHMgPSBzZXJ2aWNlRnFuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAobmFtZUNvbXBvbmVudHMuc29tZSgoY29tcCkgPT4gaXNQcm90b3R5cGVQb2xsdXRlZChjb21wKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gbmFtZUNvbXBvbmVudHNbbmFtZUNvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgbmFtZUNvbXBvbmVudHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhY2thZ2VOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhY2thZ2VOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYWNrYWdlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKHNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBtYWtlQ2xpZW50Q29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[:0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options = {}) {\n        this.internalRepr = new Map();\n        this.opaqueData = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr) {\n            const clonedValue = value.map(v => {\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        for (const [key, values] of other.internalRepr) {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (key.startsWith(':')) {\n                continue;\n            }\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */\n    toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Attach additional data of any type to the metadata object, which will not\n     * be included when sending headers. The data can later be retrieved with\n     * `getOpaque`. Keys with the prefix `grpc` are reserved for use by this\n     * library.\n     * @param key\n     * @param value\n     */\n    setOpaque(key, value) {\n        this.opaqueData.set(key, value);\n    }\n    /**\n     * Retrieve data previously added with `setOpaque`.\n     * @param key\n     * @returns\n     */\n    getOpaque(key) {\n        return this.opaqueData.get(key);\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)) {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach(v => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val) => {\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxJQUFJLE9BQU8sSUFBSSxvQ0FBb0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ldGFkYXRhLmpzPzNhMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBMRUdBTF9LRVlfUkVHRVggPSAvXls6MC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wYXF1ZURhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IHJlcGxhY2luZyBhbnkgb3RoZXIgdmFsdWVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHdob3NlIHZhbHVlIHNob3VsZCBiZSBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IGFwcGVuZGluZyB0byBhIGxpc3Qgb2YgcHJldmlvdXNcbiAgICAgKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB3aGljaCBhIG5ldyB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4ga2V5IGFuZCBhbnkgYXNzb2NpYXRlZCB2YWx1ZXMuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiBBIGxpc3Qgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBsYWluIG9iamVjdCBtYXBwaW5nIGVhY2gga2V5IHRvIHRoZSBmaXJzdCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICogVGhpcyByZWZsZWN0cyB0aGUgbW9zdCBjb21tb24gd2F5IHRoYXQgcGVvcGxlIHdpbGwgd2FudCB0byBzZWUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybiBBIGtleS92YWx1ZSBtYXBwaW5nIG9mIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodikgPyBCdWZmZXIuZnJvbSh2KSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBtZXRhZGF0YSBvYmplY3QuXG4gICAgICogQHJldHVybiBUaGUgbmV3bHkgY2xvbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEodGhpcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmV3SW50ZXJuYWxSZXByID0gbmV3TWV0YWRhdGEuaW50ZXJuYWxSZXByO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld0ludGVybmFsUmVwci5zZXQoa2V5LCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGtleS12YWx1ZSBwYWlycyBmcm9tIGEgZ2l2ZW4gTWV0YWRhdGEgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gICAgICogSWYgYm90aCB0aGlzIG9iamVjdCBhbmQgdGhlIGdpdmVuIG9iamVjdCBoYXZlIHZhbHVlcyBpbiB0aGUgc2FtZSBrZXksXG4gICAgICogdmFsdWVzIGZyb20gdGhlIG90aGVyIE1ldGFkYXRhIG9iamVjdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgb2JqZWN0J3NcbiAgICAgKiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIG90aGVyIEEgTWV0YWRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBvdGhlci5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFZhbHVlID0gKHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpIHx8IFtdKS5jb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIG1lcmdlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPdXRnb2luZ0h0dHBIZWFkZXJzIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGh0dHAyIEFQSS5cbiAgICAgKi9cbiAgICB0b0h0dHAySGVhZGVycygpIHtcbiAgICAgICAgLy8gTk9URTogTm9kZSA8OC45IGZvcm1hdHMgaHR0cDIgaGVhZGVycyBpbmNvcnJlY3RseS5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBwdWJsaWMgQVBJIChpLmUuIGtleXMgYW5kIHZhbHVlcyBhcmUgYWxyZWFkeSB2YWxpZGF0ZWQpLlxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYWRkaXRpb25hbCBkYXRhIG9mIGFueSB0eXBlIHRvIHRoZSBtZXRhZGF0YSBvYmplY3QsIHdoaWNoIHdpbGwgbm90XG4gICAgICogYmUgaW5jbHVkZWQgd2hlbiBzZW5kaW5nIGhlYWRlcnMuIFRoZSBkYXRhIGNhbiBsYXRlciBiZSByZXRyaWV2ZWQgd2l0aFxuICAgICAqIGBnZXRPcGFxdWVgLiBLZXlzIHdpdGggdGhlIHByZWZpeCBgZ3JwY2AgYXJlIHJlc2VydmVkIGZvciB1c2UgYnkgdGhpc1xuICAgICAqIGxpYnJhcnkuXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldE9wYXF1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3BhcXVlRGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGRhdGEgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBzZXRPcGFxdWVgLlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldE9wYXF1ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BhcXVlRGF0YS5nZXQoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBNZXRhZGF0YSBvYmplY3QgYmFzZWQgZmllbGRzIGluIGEgZ2l2ZW4gSW5jb21pbmdIdHRwSGVhZGVyc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBBbiBJbmNvbWluZ0h0dHBIZWFkZXJzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNZXRhZGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZWQgaGVhZGVycyAoYmVnaW5uaW5nIHdpdGggYDpgKSBhcmUgbm90IHZhbGlkIGtleXMuXG4gICAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBoZWFkZXJzW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpdCgnLCcpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2LnRyaW0oKSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZXMsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gYWRkIG1ldGFkYXRhIGVudHJ5ICR7a2V5fTogJHt2YWx1ZXN9LiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9pc3N1ZXMvMTE3M2A7XG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5jb25zdCBidWZUb1N0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbCkgPyB2YWwudG9TdHJpbmcoJ2Jhc2U2NCcpIDogdmFsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/orca.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/orca.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2025 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OrcaOobMetricsSubchannelWrapper = exports.GRPC_METRICS_HEADER = exports.ServerMetricRecorder = exports.PerRequestMetricRecorder = void 0;\nexports.createOrcaClient = createOrcaClient;\nexports.createMetricsReader = createMetricsReader;\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst loadedOrcaProto = null;\nfunction loadOrcaProto() {\n    if (loadedOrcaProto) {\n        return loadedOrcaProto;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable ORCA. */\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync('xds/service/orca/v3/orca.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto/xds`,\n            `${__dirname}/../../proto/protoc-gen-validate`\n        ],\n    });\n    return (0, make_client_1.loadPackageDefinition)(loadedProto);\n}\n/**\n * ORCA metrics recorder for a single request\n */\nclass PerRequestMetricRecorder {\n    constructor() {\n        this.message = {};\n    }\n    /**\n     * Records a request cost metric measurement for the call.\n     * @param name\n     * @param value\n     */\n    recordRequestCostMetric(name, value) {\n        if (!this.message.request_cost) {\n            this.message.request_cost = {};\n        }\n        this.message.request_cost[name] = value;\n    }\n    /**\n     * Records a request cost metric measurement for the call.\n     * @param name\n     * @param value\n     */\n    recordUtilizationMetric(name, value) {\n        if (!this.message.utilization) {\n            this.message.utilization = {};\n        }\n        this.message.utilization[name] = value;\n    }\n    /**\n     * Records an opaque named metric measurement for the call.\n     * @param name\n     * @param value\n     */\n    recordNamedMetric(name, value) {\n        if (!this.message.named_metrics) {\n            this.message.named_metrics = {};\n        }\n        this.message.named_metrics[name] = value;\n    }\n    /**\n     * Records the CPU utilization metric measurement for the call.\n     * @param value\n     */\n    recordCPUUtilizationMetric(value) {\n        this.message.cpu_utilization = value;\n    }\n    /**\n     * Records the memory utilization metric measurement for the call.\n     * @param value\n     */\n    recordMemoryUtilizationMetric(value) {\n        this.message.mem_utilization = value;\n    }\n    /**\n     * Records the memory utilization metric measurement for the call.\n     * @param value\n     */\n    recordApplicationUtilizationMetric(value) {\n        this.message.application_utilization = value;\n    }\n    /**\n     * Records the queries per second measurement.\n     * @param value\n     */\n    recordQpsMetric(value) {\n        this.message.rps_fractional = value;\n    }\n    /**\n     * Records the errors per second measurement.\n     * @param value\n     */\n    recordEpsMetric(value) {\n        this.message.eps = value;\n    }\n    serialize() {\n        const orcaProto = loadOrcaProto();\n        return orcaProto.xds.data.orca.v3.OrcaLoadReport.serialize(this.message);\n    }\n}\nexports.PerRequestMetricRecorder = PerRequestMetricRecorder;\nconst DEFAULT_REPORT_INTERVAL_MS = 30000;\nclass ServerMetricRecorder {\n    constructor() {\n        this.message = {};\n        this.serviceImplementation = {\n            StreamCoreMetrics: call => {\n                const reportInterval = call.request.report_interval ?\n                    (0, duration_1.durationToMs)((0, duration_1.durationMessageToDuration)(call.request.report_interval)) :\n                    DEFAULT_REPORT_INTERVAL_MS;\n                const reportTimer = setInterval(() => {\n                    call.write(this.message);\n                }, reportInterval);\n                call.on('cancelled', () => {\n                    clearInterval(reportTimer);\n                });\n            }\n        };\n    }\n    putUtilizationMetric(name, value) {\n        if (!this.message.utilization) {\n            this.message.utilization = {};\n        }\n        this.message.utilization[name] = value;\n    }\n    setAllUtilizationMetrics(metrics) {\n        this.message.utilization = Object.assign({}, metrics);\n    }\n    deleteUtilizationMetric(name) {\n        var _a;\n        (_a = this.message.utilization) === null || _a === void 0 ? true : delete _a[name];\n    }\n    setCpuUtilizationMetric(value) {\n        this.message.cpu_utilization = value;\n    }\n    deleteCpuUtilizationMetric() {\n        delete this.message.cpu_utilization;\n    }\n    setApplicationUtilizationMetric(value) {\n        this.message.application_utilization = value;\n    }\n    deleteApplicationUtilizationMetric() {\n        delete this.message.application_utilization;\n    }\n    setQpsMetric(value) {\n        this.message.rps_fractional = value;\n    }\n    deleteQpsMetric() {\n        delete this.message.rps_fractional;\n    }\n    setEpsMetric(value) {\n        this.message.eps = value;\n    }\n    deleteEpsMetric() {\n        delete this.message.eps;\n    }\n    addToServer(server) {\n        const serviceDefinition = loadOrcaProto().xds.service.orca.v3.OpenRcaService.service;\n        server.addService(serviceDefinition, this.serviceImplementation);\n    }\n}\nexports.ServerMetricRecorder = ServerMetricRecorder;\nfunction createOrcaClient(channel) {\n    const ClientClass = loadOrcaProto().xds.service.orca.v3.OpenRcaService;\n    return new ClientClass('unused', channel_credentials_1.ChannelCredentials.createInsecure(), { channelOverride: channel });\n}\nexports.GRPC_METRICS_HEADER = 'endpoint-load-metrics-bin';\nconst PARSED_LOAD_REPORT_KEY = 'grpc_orca_load_report';\n/**\n * Create an onCallEnded callback for use in a picker.\n * @param listener The listener to handle metrics, whenever they are provided.\n * @param previousOnCallEnded The previous onCallEnded callback to propagate\n * to, if applicable.\n * @returns\n */\nfunction createMetricsReader(listener, previousOnCallEnded) {\n    return (code, details, metadata) => {\n        let parsedLoadReport = metadata.getOpaque(PARSED_LOAD_REPORT_KEY);\n        if (parsedLoadReport) {\n            listener(parsedLoadReport);\n        }\n        else {\n            const serializedLoadReport = metadata.get(exports.GRPC_METRICS_HEADER);\n            if (serializedLoadReport.length > 0) {\n                const orcaProto = loadOrcaProto();\n                parsedLoadReport = orcaProto.xds.data.orca.v3.OrcaLoadReport.deserialize(serializedLoadReport[0]);\n                listener(parsedLoadReport);\n                metadata.setOpaque(PARSED_LOAD_REPORT_KEY, parsedLoadReport);\n            }\n        }\n        if (previousOnCallEnded) {\n            previousOnCallEnded(code, details, metadata);\n        }\n    };\n}\nconst DATA_PRODUCER_KEY = 'orca_oob_metrics';\nclass OobMetricsDataWatcher {\n    constructor(metricsListener, intervalMs) {\n        this.metricsListener = metricsListener;\n        this.intervalMs = intervalMs;\n        this.dataProducer = null;\n    }\n    setSubchannel(subchannel) {\n        const producer = subchannel.getOrCreateDataProducer(DATA_PRODUCER_KEY, createOobMetricsDataProducer);\n        this.dataProducer = producer;\n        producer.addDataWatcher(this);\n    }\n    destroy() {\n        var _a;\n        (_a = this.dataProducer) === null || _a === void 0 ? void 0 : _a.removeDataWatcher(this);\n    }\n    getInterval() {\n        return this.intervalMs;\n    }\n    onMetricsUpdate(metrics) {\n        this.metricsListener(metrics);\n    }\n}\nclass OobMetricsDataProducer {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n        this.dataWatchers = new Set();\n        this.orcaSupported = true;\n        this.metricsCall = null;\n        this.currentInterval = Infinity;\n        this.backoffTimer = new backoff_timeout_1.BackoffTimeout(() => this.updateMetricsSubscription());\n        this.subchannelStateListener = () => this.updateMetricsSubscription();\n        const channel = subchannel.getChannel();\n        this.client = createOrcaClient(channel);\n        subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    addDataWatcher(dataWatcher) {\n        this.dataWatchers.add(dataWatcher);\n        this.updateMetricsSubscription();\n    }\n    removeDataWatcher(dataWatcher) {\n        var _a;\n        this.dataWatchers.delete(dataWatcher);\n        if (this.dataWatchers.size === 0) {\n            this.subchannel.removeDataProducer(DATA_PRODUCER_KEY);\n            (_a = this.metricsCall) === null || _a === void 0 ? void 0 : _a.cancel();\n            this.metricsCall = null;\n            this.client.close();\n            this.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n        }\n        else {\n            this.updateMetricsSubscription();\n        }\n    }\n    updateMetricsSubscription() {\n        var _a;\n        if (this.dataWatchers.size === 0 || !this.orcaSupported || this.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            return;\n        }\n        const newInterval = Math.min(...Array.from(this.dataWatchers).map(watcher => watcher.getInterval()));\n        if (!this.metricsCall || newInterval !== this.currentInterval) {\n            (_a = this.metricsCall) === null || _a === void 0 ? void 0 : _a.cancel();\n            this.currentInterval = newInterval;\n            const metricsCall = this.client.streamCoreMetrics({ report_interval: (0, duration_1.msToDuration)(newInterval) });\n            this.metricsCall = metricsCall;\n            metricsCall.on('data', (report) => {\n                this.dataWatchers.forEach(watcher => {\n                    watcher.onMetricsUpdate(report);\n                });\n            });\n            metricsCall.on('error', (error) => {\n                this.metricsCall = null;\n                if (error.code === constants_1.Status.UNIMPLEMENTED) {\n                    this.orcaSupported = false;\n                    return;\n                }\n                if (error.code === constants_1.Status.CANCELLED) {\n                    return;\n                }\n                this.backoffTimer.runOnce();\n            });\n        }\n    }\n}\nclass OrcaOobMetricsSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(child, metricsListener, intervalMs) {\n        super(child);\n        this.addDataWatcher(new OobMetricsDataWatcher(metricsListener, intervalMs));\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nexports.OrcaOobMetricsSubchannelWrapper = OrcaOobMetricsSubchannelWrapper;\nfunction createOobMetricsDataProducer(subchannel) {\n    return new OobMetricsDataProducer(subchannel);\n}\n//# sourceMappingURL=orca.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9vcmNhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsZ0NBQWdDO0FBQ3ZJLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsNkdBQXVCO0FBQzdELCtCQUErQixtQkFBTyxDQUFDLCtHQUF3QjtBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBbUI7QUFDckQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRKQUNWO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGtHQUFrRywwQkFBMEI7QUFDNUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNERBQTREO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvb3JjYS5qcz8wNjNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI1IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9yY2FPb2JNZXRyaWNzU3ViY2hhbm5lbFdyYXBwZXIgPSBleHBvcnRzLkdSUENfTUVUUklDU19IRUFERVIgPSBleHBvcnRzLlNlcnZlck1ldHJpY1JlY29yZGVyID0gZXhwb3J0cy5QZXJSZXF1ZXN0TWV0cmljUmVjb3JkZXIgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZU9yY2FDbGllbnQgPSBjcmVhdGVPcmNhQ2xpZW50O1xuZXhwb3J0cy5jcmVhdGVNZXRyaWNzUmVhZGVyID0gY3JlYXRlTWV0cmljc1JlYWRlcjtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBsb2FkZWRPcmNhUHJvdG8gPSBudWxsO1xuZnVuY3Rpb24gbG9hZE9yY2FQcm90bygpIHtcbiAgICBpZiAobG9hZGVkT3JjYVByb3RvKSB7XG4gICAgICAgIHJldHVybiBsb2FkZWRPcmNhUHJvdG87XG4gICAgfVxuICAgIC8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgY29tcGxleGl0eSBpcyB0byBhdm9pZCBsb2FkaW5nIEBncnBjL3Byb3RvLWxvYWRlciBhdFxuICAgICAqIHJ1bnRpbWUgZm9yIHVzZXJzIHdobyB3aWxsIG5vdCB1c2UvZW5hYmxlIE9SQ0EuICovXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKVxuICAgICAgICAubG9hZFN5bmM7XG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygneGRzL3NlcnZpY2Uvb3JjYS92My9vcmNhLnByb3RvJywge1xuICAgICAgICBrZWVwQ2FzZTogdHJ1ZSxcbiAgICAgICAgbG9uZ3M6IFN0cmluZyxcbiAgICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdHM6IHRydWUsXG4gICAgICAgIG9uZW9mczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZURpcnM6IFtcbiAgICAgICAgICAgIGAke19fZGlybmFtZX0vLi4vLi4vcHJvdG8veGRzYCxcbiAgICAgICAgICAgIGAke19fZGlybmFtZX0vLi4vLi4vcHJvdG8vcHJvdG9jLWdlbi12YWxpZGF0ZWBcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uKShsb2FkZWRQcm90byk7XG59XG4vKipcbiAqIE9SQ0EgbWV0cmljcyByZWNvcmRlciBmb3IgYSBzaW5nbGUgcmVxdWVzdFxuICovXG5jbGFzcyBQZXJSZXF1ZXN0TWV0cmljUmVjb3JkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhIHJlcXVlc3QgY29zdCBtZXRyaWMgbWVhc3VyZW1lbnQgZm9yIHRoZSBjYWxsLlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcmVjb3JkUmVxdWVzdENvc3RNZXRyaWMobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UucmVxdWVzdF9jb3N0KSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UucmVxdWVzdF9jb3N0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlLnJlcXVlc3RfY29zdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIGEgcmVxdWVzdCBjb3N0IG1ldHJpYyBtZWFzdXJlbWVudCBmb3IgdGhlIGNhbGwuXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICByZWNvcmRVdGlsaXphdGlvbk1ldHJpYyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZS51dGlsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlLnV0aWxpemF0aW9uID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlLnV0aWxpemF0aW9uW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZHMgYW4gb3BhcXVlIG5hbWVkIG1ldHJpYyBtZWFzdXJlbWVudCBmb3IgdGhlIGNhbGwuXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICByZWNvcmROYW1lZE1ldHJpYyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZS5uYW1lZF9tZXRyaWNzKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UubmFtZWRfbWV0cmljcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZS5uYW1lZF9tZXRyaWNzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZHMgdGhlIENQVSB1dGlsaXphdGlvbiBtZXRyaWMgbWVhc3VyZW1lbnQgZm9yIHRoZSBjYWxsLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHJlY29yZENQVVV0aWxpemF0aW9uTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5jcHVfdXRpbGl6YXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyB0aGUgbWVtb3J5IHV0aWxpemF0aW9uIG1ldHJpYyBtZWFzdXJlbWVudCBmb3IgdGhlIGNhbGwuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcmVjb3JkTWVtb3J5VXRpbGl6YXRpb25NZXRyaWModmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLm1lbV91dGlsaXphdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIHRoZSBtZW1vcnkgdXRpbGl6YXRpb24gbWV0cmljIG1lYXN1cmVtZW50IGZvciB0aGUgY2FsbC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICByZWNvcmRBcHBsaWNhdGlvblV0aWxpemF0aW9uTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5hcHBsaWNhdGlvbl91dGlsaXphdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIHRoZSBxdWVyaWVzIHBlciBzZWNvbmQgbWVhc3VyZW1lbnQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcmVjb3JkUXBzTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5ycHNfZnJhY3Rpb25hbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIHRoZSBlcnJvcnMgcGVyIHNlY29uZCBtZWFzdXJlbWVudC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICByZWNvcmRFcHNNZXRyaWModmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLmVwcyA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IG9yY2FQcm90byA9IGxvYWRPcmNhUHJvdG8oKTtcbiAgICAgICAgcmV0dXJuIG9yY2FQcm90by54ZHMuZGF0YS5vcmNhLnYzLk9yY2FMb2FkUmVwb3J0LnNlcmlhbGl6ZSh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVyUmVxdWVzdE1ldHJpY1JlY29yZGVyID0gUGVyUmVxdWVzdE1ldHJpY1JlY29yZGVyO1xuY29uc3QgREVGQVVMVF9SRVBPUlRfSU5URVJWQUxfTVMgPSAzMDAwMDtcbmNsYXNzIFNlcnZlck1ldHJpY1JlY29yZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0ge307XG4gICAgICAgIHRoaXMuc2VydmljZUltcGxlbWVudGF0aW9uID0ge1xuICAgICAgICAgICAgU3RyZWFtQ29yZU1ldHJpY3M6IGNhbGwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydEludGVydmFsID0gY2FsbC5yZXF1ZXN0LnJlcG9ydF9pbnRlcnZhbCA/XG4gICAgICAgICAgICAgICAgICAgICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9NcykoKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25NZXNzYWdlVG9EdXJhdGlvbikoY2FsbC5yZXF1ZXN0LnJlcG9ydF9pbnRlcnZhbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9SRVBPUlRfSU5URVJWQUxfTVM7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0VGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwud3JpdGUodGhpcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LCByZXBvcnRJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgY2FsbC5vbignY2FuY2VsbGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHJlcG9ydFRpbWVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHV0VXRpbGl6YXRpb25NZXRyaWMobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UudXRpbGl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZS51dGlsaXphdGlvbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZS51dGlsaXphdGlvbltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRBbGxVdGlsaXphdGlvbk1ldHJpY3MobWV0cmljcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UudXRpbGl6YXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBtZXRyaWNzKTtcbiAgICB9XG4gICAgZGVsZXRlVXRpbGl6YXRpb25NZXRyaWMobmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMubWVzc2FnZS51dGlsaXphdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2FbbmFtZV07XG4gICAgfVxuICAgIHNldENwdVV0aWxpemF0aW9uTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5jcHVfdXRpbGl6YXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgZGVsZXRlQ3B1VXRpbGl6YXRpb25NZXRyaWMoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1lc3NhZ2UuY3B1X3V0aWxpemF0aW9uO1xuICAgIH1cbiAgICBzZXRBcHBsaWNhdGlvblV0aWxpemF0aW9uTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5hcHBsaWNhdGlvbl91dGlsaXphdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBkZWxldGVBcHBsaWNhdGlvblV0aWxpemF0aW9uTWV0cmljKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tZXNzYWdlLmFwcGxpY2F0aW9uX3V0aWxpemF0aW9uO1xuICAgIH1cbiAgICBzZXRRcHNNZXRyaWModmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLnJwc19mcmFjdGlvbmFsID0gdmFsdWU7XG4gICAgfVxuICAgIGRlbGV0ZVFwc01ldHJpYygpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubWVzc2FnZS5ycHNfZnJhY3Rpb25hbDtcbiAgICB9XG4gICAgc2V0RXBzTWV0cmljKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5lcHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZGVsZXRlRXBzTWV0cmljKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tZXNzYWdlLmVwcztcbiAgICB9XG4gICAgYWRkVG9TZXJ2ZXIoc2VydmVyKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VEZWZpbml0aW9uID0gbG9hZE9yY2FQcm90bygpLnhkcy5zZXJ2aWNlLm9yY2EudjMuT3BlblJjYVNlcnZpY2Uuc2VydmljZTtcbiAgICAgICAgc2VydmVyLmFkZFNlcnZpY2Uoc2VydmljZURlZmluaXRpb24sIHRoaXMuc2VydmljZUltcGxlbWVudGF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlck1ldHJpY1JlY29yZGVyID0gU2VydmVyTWV0cmljUmVjb3JkZXI7XG5mdW5jdGlvbiBjcmVhdGVPcmNhQ2xpZW50KGNoYW5uZWwpIHtcbiAgICBjb25zdCBDbGllbnRDbGFzcyA9IGxvYWRPcmNhUHJvdG8oKS54ZHMuc2VydmljZS5vcmNhLnYzLk9wZW5SY2FTZXJ2aWNlO1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q2xhc3MoJ3VudXNlZCcsIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUoKSwgeyBjaGFubmVsT3ZlcnJpZGU6IGNoYW5uZWwgfSk7XG59XG5leHBvcnRzLkdSUENfTUVUUklDU19IRUFERVIgPSAnZW5kcG9pbnQtbG9hZC1tZXRyaWNzLWJpbic7XG5jb25zdCBQQVJTRURfTE9BRF9SRVBPUlRfS0VZID0gJ2dycGNfb3JjYV9sb2FkX3JlcG9ydCc7XG4vKipcbiAqIENyZWF0ZSBhbiBvbkNhbGxFbmRlZCBjYWxsYmFjayBmb3IgdXNlIGluIGEgcGlja2VyLlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBoYW5kbGUgbWV0cmljcywgd2hlbmV2ZXIgdGhleSBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gcHJldmlvdXNPbkNhbGxFbmRlZCBUaGUgcHJldmlvdXMgb25DYWxsRW5kZWQgY2FsbGJhY2sgdG8gcHJvcGFnYXRlXG4gKiB0bywgaWYgYXBwbGljYWJsZS5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1ldHJpY3NSZWFkZXIobGlzdGVuZXIsIHByZXZpb3VzT25DYWxsRW5kZWQpIHtcbiAgICByZXR1cm4gKGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWRMb2FkUmVwb3J0ID0gbWV0YWRhdGEuZ2V0T3BhcXVlKFBBUlNFRF9MT0FEX1JFUE9SVF9LRVkpO1xuICAgICAgICBpZiAocGFyc2VkTG9hZFJlcG9ydCkge1xuICAgICAgICAgICAgbGlzdGVuZXIocGFyc2VkTG9hZFJlcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTG9hZFJlcG9ydCA9IG1ldGFkYXRhLmdldChleHBvcnRzLkdSUENfTUVUUklDU19IRUFERVIpO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRMb2FkUmVwb3J0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmNhUHJvdG8gPSBsb2FkT3JjYVByb3RvKCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkTG9hZFJlcG9ydCA9IG9yY2FQcm90by54ZHMuZGF0YS5vcmNhLnYzLk9yY2FMb2FkUmVwb3J0LmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRMb2FkUmVwb3J0WzBdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihwYXJzZWRMb2FkUmVwb3J0KTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5zZXRPcGFxdWUoUEFSU0VEX0xPQURfUkVQT1JUX0tFWSwgcGFyc2VkTG9hZFJlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzT25DYWxsRW5kZWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzT25DYWxsRW5kZWQoY29kZSwgZGV0YWlscywgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IERBVEFfUFJPRFVDRVJfS0VZID0gJ29yY2Ffb29iX21ldHJpY3MnO1xuY2xhc3MgT29iTWV0cmljc0RhdGFXYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRyaWNzTGlzdGVuZXIsIGludGVydmFsTXMpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzTGlzdGVuZXIgPSBtZXRyaWNzTGlzdGVuZXI7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNcyA9IGludGVydmFsTXM7XG4gICAgICAgIHRoaXMuZGF0YVByb2R1Y2VyID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y2VyID0gc3ViY2hhbm5lbC5nZXRPckNyZWF0ZURhdGFQcm9kdWNlcihEQVRBX1BST0RVQ0VSX0tFWSwgY3JlYXRlT29iTWV0cmljc0RhdGFQcm9kdWNlcik7XG4gICAgICAgIHRoaXMuZGF0YVByb2R1Y2VyID0gcHJvZHVjZXI7XG4gICAgICAgIHByb2R1Y2VyLmFkZERhdGFXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuZGF0YVByb2R1Y2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRGF0YVdhdGNoZXIodGhpcyk7XG4gICAgfVxuICAgIGdldEludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbE1zO1xuICAgIH1cbiAgICBvbk1ldHJpY3NVcGRhdGUobWV0cmljcykge1xuICAgICAgICB0aGlzLm1ldHJpY3NMaXN0ZW5lcihtZXRyaWNzKTtcbiAgICB9XG59XG5jbGFzcyBPb2JNZXRyaWNzRGF0YVByb2R1Y2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgICAgIHRoaXMuZGF0YVdhdGNoZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm9yY2FTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1ldHJpY3NDYWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW50ZXJ2YWwgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXIgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVNZXRyaWNzU3Vic2NyaXB0aW9uKCkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKCkgPT4gdGhpcy51cGRhdGVNZXRyaWNzU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBzdWJjaGFubmVsLmdldENoYW5uZWwoKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjcmVhdGVPcmNhQ2xpZW50KGNoYW5uZWwpO1xuICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgfVxuICAgIGFkZERhdGFXYXRjaGVyKGRhdGFXYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YVdhdGNoZXJzLmFkZChkYXRhV2F0Y2hlcik7XG4gICAgICAgIHRoaXMudXBkYXRlTWV0cmljc1N1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICByZW1vdmVEYXRhV2F0Y2hlcihkYXRhV2F0Y2hlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZGF0YVdhdGNoZXJzLmRlbGV0ZShkYXRhV2F0Y2hlcik7XG4gICAgICAgIGlmICh0aGlzLmRhdGFXYXRjaGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWwucmVtb3ZlRGF0YVByb2R1Y2VyKERBVEFfUFJPRFVDRVJfS0VZKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubWV0cmljc0NhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMubWV0cmljc0NhbGwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNZXRyaWNzU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTWV0cmljc1N1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5kYXRhV2F0Y2hlcnMuc2l6ZSA9PT0gMCB8fCAhdGhpcy5vcmNhU3VwcG9ydGVkIHx8IHRoaXMuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ludGVydmFsID0gTWF0aC5taW4oLi4uQXJyYXkuZnJvbSh0aGlzLmRhdGFXYXRjaGVycykubWFwKHdhdGNoZXIgPT4gd2F0Y2hlci5nZXRJbnRlcnZhbCgpKSk7XG4gICAgICAgIGlmICghdGhpcy5tZXRyaWNzQ2FsbCB8fCBuZXdJbnRlcnZhbCAhPT0gdGhpcy5jdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubWV0cmljc0NhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEludGVydmFsID0gbmV3SW50ZXJ2YWw7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzQ2FsbCA9IHRoaXMuY2xpZW50LnN0cmVhbUNvcmVNZXRyaWNzKHsgcmVwb3J0X2ludGVydmFsOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKG5ld0ludGVydmFsKSB9KTtcbiAgICAgICAgICAgIHRoaXMubWV0cmljc0NhbGwgPSBtZXRyaWNzQ2FsbDtcbiAgICAgICAgICAgIG1ldHJpY3NDYWxsLm9uKCdkYXRhJywgKHJlcG9ydCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVdhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIub25NZXRyaWNzVXBkYXRlKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1ldHJpY3NDYWxsLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0cmljc0NhbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yY2FTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZlRpbWVyLnJ1bk9uY2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3JjYU9vYk1ldHJpY3NTdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCwgbWV0cmljc0xpc3RlbmVyLCBpbnRlcnZhbE1zKSB7XG4gICAgICAgIHN1cGVyKGNoaWxkKTtcbiAgICAgICAgdGhpcy5hZGREYXRhV2F0Y2hlcihuZXcgT29iTWV0cmljc0RhdGFXYXRjaGVyKG1ldHJpY3NMaXN0ZW5lciwgaW50ZXJ2YWxNcykpO1xuICAgIH1cbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgfVxufVxuZXhwb3J0cy5PcmNhT29iTWV0cmljc1N1YmNoYW5uZWxXcmFwcGVyID0gT3JjYU9vYk1ldHJpY3NTdWJjaGFubmVsV3JhcHBlcjtcbmZ1bmN0aW9uIGNyZWF0ZU9vYk1ldHJpY3NEYXRhUHJvZHVjZXIoc3ViY2hhbm5lbCkge1xuICAgIHJldHVybiBuZXcgT29iTWV0cmljc0RhdGFQcm9kdWNlcihzdWJjaGFubmVsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yY2EuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/orca.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function (PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nclass UnavailablePicker {\n    constructor(status) {\n        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n * If the childPicker is provided, delegate to it instead of returning the\n * hardcoded QUEUE pick result, but still calls exitIdle.\n */\nclass QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer, childPicker) {\n        this.loadBalancer = loadBalancer;\n        this.childPicker = childPicker;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(() => {\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        if (this.childPicker) {\n            return this.childPicker.pick(pickArgs);\n        }\n        else {\n            return {\n                pickResultType: PickResultType.QUEUE,\n                subchannel: null,\n                status: null,\n                onCallStarted: null,\n                onCallEnded: null,\n            };\n        }\n    }\n}\nexports.QueuePicker = QueuePicker;\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9waWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDeEUsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsc0JBQXNCLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUhBQWlIO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9waWNrZXIuanM/ZTQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IGV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBleHBvcnRzLlBpY2tSZXN1bHRUeXBlID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgUGlja1Jlc3VsdFR5cGU7XG4oZnVuY3Rpb24gKFBpY2tSZXN1bHRUeXBlKSB7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJDT01QTEVURVwiXSA9IDBdID0gXCJDT01QTEVURVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiUVVFVUVcIl0gPSAxXSA9IFwiUVVFVUVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gMl0gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJEUk9QXCJdID0gM10gPSBcIkRST1BcIjtcbn0pKFBpY2tSZXN1bHRUeXBlIHx8IChleHBvcnRzLlBpY2tSZXN1bHRUeXBlID0gUGlja1Jlc3VsdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBUUkFOU0lFTlRfRkFJTFVSRVxuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhbiBVTkFWQUlMQUJMRSBzdGF0dXMuXG4gKi9cbmNsYXNzIFVuYXZhaWxhYmxlUGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBPYmplY3QuYXNzaWduKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCBkZXRhaWxzOiAnTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sIHN0YXR1cyk7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5UUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBVbmF2YWlsYWJsZVBpY2tlcjtcbi8qKlxuICogQSBzdGFuZGFyZCBwaWNrZXIgcmVwcmVzZW50aW5nIGEgbG9hZCBiYWxhbmNlciBpbiB0aGUgSURMRSBvciBDT05ORUNUSU5HXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGEgUVVFVUUgcGljayByZXN1bHRcbiAqIGluZGljYXRpbmcgdGhhdCB0aGUgcGljayBzaG91bGQgYmUgdHJpZWQgYWdhaW4gd2l0aCB0aGUgbmV4dCBgUGlja2VyYC4gQWxzb1xuICogcmVwb3J0cyBiYWNrIHRvIHRoZSBsb2FkIGJhbGFuY2VyIHRoYXQgYSBjb25uZWN0aW9uIHNob3VsZCBiZSBlc3RhYmxpc2hlZFxuICogb25jZSBhbnkgcGljayBpcyBhdHRlbXB0ZWQuXG4gKiBJZiB0aGUgY2hpbGRQaWNrZXIgaXMgcHJvdmlkZWQsIGRlbGVnYXRlIHRvIGl0IGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZVxuICogaGFyZGNvZGVkIFFVRVVFIHBpY2sgcmVzdWx0LCBidXQgc3RpbGwgY2FsbHMgZXhpdElkbGUuXG4gKi9cbmNsYXNzIFF1ZXVlUGlja2VyIHtcbiAgICAvLyBDb25zdHJ1Y3RlZCB3aXRoIGEgbG9hZCBiYWxhbmNlci4gQ2FsbHMgZXhpdElkbGUgb24gaXQgdGhlIGZpcnN0IHRpbWUgcGljayBpcyBjYWxsZWRcbiAgICBjb25zdHJ1Y3Rvcihsb2FkQmFsYW5jZXIsIGNoaWxkUGlja2VyKSB7XG4gICAgICAgIHRoaXMubG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2VyO1xuICAgICAgICB0aGlzLmNoaWxkUGlja2VyID0gY2hpbGRQaWNrZXI7XG4gICAgICAgIHRoaXMuY2FsbGVkRXhpdElkbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGVkRXhpdElkbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVkRXhpdElkbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkUGlja2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlFVRVVFLFxuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/priority-queue.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/priority-queue.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2025 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PriorityQueue = void 0;\nconst top = 0;\nconst parent = (i) => Math.floor(i / 2);\nconst left = (i) => i * 2 + 1;\nconst right = (i) => i * 2 + 2;\n/**\n * A generic priority queue implemented as an array-based binary heap.\n * Adapted from https://stackoverflow.com/a/42919752/159388\n */\nclass PriorityQueue {\n    /**\n     *\n     * @param comparator Returns true if the first argument should precede the\n     *   second in the queue. Defaults to `(a, b) => a > b`\n     */\n    constructor(comparator = (a, b) => a > b) {\n        this.comparator = comparator;\n        this.heap = [];\n    }\n    /**\n     * @returns The number of items currently in the queue\n     */\n    size() {\n        return this.heap.length;\n    }\n    /**\n     * @returns True if there are no items in the queue, false otherwise\n     */\n    isEmpty() {\n        return this.size() == 0;\n    }\n    /**\n     * Look at the front item that would be popped, without modifying the contents\n     * of the queue\n     * @returns The front item in the queue, or undefined if the queue is empty\n     */\n    peek() {\n        return this.heap[top];\n    }\n    /**\n     * Add the items to the queue\n     * @param values The items to add\n     * @returns The new size of the queue after adding the items\n     */\n    push(...values) {\n        values.forEach(value => {\n            this.heap.push(value);\n            this.siftUp();\n        });\n        return this.size();\n    }\n    /**\n     * Remove the front item in the queue and return it\n     * @returns The front item in the queue, or undefined if the queue is empty\n     */\n    pop() {\n        const poppedValue = this.peek();\n        const bottom = this.size() - 1;\n        if (bottom > top) {\n            this.swap(top, bottom);\n        }\n        this.heap.pop();\n        this.siftDown();\n        return poppedValue;\n    }\n    /**\n     * Simultaneously remove the front item in the queue and add the provided\n     * item.\n     * @param value The item to add\n     * @returns The front item in the queue, or undefined if the queue is empty\n     */\n    replace(value) {\n        const replacedValue = this.peek();\n        this.heap[top] = value;\n        this.siftDown();\n        return replacedValue;\n    }\n    greater(i, j) {\n        return this.comparator(this.heap[i], this.heap[j]);\n    }\n    swap(i, j) {\n        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    }\n    siftUp() {\n        let node = this.size() - 1;\n        while (node > top && this.greater(node, parent(node))) {\n            this.swap(node, parent(node));\n            node = parent(node);\n        }\n    }\n    siftDown() {\n        let node = top;\n        while ((left(node) < this.size() && this.greater(left(node), node)) ||\n            (right(node) < this.size() && this.greater(right(node), node))) {\n            let maxChild = (right(node) < this.size() && this.greater(right(node), left(node))) ? right(node) : left(node);\n            this.swap(node, maxChild);\n            node = maxChild;\n        }\n    }\n}\nexports.PriorityQueue = PriorityQueue;\n//# sourceMappingURL=priority-queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9wcmlvcml0eS1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9wcmlvcml0eS1xdWV1ZS5qcz8yOTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI1IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaW9yaXR5UXVldWUgPSB2b2lkIDA7XG5jb25zdCB0b3AgPSAwO1xuY29uc3QgcGFyZW50ID0gKGkpID0+IE1hdGguZmxvb3IoaSAvIDIpO1xuY29uc3QgbGVmdCA9IChpKSA9PiBpICogMiArIDE7XG5jb25zdCByaWdodCA9IChpKSA9PiBpICogMiArIDI7XG4vKipcbiAqIEEgZ2VuZXJpYyBwcmlvcml0eSBxdWV1ZSBpbXBsZW1lbnRlZCBhcyBhbiBhcnJheS1iYXNlZCBiaW5hcnkgaGVhcC5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDI5MTk3NTIvMTU5Mzg4XG4gKi9cbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBzaG91bGQgcHJlY2VkZSB0aGVcbiAgICAgKiAgIHNlY29uZCBpbiB0aGUgcXVldWUuIERlZmF1bHRzIHRvIGAoYSwgYikgPT4gYSA+IGJgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID4gYikge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlcmUgYXJlIG5vIGl0ZW1zIGluIHRoZSBxdWV1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpID09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2sgYXQgdGhlIGZyb250IGl0ZW0gdGhhdCB3b3VsZCBiZSBwb3BwZWQsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjb250ZW50c1xuICAgICAqIG9mIHRoZSBxdWV1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBmcm9udCBpdGVtIGluIHRoZSBxdWV1ZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxuICAgICAqL1xuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXBbdG9wXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBpdGVtcyB0byB0aGUgcXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSBpdGVtcyB0byBhZGRcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHNpemUgb2YgdGhlIHF1ZXVlIGFmdGVyIGFkZGluZyB0aGUgaXRlbXNcbiAgICAgKi9cbiAgICBwdXNoKC4uLnZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlYXAucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNpZnRVcCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZyb250IGl0ZW0gaW4gdGhlIHF1ZXVlIGFuZCByZXR1cm4gaXRcbiAgICAgKiBAcmV0dXJucyBUaGUgZnJvbnQgaXRlbSBpbiB0aGUgcXVldWUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgcXVldWUgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHBvcHBlZFZhbHVlID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuc2l6ZSgpIC0gMTtcbiAgICAgICAgaWYgKGJvdHRvbSA+IHRvcCkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKHRvcCwgYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIHRoaXMuc2lmdERvd24oKTtcbiAgICAgICAgcmV0dXJuIHBvcHBlZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW11bHRhbmVvdXNseSByZW1vdmUgdGhlIGZyb250IGl0ZW0gaW4gdGhlIHF1ZXVlIGFuZCBhZGQgdGhlIHByb3ZpZGVkXG4gICAgICogaXRlbS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYWRkXG4gICAgICogQHJldHVybnMgVGhlIGZyb250IGl0ZW0gaW4gdGhlIHF1ZXVlLCBvciB1bmRlZmluZWQgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgICovXG4gICAgcmVwbGFjZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXBsYWNlZFZhbHVlID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHRoaXMuaGVhcFt0b3BdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2lmdERvd24oKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VkVmFsdWU7XG4gICAgfVxuICAgIGdyZWF0ZXIoaSwgaikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFtpXSwgdGhpcy5oZWFwW2pdKTtcbiAgICB9XG4gICAgc3dhcChpLCBqKSB7XG4gICAgICAgIFt0aGlzLmhlYXBbaV0sIHRoaXMuaGVhcFtqXV0gPSBbdGhpcy5oZWFwW2pdLCB0aGlzLmhlYXBbaV1dO1xuICAgIH1cbiAgICBzaWZ0VXAoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5zaXplKCkgLSAxO1xuICAgICAgICB3aGlsZSAobm9kZSA+IHRvcCAmJiB0aGlzLmdyZWF0ZXIobm9kZSwgcGFyZW50KG5vZGUpKSkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKG5vZGUsIHBhcmVudChub2RlKSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpZnREb3duKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRvcDtcbiAgICAgICAgd2hpbGUgKChsZWZ0KG5vZGUpIDwgdGhpcy5zaXplKCkgJiYgdGhpcy5ncmVhdGVyKGxlZnQobm9kZSksIG5vZGUpKSB8fFxuICAgICAgICAgICAgKHJpZ2h0KG5vZGUpIDwgdGhpcy5zaXplKCkgJiYgdGhpcy5ncmVhdGVyKHJpZ2h0KG5vZGUpLCBub2RlKSkpIHtcbiAgICAgICAgICAgIGxldCBtYXhDaGlsZCA9IChyaWdodChub2RlKSA8IHRoaXMuc2l6ZSgpICYmIHRoaXMuZ3JlYXRlcihyaWdodChub2RlKSwgbGVmdChub2RlKSkpID8gcmlnaHQobm9kZSkgOiBsZWZ0KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zd2FwKG5vZGUsIG1heENoaWxkKTtcbiAgICAgICAgICAgIG5vZGUgPSBtYXhDaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJpb3JpdHlRdWV1ZSA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmlvcml0eS1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/priority-queue.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_PORT = void 0;\nexports.setup = setup;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst environment_1 = __webpack_require__(/*! ./environment */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/environment.js\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfigResult = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        this.alternativeResolver = new dns_1.promises.Resolver();\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        if (target.authority) {\n            this.alternativeResolver.setServers([target.authority]);\n        }\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        addresses: [\n                            {\n                                host: hostPort.host,\n                                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,\n                            },\n                        ],\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs =\n            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(() => {\n                    this.listener((0, call_interface_1.statusOrFromValue)(this.ipResult), {}, null, '');\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(() => {\n                this.listener((0, call_interface_1.statusOrFromError)({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`\n                }), {}, null, '');\n            });\n            this.stopNextResolutionTimer();\n        }\n        else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace('Looking up DNS hostname ' + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            this.pendingLookupPromise = this.lookup(hostname);\n            this.pendingLookupPromise.then(addressList => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.latestLookupResult = (0, call_interface_1.statusOrFromValue)(addressList.map(address => ({\n                    addresses: [address],\n                })));\n                const allAddressesString = '[' +\n                    addressList.map(addr => addr.host + ':' + addr.port).join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    allAddressesString);\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                const healthStatus = this.listener(this.latestLookupResult, {}, this.latestServiceConfigResult, '');\n                this.handleHealthStatus(healthStatus);\n            }, err => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace('Resolution error for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener((0, call_interface_1.statusOrFromError)(this.defaultResolutionError), {}, this.latestServiceConfigResult, '');\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = this.resolveTxt(hostname);\n                this.pendingTxtPromise.then(txtRecord => {\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    let serviceConfig;\n                    try {\n                        serviceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                        if (serviceConfig) {\n                            this.latestServiceConfigResult = (0, call_interface_1.statusOrFromValue)(serviceConfig);\n                        }\n                        else {\n                            this.latestServiceConfigResult = null;\n                        }\n                    }\n                    catch (err) {\n                        this.latestServiceConfigResult = (0, call_interface_1.statusOrFromError)({\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`\n                        });\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener(this.latestLookupResult, {}, this.latestServiceConfigResult, '');\n                    }\n                }, err => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    /**\n     * The ResolverListener returns a boolean indicating whether the LB policy\n     * accepted the resolution result. A false result on an otherwise successful\n     * resolution should be treated as a resolution failure.\n     * @param healthStatus\n     */\n    handleHealthStatus(healthStatus) {\n        if (healthStatus) {\n            this.backoff.stop();\n            this.backoff.reset();\n        }\n        else {\n            this.continueResolving = true;\n        }\n    }\n    async lookup(hostname) {\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n            trace('Using alternative DNS resolver.');\n            const records = await Promise.allSettled([\n                this.alternativeResolver.resolve4(hostname),\n                this.alternativeResolver.resolve6(hostname),\n            ]);\n            if (records.every(result => result.status === 'rejected')) {\n                throw new Error(records[0].reason);\n            }\n            return records\n                .reduce((acc, result) => {\n                return result.status === 'fulfilled'\n                    ? [...acc, ...result.value]\n                    : acc;\n            }, [])\n                .map(addr => ({\n                host: addr,\n                port: +this.port,\n            }));\n        }\n        /* We lookup both address families here and then split them up later\n         * because when looking up a single family, dns.lookup outputs an error\n         * if the name exists but there are no records for that family, and that\n         * error is indistinguishable from other kinds of errors */\n        const addressList = await dns_1.promises.lookup(hostname, { all: true });\n        return addressList.map(addr => ({ host: addr.address, port: +this.port }));\n    }\n    async resolveTxt(hostname) {\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n            trace('Using alternative DNS resolver.');\n            return this.alternativeResolver.resolveTxt(hostname);\n        }\n        return dns_1.promises.resolveTxt(hostname);\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = setTimeout(() => {\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs);\n        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */\n        if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                }\n                else {\n                    trace('resolution update delayed by backoff timer until ' +\n                        this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            }\n            else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfigResult = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    (0, resolver_1.registerResolver)('dns', DnsResolver);\n    (0, resolver_1.registerDefaultScheme)('dns');\n}\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1kbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsbUdBQWtCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMscUdBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQ0FBMkM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQ0FBMkM7QUFDdkcsaUJBQWlCLEtBQUs7QUFDdEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0YseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRSwwQ0FBMEMsc0NBQXNDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcz9lYWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gdm9pZCAwO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgZG5zXzEgPSByZXF1aXJlKFwiZG5zXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnZG5zX3Jlc29sdmVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5leHBvcnRzLkRFRkFVTFRfUE9SVCA9IDQ0MztcbmNvbnN0IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyA9IDMwMDAwO1xuLyoqXG4gKiBSZXNvbHZlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhbmRsZXMgRE5TIG5hbWVzIGFuZCBJUCBhZGRyZXNzZXMuXG4gKi9cbmNsYXNzIERuc1Jlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ1Jlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsdGVybmF0aXZlUmVzb2x2ZXIgPSBuZXcgZG5zXzEucHJvbWlzZXMuUmVzb2x2ZXIoKTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSkge1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZVJlc29sdmVyLnNldFNlcnZlcnMoW3RhcmdldC5hdXRob3JpdHldKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xuICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCgwLCBuZXRfMS5pc0lQdjQpKGhvc3RQb3J0Lmhvc3QpIHx8ICgwLCBuZXRfMS5pc0lQdjYpKGhvc3RQb3J0Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAoX2EgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHBvcnRzLkRFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gaG9zdFBvcnQuaG9zdDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSAoX2IgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBleHBvcnRzLkRFRkFVTFRfUE9SVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWdfZGlzYWJsZV9yZXNvbHV0aW9uJ10gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvciA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgIGRldGFpbHM6IGBOYW1lIHJlc29sdXRpb24gZmFpbGVkIGZvciB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnVucmVmKCk7XG4gICAgICAgIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zID1cbiAgICAgICAgICAgIChfYyA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRuc19taW5fdGltZV9iZXR3ZWVuX3Jlc29sdXRpb25zX21zJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUztcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhcmdldCBpcyBhbiBJUCBhZGRyZXNzLCBqdXN0IHByb3ZpZGUgdGhhdCBhZGRyZXNzIGFzIGEgcmVzdWx0LlxuICAgICAqIE90aGVyd2lzZSwgaW5pdGlhdGUgQSwgQUFBQSwgYW5kIFRYVCBsb29rdXBzXG4gICAgICovXG4gICAgc3RhcnRSZXNvbHV0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pcFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJldHVybmVkSXBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmV0dXJuaW5nIElQIGFkZHJlc3MgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyKCgwLCBjYWxsX2ludGVyZmFjZV8xLnN0YXR1c09yRnJvbVZhbHVlKSh0aGlzLmlwUmVzdWx0KSwge30sIG51bGwsICcnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyKCgwLCBjYWxsX2ludGVyZmFjZV8xLnN0YXR1c09yRnJvbUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSBETlMgYWRkcmVzcyAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KX1gXG4gICAgICAgICAgICAgICAgfSksIHt9LCBudWxsLCAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0xvb2tpbmcgdXAgRE5TIGhvc3RuYW1lICcgKyB0aGlzLmRuc0hvc3RuYW1lKTtcbiAgICAgICAgICAgIC8qIFdlIGNsZWFyIG91dCBsYXRlc3RMb29rdXBSZXN1bHQgaGVyZSB0byBlbnN1cmUgdGhhdCBpdCBjb250YWlucyB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCByZXN1bHQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzdGFydGVkIHJlc29sdmluZy4gVGhhdCB3YXksIHRoZVxuICAgICAgICAgICAgICogVFhUIHJlc29sdXRpb24gaGFuZGxlciBjYW4gdXNlIGl0LCBidXQgb25seSBpZiBpdCBmaW5pc2hlcyBzZWNvbmQuIFdlXG4gICAgICAgICAgICAgKiBkb24ndCBjbGVhciBvdXQgYW55IHByZXZpb3VzIHNlcnZpY2UgY29uZmlnIHJlc3VsdHMgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgKiBiZXR0ZXIgdG8gdXNlIGEgc2VydmljZSBjb25maWcgdGhhdCdzIHNsaWdodGx5IG91dCBvZiBkYXRlIHRoYW4gdG9cbiAgICAgICAgICAgICAqIHJldmVydCB0byBhbiBlZmZlY3RpdmVseSBibGFuayBvbmUuICovXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuZG5zSG9zdG5hbWU7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gdGhpcy5sb29rdXAoaG9zdG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZS50aGVuKGFkZHJlc3NMaXN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gKDAsIGNhbGxfaW50ZXJmYWNlXzEuc3RhdHVzT3JGcm9tVmFsdWUpKGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NdLFxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQWRkcmVzc2VzU3RyaW5nID0gJ1snICtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc0xpc3QubWFwKGFkZHIgPT4gYWRkci5ob3N0ICsgJzonICsgYWRkci5wb3J0KS5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICAgICAnXSc7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWRkcmVzc2VzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgVFhUIGxvb2t1cCBoYXMgbm90IHlldCBmaW5pc2hlZCwgYm90aCBvZiB0aGUgbGFzdCB0d29cbiAgICAgICAgICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCBiZSBudWxsLCB3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBnZXR0aW5nIGFuXG4gICAgICAgICAgICAgICAgICogZW1wdHkgVFhUIHJlc3BvbnNlLiBXaGVuIHRoZSBUWFQgbG9va3VwIGRvZXMgZmluaXNoLCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICAgICAqIGNhbiB1cGRhdGUgdGhlIHNlcnZpY2UgY29uZmlnIGJ5IHVzaW5nIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWx0aFN0YXR1cyA9IHRoaXMubGlzdGVuZXIodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHt9LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdSZXN1bHQsICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUhlYWx0aFN0YXR1cyhoZWFsdGhTdGF0dXMpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHV0aW9uIGVycm9yIGZvciB0YXJnZXQgJyArXG4gICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIoKDAsIGNhbGxfaW50ZXJmYWNlXzEuc3RhdHVzT3JGcm9tRXJyb3IpKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvciksIHt9LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdSZXN1bHQsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogSWYgdGhlcmUgYWxyZWFkeSBpcyBhIHN0aWxsLXBlbmRpbmcgVFhUIHJlc29sdXRpb24sIHdlIGNhbiBqdXN0IHVzZVxuICAgICAgICAgICAgICogdGhhdCByZXN1bHQgd2hlbiBpdCBjb21lcyBpbiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCAmJiB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogV2UgaGFuZGxlIHRoZSBUWFQgcXVlcnkgcHJvbWlzZSBkaWZmZXJlbnRseSB0aGFuIHRoZSBvdGhlcnMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAqIHRoZSBuYW1lIHJlc29sdXRpb24gYXR0ZW1wdCBhcyBhIHdob2xlIGlzIGEgc3VjY2VzcyBldmVuIGlmIHRoZSBUWFRcbiAgICAgICAgICAgICAgICAgKiBsb29rdXAgZmFpbHMgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gdGhpcy5yZXNvbHZlVHh0KGhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlLnRoZW4odHh0UmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlQ29uZmlnID0gKDAsIHNlcnZpY2VfY29uZmlnXzEuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcpKHR4dFJlY29yZCwgdGhpcy5wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnUmVzdWx0ID0gKDAsIGNhbGxfaW50ZXJmYWNlXzEuc3RhdHVzT3JGcm9tVmFsdWUpKHNlcnZpY2VDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdSZXN1bHQgPSAoMCwgY2FsbF9pbnRlcmZhY2VfMS5zdGF0dXNPckZyb21FcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUGFyc2luZyBzZXJ2aWNlIGNvbmZpZyBmYWlsZWQgd2l0aCBlcnJvciAke2Vyci5tZXNzYWdlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogV2UgcmVseSBoZXJlIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGlkZW50aWNhbCBwYXJhbWV0ZXJzIHdpbGwgYmUgZXNzZW50aWFseSBpZGVtcG90ZW50LCBhbmQgY2FsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgcmVzdWx0IGluIGEgZmFzdCBhbmQgc2VhbWxlc3Mgc3dpdGNob3Zlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHt9LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdSZXN1bHQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIFRYVCBsb29rdXAgZmFpbHMgd2Ugc2hvdWxkIGRvIG5vdGhpbmcsIHdoaWNoIG1lYW5zIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgICogY29udGludWUgdG8gdXNlIHRoZSByZXN1bHQgb2YgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgbG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgKiBvciB0aGUgZGVmYXVsdCBudWxsIGNvbmZpZyBvYmplY3QgaWYgdGhlcmUgaGFzIG5ldmVyIGJlZW4gYVxuICAgICAgICAgICAgICAgICAgICAgKiBzdWNjZXNzZnVsIGxvb2t1cC4gV2UgZG8gbm90IHNldCB0aGUgbGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAqIGhlcmUgYmVjYXVzZSB0aGF0IGlzIHNwZWNpZmljYWxseSB1c2VkIGZvciByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGVycm9ycy4gV2Ugc3RpbGwgbmVlZCB0byBoYW5kbGUgdGhpcyBlcnJvciBzbyB0aGF0IGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAqIGJ1YmJsZSB1cCBhcyBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uICovXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIFJlc29sdmVyTGlzdGVuZXIgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBMQiBwb2xpY3lcbiAgICAgKiBhY2NlcHRlZCB0aGUgcmVzb2x1dGlvbiByZXN1bHQuIEEgZmFsc2UgcmVzdWx0IG9uIGFuIG90aGVyd2lzZSBzdWNjZXNzZnVsXG4gICAgICogcmVzb2x1dGlvbiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHJlc29sdXRpb24gZmFpbHVyZS5cbiAgICAgKiBAcGFyYW0gaGVhbHRoU3RhdHVzXG4gICAgICovXG4gICAgaGFuZGxlSGVhbHRoU3RhdHVzKGhlYWx0aFN0YXR1cykge1xuICAgICAgICBpZiAoaGVhbHRoU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsb29rdXAoaG9zdG5hbWUpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuR1JQQ19OT0RFX1VTRV9BTFRFUk5BVElWRV9SRVNPTFZFUikge1xuICAgICAgICAgICAgdHJhY2UoJ1VzaW5nIGFsdGVybmF0aXZlIEROUyByZXNvbHZlci4nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW1xuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlci5yZXNvbHZlNChob3N0bmFtZSksXG4gICAgICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZVJlc29sdmVyLnJlc29sdmU2KGhvc3RuYW1lKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHJlY29yZHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlY29yZHNbMF0ucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRzXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgPyBbLi4uYWNjLCAuLi5yZXN1bHQudmFsdWVdXG4gICAgICAgICAgICAgICAgICAgIDogYWNjO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgLm1hcChhZGRyID0+ICh7XG4gICAgICAgICAgICAgICAgaG9zdDogYWRkcixcbiAgICAgICAgICAgICAgICBwb3J0OiArdGhpcy5wb3J0LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFdlIGxvb2t1cCBib3RoIGFkZHJlc3MgZmFtaWxpZXMgaGVyZSBhbmQgdGhlbiBzcGxpdCB0aGVtIHVwIGxhdGVyXG4gICAgICAgICAqIGJlY2F1c2Ugd2hlbiBsb29raW5nIHVwIGEgc2luZ2xlIGZhbWlseSwgZG5zLmxvb2t1cCBvdXRwdXRzIGFuIGVycm9yXG4gICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxuICAgICAgICAgKiBlcnJvciBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycyAqL1xuICAgICAgICBjb25zdCBhZGRyZXNzTGlzdCA9IGF3YWl0IGRuc18xLnByb21pc2VzLmxvb2t1cChob3N0bmFtZSwgeyBhbGw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzTGlzdC5tYXAoYWRkciA9PiAoeyBob3N0OiBhZGRyLmFkZHJlc3MsIHBvcnQ6ICt0aGlzLnBvcnQgfSkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlVHh0KGhvc3RuYW1lKSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIpIHtcbiAgICAgICAgICAgIHRyYWNlKCdVc2luZyBhbHRlcm5hdGl2ZSBETlMgcmVzb2x2ZXIuJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHRlcm5hdGl2ZVJlc29sdmVyLnJlc29sdmVUeHQoaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkbnNfMS5wcm9taXNlcy5yZXNvbHZlVHh0KGhvc3RuYW1lKTtcbiAgICB9XG4gICAgc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IHRydWU7XG4gICAgfVxuICAgIHN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJ1bk9uY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyBsb29rdXAsIGp1c3QgbGV0IGl0IGZpbmlzaC4gT3RoZXJ3aXNlLCBpZiB0aGVcbiAgICAgICAgICogbmV4dFJlc29sdXRpb25UaW1lciBvciBiYWNrb2ZmIHRpbWVyIGlzIHJ1bm5pbmcsIHNldCB0aGVcbiAgICAgICAgICogY29udGludWVSZXNvbHZpbmcgZmxhZyB0byByZXNvbHZlIHdoZW4gd2hpY2hldmVyIG9mIHRob3NlIHRpbWVyc1xuICAgICAgICAgKiBmaXJlcy4gT3RoZXJ3aXNlLCBzdGFydCByZXNvbHZpbmcgaW1tZWRpYXRlbHkuICovXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIHx8IHRoaXMuYmFja29mZi5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ3Jlc29sdXRpb24gdXBkYXRlIGRlbGF5ZWQgYnkgXCJtaW4gdGltZSBiZXR3ZWVuIHJlc29sdXRpb25zXCIgcmF0ZSBsaW1pdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ3Jlc29sdXRpb24gdXBkYXRlIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSByZXNvbHZlciB0byB0aGUgc2FtZSBzdGF0ZSBpdCBoYWQgd2hlbiBpdCB3YXMgY3JlYXRlZC4gSW4tZmxpZ2h0XG4gICAgICogRE5TIHJlcXVlc3RzIGNhbm5vdCBiZSBjYW5jZWxsZWQsIGJ1dCB0aGV5IGFyZSBkaXNjYXJkZWQgYW5kIHRoZWlyIHJlc3VsdHNcbiAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = setup;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'ip_resolver';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = 'ipv4';\nconst IPV6_SCHEME = 'ipv6';\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions) {\n        var _a;\n        this.listener = listener;\n        this.endpoints = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata(),\n            };\n            return;\n        }\n        const pathList = target.path.split(',');\n        for (const path of pathList) {\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||\n                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n            });\n        }\n        this.endpoints = addresses.map(address => ({ addresses: [address] }));\n        trace('Parsed ' + target.scheme + ' address list ' + addresses.map(subchannel_address_1.subchannelAddressToString));\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(() => {\n                if (this.error) {\n                    this.listener((0, call_interface_1.statusOrFromError)(this.error), {}, null, '');\n                }\n                else {\n                    this.listener((0, call_interface_1.statusOrFromValue)(this.endpoints), {}, null, '');\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(',')[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n}\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1pcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLFVBQVUsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsVUFBVSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanM/NTQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBjYWxsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vY2FsbC1pbnRlcmZhY2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnaXBfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcbmNvbnN0IElQVjZfU0NIRU1FID0gJ2lwdjYnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5jbGFzcyBJcFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSB0YXJnZXQucGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwYXRoKTtcbiAgICAgICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkpIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldC5zY2hlbWUgPT09IElQVjZfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY2KShob3N0UG9ydC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzID0gYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+ICh7IGFkZHJlc3NlczogW2FkZHJlc3NdIH0pKTtcbiAgICAgICAgdHJhY2UoJ1BhcnNlZCAnICsgdGFyZ2V0LnNjaGVtZSArICcgYWRkcmVzcyBsaXN0ICcgKyBhZGRyZXNzZXMubWFwKHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIoKDAsIGNhbGxfaW50ZXJmYWNlXzEuc3RhdHVzT3JGcm9tRXJyb3IpKHRoaXMuZXJyb3IpLCB7fSwgbnVsbCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcigoMCwgY2FsbF9pbnRlcmZhY2VfMS5zdGF0dXNPckZyb21WYWx1ZSkodGhpcy5lbmRwb2ludHMpLCB7fSwgbnVsbCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aC5zcGxpdCgnLCcpWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKShJUFY2X1NDSEVNRSwgSXBSZXNvbHZlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1pcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = setup;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions) {\n        this.listener = listener;\n        this.hasReturnedResult = false;\n        this.endpoints = [];\n        let path;\n        if (target.authority === '') {\n            path = '/' + target.path;\n        }\n        else {\n            path = target.path;\n        }\n        this.endpoints = [{ addresses: [{ path }] }];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener, (0, call_interface_1.statusOrFromValue)(this.endpoints), {}, null, '');\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return 'localhost';\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)('unix', UdsResolver);\n}\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci11ZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYyxNQUFNLEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzPzk2YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgY2FsbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2NhbGwtaW50ZXJmYWNlXCIpO1xuY2xhc3MgVWRzUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgaWYgKHRhcmdldC5hdXRob3JpdHkgPT09ICcnKSB7XG4gICAgICAgICAgICBwYXRoID0gJy8nICsgdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbeyBhZGRyZXNzZXM6IFt7IHBhdGggfV0gfV07XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIsICgwLCBjYWxsX2ludGVyZmFjZV8xLnN0YXR1c09yRnJvbVZhbHVlKSh0aGlzLmVuZHBvaW50cyksIHt9LCBudWxsLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuICdsb2NhbGhvc3QnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCd1bml4JywgVWRzUmVzb2x2ZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItdWRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CHANNEL_ARGS_CONFIG_SELECTOR_KEY = void 0;\nexports.registerResolver = registerResolver;\nexports.registerDefaultScheme = registerDefaultScheme;\nexports.createResolver = createResolver;\nexports.getDefaultAuthority = getDefaultAuthority;\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nexports.CHANNEL_ARGS_CONFIG_SELECTOR_KEY = 'grpc.internal.config_selector';\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    }\n    else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    }\n    else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target),\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzQ0FBc0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNDQUFzQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanM/OGY3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSEFOTkVMX0FSR1NfQ09ORklHX1NFTEVDVE9SX0tFWSA9IHZvaWQgMDtcbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHJlZ2lzdGVyUmVzb2x2ZXI7XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IHJlZ2lzdGVyRGVmYXVsdFNjaGVtZTtcbmV4cG9ydHMuY3JlYXRlUmVzb2x2ZXIgPSBjcmVhdGVSZXNvbHZlcjtcbmV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGdldERlZmF1bHRBdXRob3JpdHk7XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBtYXBVcmlEZWZhdWx0U2NoZW1lO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmV4cG9ydHMuQ0hBTk5FTF9BUkdTX0NPTkZJR19TRUxFQ1RPUl9LRVkgPSAnZ3JwYy5pbnRlcm5hbC5jb25maWdfc2VsZWN0b3InO1xuY29uc3QgcmVnaXN0ZXJlZFJlc29sdmVycyA9IHt9O1xubGV0IGRlZmF1bHRTY2hlbWUgPSBudWxsO1xuLyoqXG4gKiBSZWdpc3RlciBhIHJlc29sdmVyIGNsYXNzIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgcHJlZml4ZWQgd2l0aCB0aGUgYHByZWZpeGBcbiAqIHN0cmluZy4gVGhpcyBwcmVmaXggc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBVUkkgc2NoZW1lIG5hbWUgbGlzdGVkIGluIHRoZVxuICogW2dSUEMgTmFtZSBSZXNvbHV0aW9uIGRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9uYW1pbmcubWQpXG4gKiBAcGFyYW0gcHJlZml4XG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclJlc29sdmVyKHNjaGVtZSwgcmVzb2x2ZXJDbGFzcykge1xuICAgIHJlZ2lzdGVyZWRSZXNvbHZlcnNbc2NoZW1lXSA9IHJlc29sdmVyQ2xhc3M7XG59XG4vKipcbiAqIFJlZ2lzdGVyIGEgZGVmYXVsdCByZXNvbHZlciB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGhcbiAqIGFueSByZWdpc3RlcmVkIHByZWZpeC5cbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFNjaGVtZShzY2hlbWUpIHtcbiAgICBkZWZhdWx0U2NoZW1lID0gc2NoZW1lO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuYW1lIHJlc29sdmVyIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gc3VjaCBuYW1lIHJlc29sdmVyIGNhbiBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0odGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc29sdmVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwVXJpRGVmYXVsdFNjaGVtZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8ICEodGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSkge1xuICAgICAgICBpZiAoZGVmYXVsdFNjaGVtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2hlbWU6IGRlZmF1bHRTY2hlbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGF0aDogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingCall = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = 'resolving_call';\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, callNumber) {\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(() => { }, 0);\n        this.filterStack = null;\n        this.deadlineStartTime = null;\n        this.configReceivedTime = null;\n        this.childStartTime = null;\n        /**\n         * Credentials configured for this specific call. Does not include\n         * call credentials associated with the channel credentials used to create\n         * the channel.\n         */\n        this.credentials = call_credentials_1.CallCredentials.createEmpty();\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on('cancelled', () => {\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace('Propagating deadline from parent: ' +\n                    options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace('Created');\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.deadlineStartTime = new Date();\n        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace('Deadline will be reached in ' + timeout + 'ms');\n            const handleDeadline = () => {\n                if (!this.deadlineStartTime) {\n                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n                    return;\n                }\n                const deadlineInfo = [];\n                const deadlineEndTime = new Date();\n                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);\n                if (this.configReceivedTime) {\n                    if (this.configReceivedTime > this.deadlineStartTime) {\n                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);\n                    }\n                    if (this.childStartTime) {\n                        if (this.childStartTime > this.configReceivedTime) {\n                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);\n                        }\n                    }\n                    else {\n                        deadlineInfo.push('waiting for metadata filters');\n                    }\n                }\n                else {\n                    deadlineInfo.push('waiting for name resolution');\n                }\n                if (this.child) {\n                    deadlineInfo.push(...this.child.getDeadlineInfo());\n                }\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            }\n            else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace('ended with status: code=' +\n                filteredStatus.code +\n                ' details=\"' +\n                filteredStatus.details +\n                '\"');\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error('sendMessageonChild called with child not populated');\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status) => {\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error('getConfig called before start');\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === 'NONE') {\n            this.channel.queueCallForConfig(this);\n            return;\n        }\n        else if (configResult.type === 'ERROR') {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            }\n            else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        this.configReceivedTime = new Date();\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata(),\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +\n                config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n            this.child = this.channel.createRetryingCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace('Created child [' + this.child.getCallNumber() + ']');\n            this.childStartTime = new Date();\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: metadata => {\n                    this.trace('Received metadata');\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: message => {\n                    this.trace('Received message');\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then(filteredMesssage => {\n                        this.trace('Finished filtering received message');\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status) => {\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: status => {\n                    this.trace('Received status');\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    }\n                    else {\n                        this.outputStatus(status);\n                    }\n                },\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            }\n            else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status) => {\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        }\n        else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata(),\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    getAuthContext() {\n        if (this.child) {\n            return this.child.getAuthContext();\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.ResolvingCall = ResolvingCall;\n//# sourceMappingURL=resolving-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsOEVBQThFO0FBQzNJO0FBQ0E7QUFDQSw4REFBOEQsc0ZBQXNGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxtRkFBbUY7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanM/YmFjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gdm9pZCAwO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2FsbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfY2FsbCc7XG5jbGFzcyBSZXNvbHZpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBtZXRob2QsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY2FsbE51bWJlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkgPSBmaWx0ZXJTdGFja0ZhY3Rvcnk7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhZGxpbmVTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlZGVudGlhbHMgY29uZmlndXJlZCBmb3IgdGhpcyBzcGVjaWZpYyBjYWxsLiBEb2VzIG5vdCBpbmNsdWRlXG4gICAgICAgICAqIGNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFubmVsIGNyZWRlbnRpYWxzIHVzZWQgdG8gY3JlYXRlXG4gICAgICAgICAqIHRoZSBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHkoKTtcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50Q2FsbCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRDYWxsLm9uKCdjYW5jZWxsZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIGJ5IHBhcmVudCBjYWxsJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mbGFncyAmIGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUFETElORSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1Byb3BhZ2F0aW5nIGRlYWRsaW5lIGZyb20gcGFyZW50OiAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRDYWxsLmdldERlYWRsaW5lKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSAoMCwgZGVhZGxpbmVfMS5taW5EZWFkbGluZSkodGhpcy5kZWFkbGluZSwgb3B0aW9ucy5wYXJlbnRDYWxsLmdldERlYWRsaW5lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQnKTtcbiAgICAgICAgdGhpcy5ydW5EZWFkbGluZVRpbWVyKCk7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJ1bkRlYWRsaW5lVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICB0aGlzLmRlYWRsaW5lU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmU6ICcgKyAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lIHdpbGwgYmUgcmVhY2hlZCBpbiAnICsgdGltZW91dCArICdtcycpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRGVhZGxpbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlYWRsaW5lU3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsICdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYERlYWRsaW5lIGV4Y2VlZGVkIGFmdGVyICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuZGVhZGxpbmVTdGFydFRpbWUsIGRlYWRsaW5lRW5kVGltZSl9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSA+IHRoaXMuZGVhZGxpbmVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKGBuYW1lIHJlc29sdXRpb246ICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuZGVhZGxpbmVTdGFydFRpbWUsIHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRTdGFydFRpbWUgPiB0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKGBtZXRhZGF0YSBmaWx0ZXJzOiAkeygwLCBkZWFkbGluZV8xLmZvcm1hdERhdGVEaWZmZXJlbmNlKSh0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSwgdGhpcy5jaGlsZFN0YXJ0VGltZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnd2FpdGluZyBmb3IgbWV0YWRhdGEgZmlsdGVycycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnd2FpdGluZyBmb3IgbmFtZSByZXNvbHV0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKC4uLnRoaXMuY2hpbGQuZ2V0RGVhZGxpbmVJbmZvKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVELCBkZWFkbGluZUluZm8uam9pbignLCcpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhoYW5kbGVEZWFkbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZURlYWRsaW5lLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyU3RhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkU3RhdHVzID0gdGhpcy5maWx0ZXJTdGFjay5yZWNlaXZlVHJhaWxlcnMoc3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5mb3JFYWNoKHdhdGNoZXIgPT4gd2F0Y2hlcihmaWx0ZXJlZFN0YXR1cykpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoZmlsdGVyZWRTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VPbkNoaWxkKGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbmRNZXNzYWdlb25DaGlsZCBjYWxsZWQgd2l0aCBjaGlsZCBub3QgcG9wdWxhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkO1xuICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1lc3NhZ2UoUHJvbWlzZS5yZXNvbHZlKHsgbWVzc2FnZTogbWVzc2FnZSwgZmxhZ3M6IGNvbnRleHQuZmxhZ3MgfSkpLnRoZW4oZmlsdGVyZWRNZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbHRlcmVkTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25maWcoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhIHx8ICF0aGlzLmxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENvbmZpZyBjYWxsZWQgYmVmb3JlIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnUmVzdWx0ID0gdGhpcy5jaGFubmVsLmdldENvbmZpZyh0aGlzLm1ldGhvZCwgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgIGlmIChjb25maWdSZXN1bHQudHlwZSA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnRVJST1InKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKGNvbmZpZ1Jlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uZmlnUmVzdWx0LnR5cGUgPT09ICdTVUNDRVNTJ1xuICAgICAgICB0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1Jlc3VsdC5jb25maWc7XG4gICAgICAgIGlmIChjb25maWcuc3RhdHVzICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShjb25maWcuc3RhdHVzLCAnRmFpbGVkIHRvIHJvdXRlIGNhbGwgdG8gbWV0aG9kICcgKyB0aGlzLm1ldGhvZCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnRGVhZGxpbmUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uZmlnRGVhZGxpbmUuc2V0U2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRTZWNvbmRzKCkgKyBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRNaWxsaXNlY29uZHMoY29uZmlnRGVhZGxpbmUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5uYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBjb25maWdEZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlYWRsaW5lVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5wdXNoKGNvbmZpZy5keW5hbWljRmlsdGVyRmFjdG9yaWVzKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXRhZGF0YShQcm9taXNlLnJlc29sdmUodGhpcy5tZXRhZGF0YSkpLnRoZW4oZmlsdGVyZWRNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZVJldHJ5aW5nQ2FsbChjb25maWcsIHRoaXMubWV0aG9kLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydChmaWx0ZXJlZE1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmaWx0ZXJlZE1lc3NzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZpbmlzaGVkIGZpbHRlcmluZyByZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UoZmlsdGVyZWRNZXNzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRSZXNvbHZlckVycm9yKHN0YXR1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmdldENvbmZpZygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBhZGRTdGF0dXNXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEF1dGhDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IFJlc29sdmluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */\nconst NAME_MATCH_LEVEL_ORDER = [\n    'SERVICE_AND_METHOD',\n    'SERVICE',\n    'EMPTY',\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name) {\n        switch (matchLevel) {\n            case 'EMPTY':\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE':\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE_AND_METHOD':\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs) {\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return {\n        invoke(methodName, metadata) {\n            var _a, _b;\n            const splitName = methodName.split('/').filter(x => x.length > 0);\n            const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n            const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n            if (serviceConfig && serviceConfig.methodConfig) {\n                /* Check for the following in order, and return the first method\n                * config that matches:\n                * 1. A name that exactly matches the service and method\n                * 2. A name with no method set that matches the service\n                * 3. An empty name\n                */\n                for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\n                    const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                    if (matchingConfig) {\n                        return {\n                            methodConfig: matchingConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: [],\n                        };\n                    }\n                }\n            }\n            return {\n                methodConfig: { name: [] },\n                pickInformation: {},\n                status: constants_1.Status.OK,\n                dynamicFilterFactories: [],\n            };\n        },\n        unref() { }\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.latestChildErrorMessage = null;\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    trace('requestReresolution delayed by backoff timer until ' +\n                        this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker, errorMessage) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.latestChildErrorMessage = errorMessage;\n                this.updateState(newState, picker, errorMessage);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, this.handleResolverResult.bind(this), channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker, this.latestChildErrorMessage);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    handleResolverResult(endpointList, attributes, serviceConfig, resolutionNote) {\n        var _a, _b;\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n        let resultAccepted = true;\n        let workingServiceConfig = null;\n        if (serviceConfig === null) {\n            workingServiceConfig = this.defaultServiceConfig;\n        }\n        else if (serviceConfig.ok) {\n            workingServiceConfig = serviceConfig.value;\n        }\n        else {\n            if (this.previousServiceConfig !== null) {\n                workingServiceConfig = this.previousServiceConfig;\n            }\n            else {\n                resultAccepted = false;\n                this.handleResolutionFailure(serviceConfig.error);\n            }\n        }\n        if (workingServiceConfig !== null) {\n            const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n            const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);\n            if (loadBalancingConfig === null) {\n                resultAccepted = false;\n                this.handleResolutionFailure({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: 'All load balancer options in service config are not compatible',\n                    metadata: new metadata_1.Metadata(),\n                });\n            }\n            else {\n                resultAccepted = this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, Object.assign(Object.assign({}, this.channelOptions), attributes), resolutionNote);\n            }\n        }\n        if (resultAccepted) {\n            this.onSuccessfulResolution(workingServiceConfig, (_b = attributes[resolver_1.CHANNEL_ARGS_CONFIG_SELECTOR_KEY]) !== null && _b !== void 0 ? _b : getDefaultConfigSelector(workingServiceConfig));\n        }\n        return resultAccepted;\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            /* this.latestChildPicker is initialized as new QueuePicker(this), which\n             * is an appropriate value here if the child LB policy is unset.\n             * Otherwise, we want to delegate to the child here, in case that\n             * triggers something. */\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker, this.latestChildErrorMessage);\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker, errorMessage) {\n        trace((0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this, picker);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker, errorMessage);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error), error.details);\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\n            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(endpointList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qix3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsbUdBQWtCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBbUI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0Msc0NBQXNDLG1CQUFPLENBQUMsNkhBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwySUFBMkk7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcz9mZDc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbi8qKlxuICogTmFtZSBtYXRjaCBsZXZlbHMgaW4gb3JkZXIgZnJvbSBtb3N0IHRvIGxlYXN0IHNwZWNpZmljLiBUaGlzIGlzIHRoZSBvcmRlciBpblxuICogd2hpY2ggc2VhcmNoZXMgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKi9cbmNvbnN0IE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIgPSBbXG4gICAgJ1NFUlZJQ0VfQU5EX01FVEhPRCcsXG4gICAgJ1NFUlZJQ0UnLFxuICAgICdFTVBUWScsXG5dO1xuZnVuY3Rpb24gaGFzTWF0Y2hpbmdOYW1lKHNlcnZpY2UsIG1ldGhvZCwgbWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobWF0Y2hMZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAnRU1QVFknOlxuICAgICAgICAgICAgICAgIGlmICghbmFtZS5zZXJ2aWNlICYmICFuYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFJzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmICFuYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFX0FORF9NRVRIT0QnOlxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgbmFtZS5tZXRob2QgPT09IG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZE1hdGNoaW5nQ29uZmlnKHNlcnZpY2UsIG1ldGhvZCwgbWV0aG9kQ29uZmlncywgbWF0Y2hMZXZlbCkge1xuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG1ldGhvZENvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIGNvbmZpZywgbWF0Y2hMZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGludm9rZShtZXRob2ROYW1lLCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0TmFtZSA9IG1ldGhvZE5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAoX2IgPSBzcGxpdE5hbWVbMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVjayBmb3IgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHJldHVybiB0aGUgZmlyc3QgbWV0aG9kXG4gICAgICAgICAgICAgICAgKiBjb25maWcgdGhhdCBtYXRjaGVzOlxuICAgICAgICAgICAgICAgICogMS4gQSBuYW1lIHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBzZXJ2aWNlIGFuZCBtZXRob2RcbiAgICAgICAgICAgICAgICAqIDIuIEEgbmFtZSB3aXRoIG5vIG1ldGhvZCBzZXQgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgKiAzLiBBbiBlbXB0eSBuYW1lXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoTGV2ZWwgb2YgTkFNRV9NQVRDSF9MRVZFTF9PUkRFUikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZigpIHsgfVxuICAgIH07XG59XG5jbGFzcyBSZXNvbHZpbmdMb2FkQmFsYW5jZXIge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgY2xhc3MgdGhhdCBiZWhhdmVzIGxpa2UgYSBgTG9hZEJhbGFuY2VyYCBhbmQgYWxzbyBoYW5kbGVzIG5hbWVcbiAgICAgKiByZXNvbHV0aW9uIGludGVybmFsbHkuXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgYWRkcmVzcyBvZiB0aGUgYmFja2VuZCB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0U2VydmljZUNvbmZpZyBUaGUgZGVmYXVsdCBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZFxuICAgICAqICAgICBpZiBub25lIGlzIHByb3ZpZGVkIGJ5IHRoZSBuYW1lIHJlc29sdmVyLiBBIGBudWxsYCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAgKiAgICAgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBzaG91bGQgYmUgdGhlIGRlZmF1bHQgdW5jb25maWd1cmVkIGJlaGF2aW9yLlxuICAgICAqICAgICBJbiBwcmFjdGljZSwgdGhhdCBtZWFucyB1c2luZyB0aGUgXCJwaWNrIGZpcnN0XCIgbG9hZCBiYWxhbmNlclxuICAgICAqICAgICBpbXBsbWVudGF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgY2hhbm5lbE9wdGlvbnMsIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIG9uRmFpbGVkUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9IG9uU3VjY2Vzc2Z1bFJlc29sdXRpb247XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkRXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXG4gICAgICAgICAqIGF2YWlsYWJsZS4gQSB2YWx1ZSBvZiBudWxsIGluZGljYXRlcyB0aGF0IHdlIGhhdmUgbm90IHlldCByZWNlaXZlZCBhIHZhbGlkXG4gICAgICAgICAqIHNlcnZpY2UgY29uZmlnIGZyb20gdGhlIHJlc29sdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxuICAgICAgICAgKiB0aW1lciBydW5zIG91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS52YWxpZGF0ZVNlcnZpY2VDb25maWcpKEpTT04ucGFyc2UoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcbiAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmZUaW1lb3V0IGlzIHJ1bm5pbmcsIHdlJ3JlIHN0aWxsIGJhY2tpbmcgb2ZmIGZyb21cbiAgICAgICAgICAgICAgICAgKiBtYWtpbmcgcmVzb2x2ZSByZXF1ZXN0cywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW5vdGhlciBvbmUgaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBiYWNrb2ZmIHRpbWVyIGNhbGxiYWNrIHdpbGwgY2FsbFxuICAgICAgICAgICAgICAgICAqIHVwZGF0ZVJlc29sdXRpb24gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVxdWVzdFJlcmVzb2x1dGlvbiBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LmdldEVuZFRpbWUoKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyID0gKDAsIHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIpKHRhcmdldCwgdGhpcy5oYW5kbGVSZXNvbHZlclJlc3VsdC5iaW5kKHRoaXMpLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSwgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciwgdGhpcy5sYXRlc3RDaGlsZEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHZlclJlc3VsdChlbmRwb2ludExpc3QsIGF0dHJpYnV0ZXMsIHNlcnZpY2VDb25maWcsIHJlc29sdXRpb25Ob3RlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgIGxldCByZXN1bHRBY2NlcHRlZCA9IHRydWU7XG4gICAgICAgIGxldCB3b3JraW5nU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VydmljZUNvbmZpZy5vaykge1xuICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSBzZXJ2aWNlQ29uZmlnLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdEFjY2VwdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShzZXJ2aWNlQ29uZmlnLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya2luZ1NlcnZpY2VDb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtpbmdDb25maWdMaXN0ID0gKF9hID0gd29ya2luZ1NlcnZpY2VDb25maWcgPT09IG51bGwgfHwgd29ya2luZ1NlcnZpY2VDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdvcmtpbmdTZXJ2aWNlQ29uZmlnLmxvYWRCYWxhbmNpbmdDb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgY29uc3QgbG9hZEJhbGFuY2luZ0NvbmZpZyA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuc2VsZWN0TGJDb25maWdGcm9tTGlzdCkod29ya2luZ0NvbmZpZ0xpc3QsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGxvYWRCYWxhbmNpbmdDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRBY2NlcHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdBbGwgbG9hZCBiYWxhbmNlciBvcHRpb25zIGluIHNlcnZpY2UgY29uZmlnIGFyZSBub3QgY29tcGF0aWJsZScsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0QWNjZXB0ZWQgPSB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbG9hZEJhbGFuY2luZ0NvbmZpZywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNoYW5uZWxPcHRpb25zKSwgYXR0cmlidXRlcyksIHJlc29sdXRpb25Ob3RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0QWNjZXB0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbih3b3JraW5nU2VydmljZUNvbmZpZywgKF9iID0gYXR0cmlidXRlc1tyZXNvbHZlcl8xLkNIQU5ORUxfQVJHU19DT05GSUdfU0VMRUNUT1JfS0VZXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKHdvcmtpbmdTZXJ2aWNlQ29uZmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdEFjY2VwdGVkO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICB0aGlzLmlubmVyUmVzb2x2ZXIudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIC8qIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgaXMgaW5pdGlhbGl6ZWQgYXMgbmV3IFF1ZXVlUGlja2VyKHRoaXMpLCB3aGljaFxuICAgICAgICAgICAgICogaXMgYW4gYXBwcm9wcmlhdGUgdmFsdWUgaGVyZSBpZiB0aGUgY2hpbGQgTEIgcG9saWN5IGlzIHVuc2V0LlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCB3ZSB3YW50IHRvIGRlbGVnYXRlIHRvIHRoZSBjaGlsZCBoZXJlLCBpbiBjYXNlIHRoYXRcbiAgICAgICAgICAgICAqIHRyaWdnZXJzIHNvbWV0aGluZy4gKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciwgdGhpcy5sYXRlc3RDaGlsZEVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB0cmFjZSgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbY29ubmVjdGl2aXR5U3RhdGVdKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcy5leGl0SWRsZSgpIGlzIGNhbGxlZCBieSB0aGUgcGlja2VyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgcGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMsIHBpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDaGlsZFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpLCBlcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IFJlc29sdmluZ0xvYWRCYWxhbmNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */\n            this.tokens =\n                previousRetryThrottler.tokens *\n                    (maxTokens / previousRetryThrottler.maxTokens);\n        }\n        else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.min(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.max(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > (this.maxTokens / 2);\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall) {\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size ||\n            this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nconst DEFAULT_MAX_ATTEMPTS_LIMIT = 5;\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n        var _a;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */\n        this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */\n        this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */\n        this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;\n        if (channel.getOptions()['grpc.enable_retries'] === 0) {\n            this.state = 'NO_RETRY';\n            this.maxAttempts = 1;\n        }\n        else if (callConfig.methodConfig.retryPolicy) {\n            this.state = 'RETRY';\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);\n        }\n        else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = 'HEDGING';\n            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);\n        }\n        else {\n            this.state = 'TRANSPARENT_ONLY';\n            this.maxAttempts = 1;\n        }\n        this.startTime = new Date();\n    }\n    getDeadlineInfo() {\n        if (this.underlyingCalls.length === 0) {\n            return [];\n        }\n        const deadlineInfo = [];\n        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];\n        if (this.underlyingCalls.length > 1) {\n            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);\n        }\n        if (latestCall.startTime > this.startTime) {\n            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);\n        }\n        deadlineInfo.push(...latestCall.call.getDeadlineInfo());\n        return deadlineInfo;\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    reportStatus(statusObject) {\n        this.trace('ended with status: code=' +\n            statusObject.code +\n            ' details=\"' +\n            statusObject.details +\n            '\" start time=' +\n            this.startTime.toISOString());\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(() => {\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata,\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });\n        for (const { call } of this.underlyingCalls) {\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: 'FREED',\n            allocated: false,\n        });\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== 'COMMITTED') {\n            return;\n        }\n        let earliestNeededMessageIndex;\n        if (this.underlyingCalls[this.committedCallIndex].state === 'COMPLETED') {\n            /* If the committed call is completed, clear all messages, even if some\n             * have not been sent. */\n            earliestNeededMessageIndex = this.getNextBufferIndex();\n        }\n        else {\n            earliestNeededMessageIndex =\n                this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        }\n        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        var _a, _b;\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        this.trace('Committing call [' +\n            this.underlyingCalls[index].call.getCallNumber() +\n            '] at index ' +\n            index);\n        this.state = 'COMMITTED';\n        (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.committedCallIndex = index;\n        for (let i = 0; i < this.underlyingCalls.length; i++) {\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === 'COMPLETED') {\n                continue;\n            }\n            this.underlyingCalls[i].state = 'COMPLETED';\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()) {\n            if (childCall.state === 'ACTIVE' &&\n                childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */\n            this.state = 'TRANSPARENT_ONLY';\n        }\n        else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some(value => {\n            var _a;\n            return value === code ||\n                value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        });\n    }\n    getNextRetryJitter() {\n        /* Jitter of +-20% is applied: https://github.com/grpc/proposal/blob/master/A6-client-retries.md#exponential-backoff */\n        return Math.random() * (1.2 - 0.8) + 0.8;\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const jitter = this.getNextRetryJitter();\n        const nextBackoffMs = jitter * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== 'RETRY') {\n            callback(false);\n            return;\n        }\n        if (this.attempts >= this.maxAttempts) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        }\n        else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            callback(false);\n            return;\n        }\n        else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(() => {\n            var _a, _b;\n            if (this.state !== 'RETRY') {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n            else {\n                this.trace('Retry attempt denied by throttling policy');\n                callback(false);\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch (this.state) {\n            case 'COMMITTED':\n            case 'NO_RETRY':\n            case 'TRANSPARENT_ONLY':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'HEDGING':\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    }\n                    else if (pushback < 0) {\n                        this.state = 'TRANSPARENT_ONLY';\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    }\n                    else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(() => {\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case 'RETRY':\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, retried => {\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get('grpc-retry-pushback-ms');\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        }\n        catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n            return;\n        }\n        this.trace('state=' +\n            this.state +\n            ' handling status with progress ' +\n            status.progress +\n            ' from child [' +\n            this.underlyingCalls[callIndex].call.getCallNumber() +\n            '] in state ' +\n            this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = 'COMPLETED';\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === 'NO_RETRY') {\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === 'COMMITTED') {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch (status.progress) {\n            case 'NOT_STARTED':\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case 'REFUSED':\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                }\n                else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case 'DROP':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'PROCESSED':\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        if (this.attempts >= this.maxAttempts) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= this.maxAttempts) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace('Created child call [' +\n            child.getCallNumber() +\n            '] for attempt ' +\n            this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: 'ACTIVE',\n            call: child,\n            nextMessageToSend: 0,\n            startTime: new Date(),\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: metadata => {\n                this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: message => {\n                this.trace('Received message from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: status => {\n                this.trace('Received status from child [' + child.getCallNumber() + ']');\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            },\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === 'COMPLETED') {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch (bufferEntry.entryType) {\n                case 'MESSAGE':\n                    childCall.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        },\n                    }, bufferEntry.message.message);\n                    break;\n                case 'HALF_CLOSE':\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case 'FREED':\n                    // Should not be possible\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: 'MESSAGE',\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber),\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()) {\n                if (call.state === 'ACTIVE' &&\n                    call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        },\n                    }, message);\n                }\n            }\n        }\n        else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: error => {\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    },\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls) {\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: 'HALF_CLOSE',\n            allocated: false,\n        });\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&\n                call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error('Method not implemented.');\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n    getAuthContext() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getAuthContext();\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.RetryingCall = RetryingCall;\n//# sourceMappingURL=retrying-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCO0FBQzVFLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsUUFBUSxNQUFNLG9CQUFvQixvQkFBb0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxRQUFRLE1BQU0sdUJBQXVCLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxZQUFZLGdCQUFnQixvQkFBb0Isb0JBQW9CO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQ0FBZ0M7QUFDcEY7QUFDQTtBQUNBLGdFQUFnRSwyRUFBMkU7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQTREO0FBQ3hGLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwyQ0FBMkM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzPzI5NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IGV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmV0cnlpbmdfY2FsbCc7XG5jbGFzcyBSZXRyeVRocm90dGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4VG9rZW5zLCB0b2tlblJhdGlvLCBwcmV2aW91c1JldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB0aGlzLnRva2VuUmF0aW8gPSB0b2tlblJhdGlvO1xuICAgICAgICBpZiAocHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICAgICAgLyogV2hlbiBjYXJyeWluZyBvdmVyIHRva2VucyBmcm9tIGEgcHJldmlvdXMgY29uZmlnLCByZXNjYWxlIHRoZW0gdG8gdGhlXG4gICAgICAgICAgICAgKiBuZXcgbWF4IHZhbHVlICovXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXRyeVRocm90dGxlci50b2tlbnMgKlxuICAgICAgICAgICAgICAgICAgICAobWF4VG9rZW5zIC8gcHJldmlvdXNSZXRyeVRocm90dGxlci5tYXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPSBtYXhUb2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1pbih0aGlzLnRva2VucyArIHRoaXMudG9rZW5SYXRpbywgdGhpcy5tYXhUb2tlbnMpO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IE1hdGgubWF4KHRoaXMudG9rZW5zIC0gMSwgMCk7XG4gICAgfVxuICAgIGNhblJldHJ5Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zID4gKHRoaXMubWF4VG9rZW5zIC8gMik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXRyeVRocm90dGxlciA9IFJldHJ5VGhyb3R0bGVyO1xuY2xhc3MgTWVzc2FnZUJ1ZmZlclRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsTGltaXQsIGxpbWl0UGVyQ2FsbCkge1xuICAgICAgICB0aGlzLnRvdGFsTGltaXQgPSB0b3RhbExpbWl0O1xuICAgICAgICB0aGlzLmxpbWl0UGVyQ2FsbCA9IGxpbWl0UGVyQ2FsbDtcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCA9IDA7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWxsb2NhdGUoc2l6ZSwgY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmICh0aGlzLmxpbWl0UGVyQ2FsbCAtIGN1cnJlbnRQZXJDYWxsIDwgc2l6ZSB8fFxuICAgICAgICAgICAgdGhpcy50b3RhbExpbWl0IC0gdGhpcy50b3RhbEFsbG9jYXRlZCA8IHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuc2V0KGNhbGxJZCwgY3VycmVudFBlckNhbGwgKyBzaXplKTtcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCArPSBzaXplO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnJlZShzaXplLCBjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50b3RhbEFsbG9jYXRlZCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCAtPSBzaXplO1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgaWYgKGN1cnJlbnRQZXJDYWxsIDwgc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBmcmVlZCAke3NpemV9ID4gYWxsb2NhdGVkIGZvciBjYWxsICR7Y3VycmVudFBlckNhbGx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsIC0gc2l6ZSk7XG4gICAgfVxuICAgIGZyZWVBbGwoY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsQWxsb2NhdGVkIDwgY3VycmVudFBlckNhbGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gYWxsb2NhdGVkICR7Y3VycmVudFBlckNhbGx9ID4gdG90YWwgYWxsb2NhdGVkICR7dGhpcy50b3RhbEFsbG9jYXRlZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkIC09IGN1cnJlbnRQZXJDYWxsO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZGVsZXRlKGNhbGxJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IE1lc3NhZ2VCdWZmZXJUcmFja2VyO1xuY29uc3QgUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSA9ICdncnBjLXByZXZpb3VzLXJwYy1hdHRlbXB0cyc7XG5jb25zdCBERUZBVUxUX01BWF9BVFRFTVBUU19MSU1JVCA9IDU7XG5jbGFzcyBSZXRyeWluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGNhbGxDb25maWcsIG1ldGhvZE5hbWUsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSwgY2FsbE51bWJlciwgYnVmZmVyVHJhY2tlciwgcmV0cnlUaHJvdHRsZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNhbGxDb25maWcgPSBjYWxsQ29uZmlnO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyID0gYnVmZmVyVHJhY2tlcjtcbiAgICAgICAgdGhpcy5yZXRyeVRocm90dGxlciA9IHJldHJ5VGhyb3R0bGVyO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscyA9IFtdO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2Zmc2V0IG9mIG1lc3NhZ2UgaW5kaWNlcyBpbiB0aGUgd3JpdGVCdWZmZXIuIEZvciBleGFtcGxlLCBpZlxuICAgICAgICAgKiB3cml0ZUJ1ZmZlck9mZnNldCBpcyAxMCwgbWVzc2FnZSAxMCBpcyBpbiB3cml0ZUJ1ZmZlclswXSBhbmQgbWVzc2FnZSAxNVxuICAgICAgICAgKiBpcyBpbiB3cml0ZUJ1ZmZlcls1XS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgYSByZWFkIGhhcyBiZWVuIHN0YXJ0ZWQsIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIHRvIHN0YXJ0XG4gICAgICAgICAqIHJlYWRzIG9uIG5ldyBjaGlsZCBjYWxscy4gVGhpcyBvbmx5IG1hdHRlcnMgZm9yIHRoZSBmaXJzdCByZWFkLCBiZWNhdXNlXG4gICAgICAgICAqIG9uY2UgYSBtZXNzYWdlIGNvbWVzIGluIHRoZSBjaGlsZCBjYWxsIGJlY29tZXMgY29tbWl0dGVkIGFuZCB0aGVyZSB3aWxsXG4gICAgICAgICAqIGJlIG5vIG5ldyBjaGlsZCBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHNvIGZhclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuaGVkZ2luZ1RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWMgPSAwO1xuICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSAwO1xuICAgICAgICBjb25zdCBtYXhBdHRlbXB0c0xpbWl0ID0gKF9hID0gY2hhbm5lbC5nZXRPcHRpb25zKClbJ2dycGMtbm9kZS5yZXRyeV9tYXhfYXR0ZW1wdHNfbGltaXQnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9NQVhfQVRURU1QVFNfTElNSVQ7XG4gICAgICAgIGlmIChjaGFubmVsLmdldE9wdGlvbnMoKVsnZ3JwYy5lbmFibGVfcmV0cmllcyddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ05PX1JFVFJZJztcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JFVFJZJztcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3k7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kuaW5pdGlhbEJhY2tvZmYuc3Vic3RyaW5nKDAsIHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBNYXRoLm1pbihyZXRyeVBvbGljeS5tYXhBdHRlbXB0cywgbWF4QXR0ZW1wdHNMaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBNYXRoLm1pbihjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCBtYXhBdHRlbXB0c0xpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgICAgICB0aGlzLm1heEF0dGVtcHRzID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lSW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYWRsaW5lSW5mbyA9IFtdO1xuICAgICAgICBjb25zdCBsYXRlc3RDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgcHJldmlvdXMgYXR0ZW1wdHM6ICR7dGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoIC0gMX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXN0Q2FsbC5zdGFydFRpbWUgPiB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYHRpbWUgdG8gY3VycmVudCBhdHRlbXB0IHN0YXJ0OiAkeygwLCBkZWFkbGluZV8xLmZvcm1hdERhdGVEaWZmZXJlbmNlKSh0aGlzLnN0YXJ0VGltZSwgbGF0ZXN0Q2FsbC5zdGFydFRpbWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKC4uLmxhdGVzdENhbGwuY2FsbC5nZXREZWFkbGluZUluZm8oKSk7XG4gICAgICAgIHJldHVybiBkZWFkbGluZUluZm87XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJlcG9ydFN0YXR1cyhzdGF0dXNPYmplY3QpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICBzdGF0dXNPYmplY3QuY29kZSArXG4gICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5kZXRhaWxzICtcbiAgICAgICAgICAgICdcIiBzdGFydCB0aW1lPScgK1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlci5mcmVlQWxsKHRoaXMuY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGNvbnN0cnVjdCBzdGF0dXMgb2JqZWN0IHRvIHJlbW92ZSBwcm9ncmVzcyBmaWVsZFxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogc3RhdHVzT2JqZWN0LmNvZGUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogc3RhdHVzT2JqZWN0LmRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1c09iamVjdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICAgICAgZm9yIChjb25zdCB7IGNhbGwgfSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLmNhbGwuZ2V0UGVlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMud3JpdGVCdWZmZXJbbWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0ZSRUVEJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0QnVmZmVySW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyU2VudE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XG4gICAgICAgICAgICAvKiBJZiB0aGUgY29tbWl0dGVkIGNhbGwgaXMgY29tcGxldGVkLCBjbGVhciBhbGwgbWVzc2FnZXMsIGV2ZW4gaWYgc29tZVxuICAgICAgICAgICAgICogaGF2ZSBub3QgYmVlbiBzZW50LiAqL1xuICAgICAgICAgICAgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXggPVxuICAgICAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtZXNzYWdlSW5kZXggPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0OyBtZXNzYWdlSW5kZXggPCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDsgbWVzc2FnZUluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckVudHJ5LmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlci5mcmVlKGJ1ZmZlckVudHJ5Lm1lc3NhZ2UubWVzc2FnZS5sZW5ndGgsIHRoaXMuY2FsbE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXggLSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4O1xuICAgIH1cbiAgICBjb21taXRDYWxsKGluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ0NvbW1pdHRpbmcgY2FsbCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uY2FsbC5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnQ09NTUlUVEVEJztcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKS5vbkNvbW1pdHRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLnN0YXRlID0gJ0NPTVBMRVRFRCc7XG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0Rpc2NhcmRlZCBpbiBmYXZvciBvZiBvdGhlciBoZWRnZWQgYXR0ZW1wdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJTZW50TWVzc2FnZXMoKTtcbiAgICB9XG4gICAgY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb3N0TWVzc2FnZXMgPSAtMTtcbiAgICAgICAgbGV0IGNhbGxXaXRoTW9zdE1lc3NhZ2VzID0gLTE7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZENhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkQ2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiZcbiAgICAgICAgICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPiBtb3N0TWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBtb3N0TWVzc2FnZXMgPSBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQ7XG4gICAgICAgICAgICAgICAgY2FsbFdpdGhNb3N0TWVzc2FnZXMgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbFdpdGhNb3N0TWVzc2FnZXMgPT09IC0xKSB7XG4gICAgICAgICAgICAvKiBUaGVyZSBhcmUgbm8gYWN0aXZlIGNhbGxzLCBkaXNhYmxlIHJldHJpZXMgdG8gZm9yY2UgdGhlIG5leHQgY2FsbCB0aGF0XG4gICAgICAgICAgICAgKiBpcyBzdGFydGVkIHRvIGJlIGNvbW1pdHRlZC4gKi9cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbFdpdGhNb3N0TWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzU3RhdHVzQ29kZUluTGlzdChsaXN0LCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBsaXN0LnNvbWUodmFsdWUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjb2RlIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAoKF9hID0gY29uc3RhbnRzXzEuU3RhdHVzW2NvZGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0UmV0cnlKaXR0ZXIoKSB7XG4gICAgICAgIC8qIEppdHRlciBvZiArLTIwJSBpcyBhcHBsaWVkOiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BNi1jbGllbnQtcmV0cmllcy5tZCNleHBvbmVudGlhbC1iYWNrb2ZmICovXG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKDEuMiAtIDAuOCkgKyAwLjg7XG4gICAgfVxuICAgIGdldE5leHRSZXRyeUJhY2tvZmZNcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKCFyZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgaml0dGVyID0gdGhpcy5nZXROZXh0UmV0cnlKaXR0ZXIoKTtcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmZNcyA9IGppdHRlciAqIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG1heEJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kubWF4QmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kubWF4QmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IE1hdGgubWluKHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIHJldHJ5UG9saWN5LmJhY2tvZmZNdWx0aXBsaWVyLCBtYXhCYWNrb2ZmU2VjKTtcbiAgICAgICAgcmV0dXJuIG5leHRCYWNrb2ZmTXM7XG4gICAgfVxuICAgIG1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IHRoaXMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlEZWxheU1zO1xuICAgICAgICBpZiAocHVzaGJhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHRoaXMuZ2V0TmV4dFJldHJ5QmFja29mZk1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0cnlEZWxheU1zID0gcHVzaGJhY2s7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWM7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdSRVRSWScpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5SZXRyeUNhbGwoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmV0cnkgYXR0ZW1wdCBkZW5pZWQgYnkgdGhyb3R0bGluZyBwb2xpY3knKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHJldHJ5RGVsYXlNcyk7XG4gICAgfVxuICAgIGNvdW50QWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBoYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0NPTU1JVFRFRCc6XG4gICAgICAgICAgICBjYXNlICdOT19SRVRSWSc6XG4gICAgICAgICAgICBjYXNlICdUUkFOU1BBUkVOVF9PTkxZJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSEVER0lORyc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KChfYSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeS5ub25GYXRhbFN0YXR1c0NvZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWxheU1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVzaGJhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSBwdXNoYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhZnRlciB0cnlpbmcgdG8gc3RhcnQgYSBjYWxsIHRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMsIHRoaXMgd2FzIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRBY3RpdmVDYWxscygpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSRVRSWSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3kucmV0cnlhYmxlU3RhdHVzQ29kZXMsIHN0YXR1cy5jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCByZXRyaWVkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0cmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFB1c2hiYWNrKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1kVmFsdWUgPSBtZXRhZGF0YS5nZXQoJ2dycGMtcmV0cnktcHVzaGJhY2stbXMnKTtcbiAgICAgICAgaWYgKG1kVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1kVmFsdWVbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdzdGF0ZT0nICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgK1xuICAgICAgICAgICAgJyBoYW5kbGluZyBzdGF0dXMgd2l0aCBwcm9ncmVzcyAnICtcbiAgICAgICAgICAgIHN0YXR1cy5wcm9ncmVzcyArXG4gICAgICAgICAgICAnIGZyb20gY2hpbGQgWycgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5jYWxsLmdldENhbGxOdW1iZXIoKSArXG4gICAgICAgICAgICAnXSBpbiBzdGF0ZSAnICtcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUpO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID0gJ0NPTVBMRVRFRCc7XG4gICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnTk9fUkVUUlknKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hiYWNrID0gdGhpcy5nZXRQdXNoYmFjayhzdGF0dXMubWV0YWRhdGEpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY2FzZSAnTk9UX1NUQVJURUQnOlxuICAgICAgICAgICAgICAgIC8vIFJQQyBuZXZlciBsZWF2ZXMgdGhlIGNsaWVudCwgYWx3YXlzIHNhZmUgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUkVGVVNFRCc6XG4gICAgICAgICAgICAgICAgLy8gUlBDIHJlYWNoZXMgdGhlIHNlcnZlciBsaWJyYXJ5LCBidXQgbm90IHRoZSBzZXJ2ZXIgYXBwbGljYXRpb24gbG9naWNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST0NFU1NFRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnSEVER0lORycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IHRoaXMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xuICAgIH1cbiAgICBtYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMuaGVkZ2luZ1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWRnaW5nVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnSEVER0lORycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdQb2xpY3kgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3k7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IHRoaXMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTdHJpbmcgPSAoX2EgPSBoZWRnaW5nUG9saWN5LmhlZGdpbmdEZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJzBzJztcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U2VjID0gTnVtYmVyKGhlZGdpbmdEZWxheVN0cmluZy5zdWJzdHJpbmcoMCwgaGVkZ2luZ0RlbGF5U3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCk7XG4gICAgICAgIH0sIGhlZGdpbmdEZWxheVNlYyAqIDEwMDApO1xuICAgICAgICAoX2MgPSAoX2IgPSB0aGlzLmhlZGdpbmdUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICB9XG4gICAgc3RhcnROZXdBdHRlbXB0KCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hhbm5lbC5jcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCh0aGlzLmNhbGxDb25maWcsIHRoaXMubWV0aG9kTmFtZSwgdGhpcy5ob3N0LCB0aGlzLmNyZWRlbnRpYWxzLCB0aGlzLmRlYWRsaW5lKTtcbiAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBjYWxsIFsnICtcbiAgICAgICAgICAgIGNoaWxkLmdldENhbGxOdW1iZXIoKSArXG4gICAgICAgICAgICAnXSBmb3IgYXR0ZW1wdCAnICtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICBzdGF0ZTogJ0FDVElWRScsXG4gICAgICAgICAgICBjYWxsOiBjaGlsZCxcbiAgICAgICAgICAgIG5leHRNZXNzYWdlVG9TZW5kOiAwLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBdHRlbXB0cyA9IHRoaXMuYXR0ZW1wdHMgLSAxO1xuICAgICAgICBjb25zdCBpbml0aWFsTWV0YWRhdGEgPSB0aGlzLmluaXRpYWxNZXRhZGF0YS5jbG9uZSgpO1xuICAgICAgICBpZiAocHJldmlvdXNBdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxNZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjZWl2ZWRNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBjaGlsZC5zdGFydChpbml0aWFsTWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNBdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uc3RhdGUgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXRhZGF0YSAmJiBwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kTmV4dENoaWxkTWVzc2FnZShpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLnJlYWRTdGFydGVkKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5pbml0aWFsTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nVGltZXIoKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQ7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KSkuY2FsbGJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xuICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgdGhpcy5zZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KTtcbiAgICB9XG4gICAgc2VuZE5leHRDaGlsZE1lc3NhZ2UoY2hpbGRJbmRleCkge1xuICAgICAgICBjb25zdCBjaGlsZENhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1tjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkQ2FsbC5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkoY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyRW50cnkuZW50cnlUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTUVTU0FHRSc6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdIQUxGX0NMT1NFJzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdGUkVFRCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCB3cml0ZU9iaiA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBmbGFnczogY29udGV4dC5mbGFncyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRW50cnkgPSB7XG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdNRVNTQUdFJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHdyaXRlT2JqLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiB0aGlzLmJ1ZmZlclRyYWNrZXIuYWxsb2NhdGUobWVzc2FnZS5sZW5ndGgsIHRoaXMuY2FsbE51bWJlciksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChidWZmZXJFbnRyeSk7XG4gICAgICAgIGlmIChidWZmZXJFbnRyeS5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIChfYSA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2FsbEluZGV4LCBjYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiZcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAvLyBjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcyBjYW4gZmFpbCBpZiB3ZSBhcmUgYmV0d2VlbiBwaW5nIGF0dGVtcHRzXG4gICAgICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdO1xuICAgICAgICAgICAgYnVmZmVyRW50cnkuY2FsbGJhY2sgPSBjb250ZXh0LmNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IG1lc3NhZ2VJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgdW5kZXJseWluZ0NhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcbiAgICAgICAgICAgIGlmICgodW5kZXJseWluZ0NhbGwgPT09IG51bGwgfHwgdW5kZXJseWluZ0NhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuZGVybHlpbmdDYWxsLnN0YXRlKSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICB1bmRlcmx5aW5nQ2FsbC5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBjb25zdCBoYWxmQ2xvc2VJbmRleCA9IHRoaXMuZ2V0TmV4dEJ1ZmZlckluZGV4KCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaCh7XG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdIQUxGX0NMT1NFJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcbiAgICAgICAgICAgIGlmICgoY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnN0YXRlKSA9PT0gJ0FDVElWRScgJiZcbiAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBoYWxmQ2xvc2VJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICBjYWxsLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMobmV3Q3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZE5hbWU7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF0uY2FsbC5nZXRBdXRoQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IFJldHJ5aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5aW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nexports.serverErrorToStatus = serverErrorToStatus;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction serverErrorToStatus(error, overrideTrailers) {\n    var _a;\n    const status = {\n        code: constants_1.Status.UNKNOWN,\n        details: 'message' in error ? error.message : 'Unknown Error',\n        metadata: (_a = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a !== void 0 ? _a : null,\n    };\n    if ('code' in error &&\n        typeof error.code === 'number' &&\n        Number.isInteger(error.code)) {\n        status.code = error.code;\n        if ('details' in error && typeof error.details === 'string') {\n            status.details = error.details;\n        }\n    }\n    return status;\n}\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(path, call, metadata, request) {\n        super();\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    getAuthContext() {\n        return this.call.getAuthContext();\n    }\n    getMetricsRecorder() {\n        return this.call.getMetricsRecorder();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(path, call, metadata) {\n        super({ objectMode: true });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.cancelled = false;\n    }\n    _read(size) {\n        this.call.startRead();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    getAuthContext() {\n        return this.call.getAuthContext();\n    }\n    getMetricsRecorder() {\n        return this.call.getMetricsRecorder();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(path, call, metadata, request) {\n        super({ objectMode: true });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.pendingStatus = {\n            code: constants_1.Status.OK,\n            details: 'OK',\n        };\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.on('error', err => {\n            this.pendingStatus = serverErrorToStatus(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    getAuthContext() {\n        return this.call.getAuthContext();\n    }\n    getMetricsRecorder() {\n        return this.call.getMetricsRecorder();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        this.call.sendMessage(chunk, callback);\n    }\n    _final(callback) {\n        var _a;\n        callback(null);\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(path, call, metadata) {\n        super({ objectMode: true });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.pendingStatus = {\n            code: constants_1.Status.OK,\n            details: 'OK',\n        };\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.on('error', err => {\n            this.pendingStatus = serverErrorToStatus(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    getAuthContext() {\n        return this.call.getAuthContext();\n    }\n    getMetricsRecorder() {\n        return this.call.getMetricsRecorder();\n    }\n    _read(size) {\n        this.call.startRead();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        this.call.sendMessage(chunk, callback);\n    }\n    _final(callback) {\n        var _a;\n        callback(null);\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQjtBQUNsSSwyQkFBMkI7QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQseUJBQXlCLHFHQUFxRztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5QkFBeUIscUdBQXFHO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcz9jZWI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJVbmFyeUNhbGxJbXBsID0gdm9pZCAwO1xuZXhwb3J0cy5zZXJ2ZXJFcnJvclRvU3RhdHVzID0gc2VydmVyRXJyb3JUb1N0YXR1cztcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gc2VydmVyRXJyb3JUb1N0YXR1cyhlcnJvciwgb3ZlcnJpZGVUcmFpbGVycykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICBkZXRhaWxzOiAnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gRXJyb3InLFxuICAgICAgICBtZXRhZGF0YTogKF9hID0gb3ZlcnJpZGVUcmFpbGVycyAhPT0gbnVsbCAmJiBvdmVycmlkZVRyYWlsZXJzICE9PSB2b2lkIDAgPyBvdmVycmlkZVRyYWlsZXJzIDogZXJyb3IubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoJ2NvZGUnIGluIGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGVycm9yLmNvZGUpKSB7XG4gICAgICAgIHN0YXR1cy5jb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgaWYgKCdkZXRhaWxzJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IuZGV0YWlscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gZXJyb3IuZGV0YWlscztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdHVzO1xufVxuY2xhc3MgU2VydmVyVW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRIb3N0KCk7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEF1dGhDb250ZXh0KCk7XG4gICAgfVxuICAgIGdldE1ldHJpY3NSZWNvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRNZXRyaWNzUmVjb3JkZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSBTZXJ2ZXJVbmFyeUNhbGxJbXBsO1xuY2xhc3MgU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBfcmVhZChzaXplKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0SG9zdCgpO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRBdXRoQ29udGV4dCgpO1xuICAgIH1cbiAgICBnZXRNZXRyaWNzUmVjb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0TWV0cmljc1JlY29yZGVyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHNlcnZlckVycm9yVG9TdGF0dXMoZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRIb3N0KCk7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEF1dGhDb250ZXh0KCk7XG4gICAgfVxuICAgIGdldE1ldHJpY3NSZWNvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRNZXRyaWNzUmVjb3JkZXIoKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1lc3NhZ2UoY2h1bmssIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wZW5kaW5nU3RhdHVzKSwgeyBtZXRhZGF0YTogKF9hID0gdGhpcy5wZW5kaW5nU3RhdHVzLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgfSkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIFNlcnZlckR1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBzZXJ2ZXJFcnJvclRvU3RhdHVzKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0SG9zdCgpO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRBdXRoQ29udGV4dCgpO1xuICAgIH1cbiAgICBnZXRNZXRyaWNzUmVjb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0TWV0cmljc1JlY29yZGVyKCk7XG4gICAgfVxuICAgIF9yZWFkKHNpemUpIHtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZShjaHVuaywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBfZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRTdGF0dXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBlbmRpbmdTdGF0dXMpLCB7IG1ldGFkYXRhOiAoX2EgPSB0aGlzLnBlbmRpbmdTdGF0dXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudHJhaWxpbmdNZXRhZGF0YSB9KSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IFNlcnZlckR1cGxleFN0cmVhbUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerCredentials = void 0;\nexports.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;\nexports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    constructor(serverConstructorOptions, contextOptions) {\n        this.serverConstructorOptions = serverConstructorOptions;\n        this.watchers = new Set();\n        this.latestContextOptions = null;\n        this.latestContextOptions = contextOptions !== null && contextOptions !== void 0 ? contextOptions : null;\n    }\n    _addWatcher(watcher) {\n        this.watchers.add(watcher);\n    }\n    _removeWatcher(watcher) {\n        this.watchers.delete(watcher);\n    }\n    getWatcherCount() {\n        return this.watchers.size;\n    }\n    updateSecureContextOptions(options) {\n        this.latestContextOptions = options;\n        for (const watcher of this.watchers) {\n            watcher(this.latestContextOptions);\n        }\n    }\n    _isSecure() {\n        return this.serverConstructorOptions !== null;\n    }\n    _getSecureContextOptions() {\n        return this.latestContextOptions;\n    }\n    _getConstructorOptions() {\n        return this.serverConstructorOptions;\n    }\n    _getInterceptors() {\n        return [];\n    }\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        var _a;\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError('rootCerts must be null or a Buffer');\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError('keyCertPairs must be an array');\n        }\n        if (typeof checkClientCertificate !== 'boolean') {\n            throw new TypeError('checkClientCertificate must be a boolean');\n        }\n        const cert = [];\n        const key = [];\n        for (let i = 0; i < keyCertPairs.length; i++) {\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== 'object') {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        }, {\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            cert,\n            key,\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    constructor() {\n        super(null);\n    }\n    _getSettings() {\n        return null;\n    }\n    _equals(other) {\n        return other instanceof InsecureServerCredentials;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(constructorOptions, contextOptions) {\n        super(constructorOptions, contextOptions);\n        this.options = Object.assign(Object.assign({}, constructorOptions), contextOptions);\n    }\n    /**\n     * Checks equality by checking the options that are actually set by\n     * createSsl.\n     * @param other\n     * @returns\n     */\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof SecureServerCredentials)) {\n            return false;\n        }\n        // options.ca equality check\n        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {\n            if (!this.options.ca.equals(other.options.ca)) {\n                return false;\n            }\n        }\n        else {\n            if (this.options.ca !== other.options.ca) {\n                return false;\n            }\n        }\n        // options.cert equality check\n        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {\n            if (this.options.cert.length !== other.options.cert.length) {\n                return false;\n            }\n            for (let i = 0; i < this.options.cert.length; i++) {\n                const thisCert = this.options.cert[i];\n                const otherCert = other.options.cert[i];\n                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {\n                    if (!thisCert.equals(otherCert)) {\n                        return false;\n                    }\n                }\n                else {\n                    if (thisCert !== otherCert) {\n                        return false;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.options.cert !== other.options.cert) {\n                return false;\n            }\n        }\n        // options.key equality check\n        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {\n            if (this.options.key.length !== other.options.key.length) {\n                return false;\n            }\n            for (let i = 0; i < this.options.key.length; i++) {\n                const thisKey = this.options.key[i];\n                const otherKey = other.options.key[i];\n                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {\n                    if (!thisKey.equals(otherKey)) {\n                        return false;\n                    }\n                }\n                else {\n                    if (thisKey !== otherKey) {\n                        return false;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.options.key !== other.options.key) {\n                return false;\n            }\n        }\n        // options.requestCert equality check\n        if (this.options.requestCert !== other.options.requestCert) {\n            return false;\n        }\n        /* ciphers is derived from a value that is constant for the process, so no\n         * equality check is needed. */\n        return true;\n    }\n}\nclass CertificateProviderServerCredentials extends ServerCredentials {\n    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {\n        super({\n            requestCert: caCertificateProvider !== null,\n            rejectUnauthorized: requireClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        this.identityCertificateProvider = identityCertificateProvider;\n        this.caCertificateProvider = caCertificateProvider;\n        this.requireClientCertificate = requireClientCertificate;\n        this.latestCaUpdate = null;\n        this.latestIdentityUpdate = null;\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n    }\n    _addWatcher(watcher) {\n        var _a;\n        if (this.getWatcherCount() === 0) {\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.addCaCertificateListener(this.caCertificateUpdateListener);\n            this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n        super._addWatcher(watcher);\n    }\n    _removeWatcher(watcher) {\n        var _a;\n        super._removeWatcher(watcher);\n        if (this.getWatcherCount() === 0) {\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeCaCertificateListener(this.caCertificateUpdateListener);\n            this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof CertificateProviderServerCredentials)) {\n            return false;\n        }\n        return (this.caCertificateProvider === other.caCertificateProvider &&\n            this.identityCertificateProvider === other.identityCertificateProvider &&\n            this.requireClientCertificate === other.requireClientCertificate);\n    }\n    calculateSecureContextOptions() {\n        var _a;\n        if (this.latestIdentityUpdate === null) {\n            return null;\n        }\n        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {\n            return null;\n        }\n        return {\n            ca: (_a = this.latestCaUpdate) === null || _a === void 0 ? void 0 : _a.caCertificate,\n            cert: [this.latestIdentityUpdate.certificate],\n            key: [this.latestIdentityUpdate.privateKey],\n        };\n    }\n    finalizeUpdate() {\n        const secureContextOptions = this.calculateSecureContextOptions();\n        this.updateSecureContextOptions(secureContextOptions);\n    }\n    handleCaCertificateUpdate(update) {\n        this.latestCaUpdate = update;\n        this.finalizeUpdate();\n    }\n    handleIdentityCertitificateUpdate(update) {\n        this.latestIdentityUpdate = update;\n        this.finalizeUpdate();\n    }\n}\nfunction createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {\n    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);\n}\nclass InterceptorServerCredentials extends ServerCredentials {\n    constructor(childCredentials, interceptors) {\n        super({});\n        this.childCredentials = childCredentials;\n        this.interceptors = interceptors;\n    }\n    _isSecure() {\n        return this.childCredentials._isSecure();\n    }\n    _equals(other) {\n        if (!(other instanceof InterceptorServerCredentials)) {\n            return false;\n        }\n        if (!(this.childCredentials._equals(other.childCredentials))) {\n            return false;\n        }\n        if (this.interceptors.length !== other.interceptors.length) {\n            return false;\n        }\n        for (let i = 0; i < this.interceptors.length; i++) {\n            if (this.interceptors[i] !== other.interceptors[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _getInterceptors() {\n        return this.interceptors;\n    }\n    _addWatcher(watcher) {\n        this.childCredentials._addWatcher(watcher);\n    }\n    _removeWatcher(watcher) {\n        this.childCredentials._removeWatcher(watcher);\n    }\n    _getConstructorOptions() {\n        return this.childCredentials._getConstructorOptions();\n    }\n    _getSecureContextOptions() {\n        return this.childCredentials._getSecureContextOptions();\n    }\n}\nfunction createServerCredentialsWithInterceptors(credentials, interceptors) {\n    return new InterceptorServerCredentials(credentials, interceptors);\n}\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsa0RBQWtEO0FBQ2xELCtDQUErQztBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanM/NzI1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzID0gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJDcmVkZW50aWFsc1dpdGhJbnRlcmNlcHRvcnMgPSBjcmVhdGVTZXJ2ZXJDcmVkZW50aWFsc1dpdGhJbnRlcmNlcHRvcnM7XG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XG5jbGFzcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyQ29uc3RydWN0b3JPcHRpb25zLCBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICB0aGlzLnNlcnZlckNvbnN0cnVjdG9yT3B0aW9ucyA9IHNlcnZlckNvbnN0cnVjdG9yT3B0aW9ucztcbiAgICAgICAgdGhpcy53YXRjaGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RDb250ZXh0T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29udGV4dE9wdGlvbnMgPSBjb250ZXh0T3B0aW9ucyAhPT0gbnVsbCAmJiBjb250ZXh0T3B0aW9ucyAhPT0gdm9pZCAwID8gY29udGV4dE9wdGlvbnMgOiBudWxsO1xuICAgIH1cbiAgICBfYWRkV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMud2F0Y2hlcnMuYWRkKHdhdGNoZXIpO1xuICAgIH1cbiAgICBfcmVtb3ZlV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMud2F0Y2hlcnMuZGVsZXRlKHdhdGNoZXIpO1xuICAgIH1cbiAgICBnZXRXYXRjaGVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhdGNoZXJzLnNpemU7XG4gICAgfVxuICAgIHVwZGF0ZVNlY3VyZUNvbnRleHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RDb250ZXh0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlciBvZiB0aGlzLndhdGNoZXJzKSB7XG4gICAgICAgICAgICB3YXRjaGVyKHRoaXMubGF0ZXN0Q29udGV4dE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29uc3RydWN0b3JPcHRpb25zICE9PSBudWxsO1xuICAgIH1cbiAgICBfZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdENvbnRleHRPcHRpb25zO1xuICAgIH1cbiAgICBfZ2V0Q29uc3RydWN0b3JPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnM7XG4gICAgfVxuICAgIF9nZXRJbnRlcmNlcHRvcnMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVNzbChyb290Q2VydHMsIGtleUNlcnRQYWlycywgY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3RDZXJ0cyBtdXN0IGJlIG51bGwgb3IgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5Q2VydFBhaXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q2VydFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xuICAgICAgICAgICAgaWYgKHBhaXIgPT09IG51bGwgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIucHJpdmF0ZV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0ucHJpdmF0ZV9rZXkgbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5jZXJ0X2NoYWluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLmNlcnRfY2hhaW4gbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VydC5wdXNoKHBhaXIuY2VydF9jaGFpbik7XG4gICAgICAgICAgICBrZXkucHVzaChwYWlyLnByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjaGVja0NsaWVudENlcnRpZmljYXRlLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IFNlcnZlckNyZWRlbnRpYWxzO1xuY2xhc3MgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscztcbiAgICB9XG59XG5jbGFzcyBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvck9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNvbnN0cnVjdG9yT3B0aW9ucywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cnVjdG9yT3B0aW9ucyksIGNvbnRleHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGVxdWFsaXR5IGJ5IGNoZWNraW5nIHRoZSBvcHRpb25zIHRoYXQgYXJlIGFjdHVhbGx5IHNldCBieVxuICAgICAqIGNyZWF0ZVNzbC5cbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGlvbnMuY2EgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLm9wdGlvbnMuY2EpICYmIEJ1ZmZlci5pc0J1ZmZlcihvdGhlci5vcHRpb25zLmNhKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2EuZXF1YWxzKG90aGVyLm9wdGlvbnMuY2EpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYSAhPT0gb3RoZXIub3B0aW9ucy5jYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zLmNlcnQgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmNlcnQpICYmIEFycmF5LmlzQXJyYXkob3RoZXIub3B0aW9ucy5jZXJ0KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZXJ0Lmxlbmd0aCAhPT0gb3RoZXIub3B0aW9ucy5jZXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzQ2VydCA9IHRoaXMub3B0aW9ucy5jZXJ0W2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2VydCA9IG90aGVyLm9wdGlvbnMuY2VydFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXNDZXJ0KSAmJiBCdWZmZXIuaXNCdWZmZXIob3RoZXJDZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNDZXJ0LmVxdWFscyhvdGhlckNlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ2VydCAhPT0gb3RoZXJDZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNlcnQgIT09IG90aGVyLm9wdGlvbnMuY2VydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zLmtleSBlcXVhbGl0eSBjaGVja1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMua2V5KSAmJiBBcnJheS5pc0FycmF5KG90aGVyLm9wdGlvbnMua2V5KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXkubGVuZ3RoICE9PSBvdGhlci5vcHRpb25zLmtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5rZXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzS2V5ID0gdGhpcy5vcHRpb25zLmtleVtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlcktleSA9IG90aGVyLm9wdGlvbnMua2V5W2ldO1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpc0tleSkgJiYgQnVmZmVyLmlzQnVmZmVyKG90aGVyS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNLZXkuZXF1YWxzKG90aGVyS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0tleSAhPT0gb3RoZXJLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5ICE9PSBvdGhlci5vcHRpb25zLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zLnJlcXVlc3RDZXJ0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWVzdENlcnQgIT09IG90aGVyLm9wdGlvbnMucmVxdWVzdENlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjaXBoZXJzIGlzIGRlcml2ZWQgZnJvbSBhIHZhbHVlIHRoYXQgaXMgY29uc3RhbnQgZm9yIHRoZSBwcm9jZXNzLCBzbyBub1xuICAgICAgICAgKiBlcXVhbGl0eSBjaGVjayBpcyBuZWVkZWQuICovXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmNsYXNzIENlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIGNhQ2VydGlmaWNhdGVQcm92aWRlciwgcmVxdWlyZUNsaWVudENlcnRpZmljYXRlKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjYUNlcnRpZmljYXRlUHJvdmlkZXIgIT09IG51bGwsXG4gICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFU1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgPSBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLnJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSA9IHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZTtcbiAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lciA9IHRoaXMuaGFuZGxlQ2FDZXJ0aWZpY2F0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lciA9IHRoaXMuaGFuZGxlSWRlbnRpdHlDZXJ0aXRpZmljYXRlVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIF9hZGRXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5nZXRXYXRjaGVyQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIuYWRkSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fYWRkV2F0Y2hlcih3YXRjaGVyKTtcbiAgICB9XG4gICAgX3JlbW92ZVdhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyLl9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpO1xuICAgICAgICBpZiAodGhpcy5nZXRXYXRjaGVyQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIucmVtb3ZlSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSA9PT0gb3RoZXIucmVxdWlyZUNsaWVudENlcnRpZmljYXRlKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciAhPT0gbnVsbCAmJiB0aGlzLmxhdGVzdENhVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2E6IChfYSA9IHRoaXMubGF0ZXN0Q2FVcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYUNlcnRpZmljYXRlLFxuICAgICAgICAgICAgY2VydDogW3RoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUuY2VydGlmaWNhdGVdLFxuICAgICAgICAgICAga2V5OiBbdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZS5wcml2YXRlS2V5XSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluYWxpemVVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNlY3VyZUNvbnRleHRPcHRpb25zID0gdGhpcy5jYWxjdWxhdGVTZWN1cmVDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlY3VyZUNvbnRleHRPcHRpb25zKHNlY3VyZUNvbnRleHRPcHRpb25zKTtcbiAgICB9XG4gICAgaGFuZGxlQ2FDZXJ0aWZpY2F0ZVVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZVVwZGF0ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVJZGVudGl0eUNlcnRpdGlmaWNhdGVVcGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMuZmluYWxpemVVcGRhdGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHMoY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSkge1xuICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzKGNhQ2VydGlmaWNhdGVQcm92aWRlciwgaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLCByZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUpO1xufVxuY2xhc3MgSW50ZXJjZXB0b3JTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZENyZWRlbnRpYWxzLCBpbnRlcmNlcHRvcnMpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLmNoaWxkQ3JlZGVudGlhbHMgPSBjaGlsZENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycyA9IGludGVyY2VwdG9ycztcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9pc1NlY3VyZSgpO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgSW50ZXJjZXB0b3JTZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLmNoaWxkQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jaGlsZENyZWRlbnRpYWxzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnRlcmNlcHRvcnMubGVuZ3RoICE9PSBvdGhlci5pbnRlcmNlcHRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmludGVyY2VwdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0b3JzW2ldICE9PSBvdGhlci5pbnRlcmNlcHRvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9nZXRJbnRlcmNlcHRvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVyY2VwdG9ycztcbiAgICB9XG4gICAgX2FkZFdhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLmNoaWxkQ3JlZGVudGlhbHMuX2FkZFdhdGNoZXIod2F0Y2hlcik7XG4gICAgfVxuICAgIF9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpO1xuICAgIH1cbiAgICBfZ2V0Q29uc3RydWN0b3JPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9nZXRDb25zdHJ1Y3Rvck9wdGlvbnMoKTtcbiAgICB9XG4gICAgX2dldFNlY3VyZUNvbnRleHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9nZXRTZWN1cmVDb250ZXh0T3B0aW9ucygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9ycyhjcmVkZW50aWFscywgaW50ZXJjZXB0b3JzKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcmNlcHRvclNlcnZlckNyZWRlbnRpYWxzKGNyZWRlbnRpYWxzLCBpbnRlcmNlcHRvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = void 0;\nexports.isInterceptingServerListener = isInterceptingServerListener;\nexports.getServerInterceptingCall = getServerInterceptingCall;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst orca_1 = __webpack_require__(/*! ./orca */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/orca.js\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nclass ServerListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveHalfClose(onReceiveHalfClose) {\n        this.halfClose = onReceiveHalfClose;\n        return this;\n    }\n    withOnCancel(onCancel) {\n        this.cancel = onCancel;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveHalfClose: this.halfClose,\n            onCancel: this.cancel,\n        };\n    }\n}\nexports.ServerListenerBuilder = ServerListenerBuilder;\nfunction isInterceptingServerListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nclass InterceptingServerListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        /**\n         * Once the call is cancelled, ignore all other events.\n         */\n        this.cancelled = false;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.pendingMessage = null;\n        this.processingMessage = false;\n        this.hasPendingHalfClose = false;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.hasPendingHalfClose) {\n            this.nextListener.onReceiveHalfClose();\n            this.hasPendingHalfClose = false;\n        }\n    }\n    onReceiveMetadata(metadata) {\n        if (this.cancelled) {\n            return;\n        }\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {\n            this.processingMetadata = false;\n            if (this.cancelled) {\n                return;\n            }\n            this.nextListener.onReceiveMetadata(interceptedMetadata);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    onReceiveMessage(message) {\n        if (this.cancelled) {\n            return;\n        }\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, msg => {\n            this.processingMessage = false;\n            if (this.cancelled) {\n                return;\n            }\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    onReceiveHalfClose() {\n        if (this.cancelled) {\n            return;\n        }\n        this.listener.onReceiveHalfClose(() => {\n            if (this.cancelled) {\n                return;\n            }\n            if (this.processingMetadata || this.processingMessage) {\n                this.hasPendingHalfClose = true;\n            }\n            else {\n                this.nextListener.onReceiveHalfClose();\n            }\n        });\n    }\n    onCancel() {\n        this.cancelled = true;\n        this.listener.onCancel();\n        this.nextListener.onCancel();\n    }\n}\nclass ResponderBuilder {\n    constructor() {\n        this.start = undefined;\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMetadata(sendMetadata) {\n        this.metadata = sendMetadata;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withSendStatus(sendStatus) {\n        this.status = sendStatus;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMetadata: this.metadata,\n            sendMessage: this.message,\n            sendStatus: this.status,\n        };\n    }\n}\nexports.ResponderBuilder = ResponderBuilder;\nconst defaultServerListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveHalfClose: next => {\n        next();\n    },\n    onCancel: () => { },\n};\nconst defaultResponder = {\n    start: next => {\n        next();\n    },\n    sendMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    sendStatus: (status, next) => {\n        next(status);\n    },\n};\nclass ServerInterceptingCall {\n    constructor(nextCall, responder) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        this.processingMetadata = false;\n        this.sentMetadata = false;\n        this.processingMessage = false;\n        this.pendingMessage = null;\n        this.pendingMessageCallback = null;\n        this.pendingStatus = null;\n        this.responder = {\n            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,\n            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,\n            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,\n            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus,\n        };\n    }\n    processPendingMessage() {\n        if (this.pendingMessageCallback) {\n            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);\n            this.pendingMessage = null;\n            this.pendingMessageCallback = null;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextCall.sendStatus(this.pendingStatus);\n            this.pendingStatus = null;\n        }\n    }\n    start(listener) {\n        this.responder.start(interceptedListener => {\n            var _a, _b, _c, _d;\n            const fullInterceptedListener = {\n                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,\n                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,\n                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,\n                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel,\n            };\n            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);\n            this.nextCall.start(finalInterceptingListener);\n        });\n    }\n    sendMetadata(metadata) {\n        this.processingMetadata = true;\n        this.sentMetadata = true;\n        this.responder.sendMetadata(metadata, interceptedMetadata => {\n            this.processingMetadata = false;\n            this.nextCall.sendMetadata(interceptedMetadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    sendMessage(message, callback) {\n        this.processingMessage = true;\n        if (!this.sentMetadata) {\n            this.sendMetadata(new metadata_1.Metadata());\n        }\n        this.responder.sendMessage(message, interceptedMessage => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = interceptedMessage;\n                this.pendingMessageCallback = callback;\n            }\n            else {\n                this.nextCall.sendMessage(interceptedMessage, callback);\n            }\n        });\n    }\n    sendStatus(status) {\n        this.responder.sendStatus(status, interceptedStatus => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = interceptedStatus;\n            }\n            else {\n                this.nextCall.sendStatus(interceptedStatus);\n            }\n        });\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    getDeadline() {\n        return this.nextCall.getDeadline();\n    }\n    getHost() {\n        return this.nextCall.getHost();\n    }\n    getAuthContext() {\n        return this.nextCall.getAuthContext();\n    }\n    getConnectionInfo() {\n        return this.nextCall.getConnectionInfo();\n    }\n    getMetricsRecorder() {\n        return this.nextCall.getMetricsRecorder();\n    }\n}\nexports.ServerInterceptingCall = ServerInterceptingCall;\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n    [GRPC_ENCODING_HEADER]: 'identity',\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass BaseServerInterceptingCall {\n    constructor(stream, headers, callEventTracker, handler, options) {\n        var _a, _b;\n        this.stream = stream;\n        this.callEventTracker = callEventTracker;\n        this.handler = handler;\n        this.listener = null;\n        this.deadlineTimer = null;\n        this.deadline = Infinity;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.cancelled = false;\n        this.metadataSent = false;\n        this.wantTrailers = false;\n        this.cancelNotified = false;\n        this.incomingEncoding = 'identity';\n        this.readQueue = [];\n        this.isReadPending = false;\n        this.receivedHalfClose = false;\n        this.streamEnded = false;\n        this.metricsRecorder = new orca_1.PerRequestMetricRecorder();\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' +\n                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            if (this.callEventTracker && !this.streamEnded) {\n                this.streamEnded = true;\n                this.callEventTracker.onStreamEnd(false);\n                this.callEventTracker.onCallEnd({\n                    code: constants_1.Status.CANCELLED,\n                    details: 'Stream closed before sending status',\n                    metadata: null,\n                });\n            }\n            this.notifyOnCancel();\n        });\n        this.stream.on('data', (data) => {\n            this.handleDataFrame(data);\n        });\n        this.stream.pause();\n        this.stream.on('end', () => {\n            this.handleEndEvent();\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n        this.host = (_a = headers[':authority']) !== null && _a !== void 0 ? _a : headers.host;\n        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace('Request to ' +\n                this.handler.path +\n                ' received headers ' +\n                JSON.stringify(metadata.toJSON()));\n        }\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            this.handleTimeoutHeader(timeoutHeader[0]);\n        }\n        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);\n        if (encodingHeader.length > 0) {\n            this.incomingEncoding = encodingHeader[0];\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(GRPC_TIMEOUT_HEADER);\n        metadata.remove(GRPC_ENCODING_HEADER);\n        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        this.metadata = metadata;\n        const socket = (_b = stream.session) === null || _b === void 0 ? void 0 : _b.socket;\n        this.connectionInfo = {\n            localAddress: socket === null || socket === void 0 ? void 0 : socket.localAddress,\n            localPort: socket === null || socket === void 0 ? void 0 : socket.localPort,\n            remoteAddress: socket === null || socket === void 0 ? void 0 : socket.remoteAddress,\n            remotePort: socket === null || socket === void 0 ? void 0 : socket.remotePort\n        };\n        this.shouldSendMetrics = !!options['grpc.server_call_metric_recording'];\n    }\n    handleTimeoutHeader(timeoutHeader) {\n        const match = timeoutHeader.toString().match(DEADLINE_REGEX);\n        if (match === null) {\n            const status = {\n                code: constants_1.Status.INTERNAL,\n                details: `Invalid ${GRPC_TIMEOUT_HEADER} value \"${timeoutHeader}\"`,\n                metadata: null,\n            };\n            // Wait for the constructor to complete before sending the error.\n            process.nextTick(() => {\n                this.sendStatus(status);\n            });\n            return;\n        }\n        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n        const now = new Date();\n        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n        this.deadlineTimer = setTimeout(() => {\n            const status = {\n                code: constants_1.Status.DEADLINE_EXCEEDED,\n                details: 'Deadline exceeded',\n                metadata: null,\n            };\n            this.sendStatus(status);\n        }, timeout);\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {\n            this.notifyOnCancel();\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    notifyOnCancel() {\n        if (this.cancelNotified) {\n            return;\n        }\n        this.cancelNotified = true;\n        this.cancelled = true;\n        process.nextTick(() => {\n            var _a;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();\n        });\n        if (this.deadlineTimer) {\n            clearTimeout(this.deadlineTimer);\n        }\n        // Flush incoming data frames\n        this.stream.resume();\n    }\n    /**\n     * A server handler can start sending messages without explicitly sending\n     * metadata. In that case, we need to send headers before sending any\n     * messages. This function does that if necessary.\n     */\n    maybeSendMetadata() {\n        if (!this.metadataSent) {\n            this.sendMetadata(new metadata_1.Metadata());\n        }\n    }\n    /**\n     * Serialize a message to a length-delimited byte string.\n     * @param value\n     * @returns\n     */\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        /* Note: response compression is currently not supported, so this\n         * compressed bit is always 0. */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message, encoding) {\n        const messageContents = message.subarray(5);\n        if (encoding === 'identity') {\n            return messageContents;\n        }\n        else if (encoding === 'deflate' || encoding === 'gzip') {\n            let decompresser;\n            if (encoding === 'deflate') {\n                decompresser = zlib.createInflate();\n            }\n            else {\n                decompresser = zlib.createGunzip();\n            }\n            return new Promise((resolve, reject) => {\n                let totalLength = 0;\n                const messageParts = [];\n                decompresser.on('data', (chunk) => {\n                    messageParts.push(chunk);\n                    totalLength += chunk.byteLength;\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n                        decompresser.destroy();\n                        reject({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n                        });\n                    }\n                });\n                decompresser.on('end', () => {\n                    resolve(Buffer.concat(messageParts));\n                });\n                decompresser.write(messageContents);\n                decompresser.end();\n            });\n        }\n        else {\n            return Promise.reject({\n                code: constants_1.Status.UNIMPLEMENTED,\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n            });\n        }\n    }\n    async decompressAndMaybePush(queueEntry) {\n        if (queueEntry.type !== 'COMPRESSED') {\n            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);\n        }\n        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed\n            ? this.incomingEncoding\n            : 'identity';\n        let decompressedMessage;\n        try {\n            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);\n        }\n        catch (err) {\n            this.sendStatus(err);\n            return;\n        }\n        try {\n            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);\n        }\n        catch (err) {\n            this.sendStatus({\n                code: constants_1.Status.INTERNAL,\n                details: `Error deserializing request: ${err.message}`,\n            });\n            return;\n        }\n        queueEntry.type = 'READABLE';\n        this.maybePushNextMessage();\n    }\n    maybePushNextMessage() {\n        if (this.listener &&\n            this.isReadPending &&\n            this.readQueue.length > 0 &&\n            this.readQueue[0].type !== 'COMPRESSED') {\n            this.isReadPending = false;\n            const nextQueueEntry = this.readQueue.shift();\n            if (nextQueueEntry.type === 'READABLE') {\n                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);\n            }\n            else {\n                // nextQueueEntry.type === 'HALF_CLOSE'\n                this.listener.onReceiveHalfClose();\n            }\n        }\n    }\n    handleDataFrame(data) {\n        var _a;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to ' +\n            this.handler.path +\n            ' received data frame of size ' +\n            data.length);\n        let rawMessages;\n        try {\n            rawMessages = this.decoder.write(data);\n        }\n        catch (e) {\n            this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });\n            return;\n        }\n        for (const messageBytes of rawMessages) {\n            this.stream.pause();\n            const queueEntry = {\n                type: 'COMPRESSED',\n                compressedMessage: messageBytes,\n                parsedMessage: null,\n            };\n            this.readQueue.push(queueEntry);\n            this.decompressAndMaybePush(queueEntry);\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();\n        }\n    }\n    handleEndEvent() {\n        this.readQueue.push({\n            type: 'HALF_CLOSE',\n            compressedMessage: null,\n            parsedMessage: null,\n        });\n        this.receivedHalfClose = true;\n        this.maybePushNextMessage();\n    }\n    start(listener) {\n        trace('Request to ' + this.handler.path + ' start called');\n        if (this.checkCancelled()) {\n            return;\n        }\n        this.listener = listener;\n        listener.onReceiveMetadata(this.metadata);\n    }\n    sendMetadata(metadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = metadata ? metadata.toHttp2Headers() : null;\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    sendMessage(message, callback) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        let response;\n        try {\n            response = this.serializeMessage(message);\n        }\n        catch (e) {\n            this.sendStatus({\n                code: constants_1.Status.INTERNAL,\n                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,\n                metadata: null,\n            });\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            response.length - 5 > this.maxSendMessageSize) {\n            this.sendStatus({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,\n                metadata: null,\n            });\n            return;\n        }\n        this.maybeSendMetadata();\n        trace('Request to ' +\n            this.handler.path +\n            ' sent data frame of size ' +\n            response.length);\n        this.stream.write(response, error => {\n            var _a;\n            if (error) {\n                this.sendStatus({\n                    code: constants_1.Status.INTERNAL,\n                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,\n                    metadata: null,\n                });\n                return;\n            }\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n            callback();\n        });\n    }\n    sendStatus(status) {\n        var _a, _b, _c;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' +\n            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[status.code] +\n            ' details: ' +\n            status.details);\n        const statusMetadata = (_c = (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.clone()) !== null && _c !== void 0 ? _c : new metadata_1.Metadata();\n        if (this.shouldSendMetrics) {\n            statusMetadata.set(orca_1.GRPC_METRICS_HEADER, this.metricsRecorder.serialize());\n        }\n        if (this.metadataSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once('wantTrailers', () => {\n                    if (this.callEventTracker && !this.streamEnded) {\n                        this.streamEnded = true;\n                        this.callEventTracker.onStreamEnd(true);\n                        this.callEventTracker.onCallEnd(status);\n                    }\n                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, statusMetadata.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.notifyOnCancel();\n                });\n                this.stream.end();\n            }\n            else {\n                this.notifyOnCancel();\n            }\n        }\n        else {\n            if (this.callEventTracker && !this.streamEnded) {\n                this.streamEnded = true;\n                this.callEventTracker.onStreamEnd(true);\n                this.callEventTracker.onCallEnd(status);\n            }\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), statusMetadata.toHttp2Headers());\n            this.stream.respond(trailersToSend, { endStream: true });\n            this.notifyOnCancel();\n        }\n    }\n    startRead() {\n        trace('Request to ' + this.handler.path + ' startRead called');\n        if (this.checkCancelled()) {\n            return;\n        }\n        this.isReadPending = true;\n        if (this.readQueue.length === 0) {\n            if (!this.receivedHalfClose) {\n                this.stream.resume();\n            }\n        }\n        else {\n            this.maybePushNextMessage();\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getHost() {\n        return this.host;\n    }\n    getAuthContext() {\n        var _a;\n        if (((_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket) instanceof tls_1.TLSSocket) {\n            const peerCertificate = this.stream.session.socket.getPeerCertificate();\n            return {\n                transportSecurityType: 'ssl',\n                sslPeerCertificate: peerCertificate.raw ? peerCertificate : undefined\n            };\n        }\n        else {\n            return {};\n        }\n    }\n    getConnectionInfo() {\n        return this.connectionInfo;\n    }\n    getMetricsRecorder() {\n        return this.metricsRecorder;\n    }\n}\nexports.BaseServerInterceptingCall = BaseServerInterceptingCall;\nfunction getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {\n    const methodDefinition = {\n        path: handler.path,\n        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',\n        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',\n        requestDeserialize: handler.deserialize,\n        responseSerialize: handler.serialize,\n    };\n    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);\n    return interceptors.reduce((call, interceptor) => {\n        return interceptor(methodDefinition, call);\n    }, baseCall);\n}\n//# sourceMappingURL=server-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItaW50ZXJjZXB0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsNkJBQTZCO0FBQzlILG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQywrRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCLFNBQVMsY0FBYztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRywyQkFBMkI7QUFDNUgseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTO0FBQzVGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBaUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQ0FBZ0M7QUFDeEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQixNQUFNLHdCQUF3QjtBQUN6RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0NBQW9DO0FBQzNGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFGQUFxRjtBQUNoSjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFGQUFxRjtBQUN0SixrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCLEdBQUcsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci1pbnRlcmNlcHRvcnMuanM/NDAzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyNCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVzcG9uZGVyQnVpbGRlciA9IGV4cG9ydHMuU2VydmVyTGlzdGVuZXJCdWlsZGVyID0gdm9pZCAwO1xuZXhwb3J0cy5pc0ludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVyID0gaXNJbnRlcmNlcHRpbmdTZXJ2ZXJMaXN0ZW5lcjtcbmV4cG9ydHMuZ2V0U2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IGdldFNlcnZlckludGVyY2VwdGluZ0NhbGw7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBvcmNhXzEgPSByZXF1aXJlKFwiLi9vcmNhXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyX2NhbGwnO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jbGFzcyBTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbmNlbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1ldGFkYXRhKG9uUmVjZWl2ZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVIYWxmQ2xvc2Uob25SZWNlaXZlSGFsZkNsb3NlKSB7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gb25SZWNlaXZlSGFsZkNsb3NlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aE9uQ2FuY2VsKG9uQ2FuY2VsKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gb25DYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcbiAgICAgICAgICAgIG9uQ2FuY2VsOiB0aGlzLmNhbmNlbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckxpc3RlbmVyQnVpbGRlciA9IFNlcnZlckxpc3RlbmVyQnVpbGRlcjtcbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nU2VydmVyTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEubGVuZ3RoID09PSAxKTtcbn1cbmNsYXNzIEludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVySW1wbCB7XG4gICAgY29uc3RydWN0b3IobGlzdGVuZXIsIG5leHRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogT25jZSB0aGUgY2FsbCBpcyBjYW5jZWxsZWQsIGlnbm9yZSBhbGwgb3RoZXIgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgaW50ZXJjZXB0ZWRNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEoaW50ZXJjZXB0ZWRNZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgbXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZUhhbGZDbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25DYW5jZWwoKTtcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25DYW5jZWwoKTtcbiAgICB9XG59XG5jbGFzcyBSZXNwb25kZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aFN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhTZW5kTWV0YWRhdGEoc2VuZE1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBzZW5kTWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZFN0YXR1cyhzZW5kU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc2VuZFN0YXR1cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBzZW5kTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc2VuZFN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZXNwb25kZXJCdWlsZGVyID0gUmVzcG9uZGVyQnVpbGRlcjtcbmNvbnN0IGRlZmF1bHRTZXJ2ZXJMaXN0ZW5lciA9IHtcbiAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZUhhbGZDbG9zZTogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxuICAgIG9uQ2FuY2VsOiAoKSA9PiB7IH0sXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbmRlciA9IHtcbiAgICBzdGFydDogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxuICAgIHNlbmRNZXRhZGF0YTogKG1ldGFkYXRhLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xuICAgIH0sXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBzZW5kU3RhdHVzOiAoc3RhdHVzLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoc3RhdHVzKTtcbiAgICB9LFxufTtcbmNsYXNzIFNlcnZlckludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKG5leHRDYWxsLCByZXNwb25kZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VudE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzcG9uZGVyID0ge1xuICAgICAgICAgICAgc3RhcnQ6IChfYSA9IHJlc3BvbmRlciA9PT0gbnVsbCB8fCByZXNwb25kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbmRlci5zdGFydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFJlc3BvbmRlci5zdGFydCxcbiAgICAgICAgICAgIHNlbmRNZXRhZGF0YTogKF9iID0gcmVzcG9uZGVyID09PSBudWxsIHx8IHJlc3BvbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uZGVyLnNlbmRNZXRhZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlc3BvbmRlci5zZW5kTWV0YWRhdGEsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKF9jID0gcmVzcG9uZGVyID09PSBudWxsIHx8IHJlc3BvbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uZGVyLnNlbmRNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVzcG9uZGVyLnNlbmRNZXNzYWdlLFxuICAgICAgICAgICAgc2VuZFN0YXR1czogKF9kID0gcmVzcG9uZGVyID09PSBudWxsIHx8IHJlc3BvbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uZGVyLnNlbmRTdGF0dXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRSZXNwb25kZXIuc2VuZFN0YXR1cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlKHRoaXMucGVuZGluZ01lc3NhZ2UsIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZFN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlc3BvbmRlci5zdGFydChpbnRlcmNlcHRlZExpc3RlbmVyID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRlZExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2EgPSBpbnRlcmNlcHRlZExpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGVkTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTZXJ2ZXJMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2IgPSBpbnRlcmNlcHRlZExpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGVkTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFNlcnZlckxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlOiAoX2MgPSBpbnRlcmNlcHRlZExpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGVkTGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0U2VydmVyTGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlLFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiAoX2QgPSBpbnRlcmNlcHRlZExpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGVkTGlzdGVuZXIub25DYW5jZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRTZXJ2ZXJMaXN0ZW5lci5vbkNhbmNlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbmV3IEludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVySW1wbChmdWxsSW50ZXJjZXB0ZWRMaXN0ZW5lciwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydChmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VudE1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNwb25kZXIuc2VuZE1ldGFkYXRhKG1ldGFkYXRhLCBpbnRlcmNlcHRlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXRhZGF0YShpbnRlcmNlcHRlZE1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnNlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNwb25kZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgaW50ZXJjZXB0ZWRNZXNzYWdlID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBpbnRlcmNlcHRlZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlKGludGVyY2VwdGVkTWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5yZXNwb25kZXIuc2VuZFN0YXR1cyhzdGF0dXMsIGludGVyY2VwdGVkU3RhdHVzID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gaW50ZXJjZXB0ZWRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRTdGF0dXMoaW50ZXJjZXB0ZWRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRIb3N0KCk7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRBdXRoQ29udGV4dCgpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0Q29ubmVjdGlvbkluZm8oKTtcbiAgICB9XG4gICAgZ2V0TWV0cmljc1JlY29yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRNZXRyaWNzUmVjb3JkZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsO1xuY29uc3QgR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtYWNjZXB0LWVuY29kaW5nJztcbmNvbnN0IEdSUENfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19NRVNTQUdFX0hFQURFUiA9ICdncnBjLW1lc3NhZ2UnO1xuY29uc3QgR1JQQ19TVEFUVVNfSEVBREVSID0gJ2dycGMtc3RhdHVzJztcbmNvbnN0IEdSUENfVElNRU9VVF9IRUFERVIgPSAnZ3JwYy10aW1lb3V0JztcbmNvbnN0IERFQURMSU5FX1JFR0VYID0gLyhcXGR7MSw4fSlcXHMqKFtITVNtdW5dKS87XG5jb25zdCBkZWFkbGluZVVuaXRzVG9NcyA9IHtcbiAgICBIOiAzNjAwMDAwLFxuICAgIE06IDYwMDAwLFxuICAgIFM6IDEwMDAsXG4gICAgbTogMSxcbiAgICB1OiAwLjAwMSxcbiAgICBuOiAwLjAwMDAwMSxcbn07XG5jb25zdCBkZWZhdWx0Q29tcHJlc3Npb25IZWFkZXJzID0ge1xuICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlbW92ZSB0aGVzZSBlbmNvZGluZyBoZWFkZXJzIGZyb20gdGhlIGRlZmF1bHQgcmVzcG9uc2VcbiAgICAvLyBvbmNlIGNvbXByZXNzaW9uIGlzIGludGVncmF0ZWQuXG4gICAgW0dSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eSxkZWZsYXRlLGd6aXAnLFxuICAgIFtHUlBDX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eScsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyA9IHtcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfT0ssXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nLFxufTtcbmNvbnN0IGRlZmF1bHRSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgd2FpdEZvclRyYWlsZXJzOiB0cnVlLFxufTtcbmNsYXNzIEJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlciA9IGNhbGxFdmVudFRyYWNrZXI7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbmNlbE5vdGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5jb21pbmdFbmNvZGluZyA9ICdpZGVudGl0eSc7XG4gICAgICAgIHRoaXMucmVhZFF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuaXNSZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY2VpdmVkSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRyaWNzUmVjb3JkZXIgPSBuZXcgb3JjYV8xLlBlclJlcXVlc3RNZXRyaWNSZWNvcmRlcigpO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciB0byBhdm9pZCB1bmNhdWdodCBlcnJvciBldmVudCBleGNlcHRpb25zLCBidXRcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG5vdGhpbmcgd2UgY2FuIHJlYXNvbmFibHkgZG8gaGVyZS4gQW55IGVycm9yIGV2ZW50IHNob3VsZFxuICAgICAgICAgICAgICogaGF2ZSBhIGNvcnJlc3BvbmRpbmcgY2xvc2UgZXZlbnQsIHdoaWNoIGhhbmRsZXMgZW1pdHRpbmcgdGhlIGNhbmNlbGxlZFxuICAgICAgICAgICAgICogZXZlbnQuIEFuZCB0aGUgc3RyZWFtIGlzIG5vdyBpbiBhIGJhZCBzdGF0ZSwgc28gd2UgY2FuJ3QgcmVhc29uYWJseVxuICAgICAgICAgICAgICogZXhwZWN0IHRvIGJlIGFibGUgdG8gc2VuZCBhbiBlcnJvciBvdmVyIGl0LiAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMuaGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpICtcbiAgICAgICAgICAgICAgICAnIHN0cmVhbSBjbG9zZWQgd2l0aCByc3RDb2RlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50VHJhY2tlciAmJiAhdGhpcy5zdHJlYW1FbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uQ2FsbEVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdTdHJlYW0gY2xvc2VkIGJlZm9yZSBzZW5kaW5nIHN0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhRnJhbWUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbmRFdmVudCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9zdCA9IChfYSA9IGhlYWRlcnNbJzphdXRob3JpdHknXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaGVhZGVycy5ob3N0O1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICAgICAnIHJlY2VpdmVkIGhlYWRlcnMgJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEudG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0SGVhZGVyID0gbWV0YWRhdGEuZ2V0KEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICBpZiAodGltZW91dEhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRpbWVvdXRIZWFkZXIodGltZW91dEhlYWRlclswXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmdIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19FTkNPRElOR19IRUFERVIpO1xuICAgICAgICBpZiAoZW5jb2RpbmdIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmNvbWluZ0VuY29kaW5nID0gZW5jb2RpbmdIZWFkZXJbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHNldmVyYWwgaGVhZGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19FTkNPRElOR19IRUFERVIpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQUNDRVBUX0VOQ09ESU5HKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfVEUpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IChfYiA9IHN0cmVhbS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29ja2V0O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25JbmZvID0ge1xuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQubG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYWxQb3J0OiBzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQubG9jYWxQb3J0LFxuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogc29ja2V0ID09PSBudWxsIHx8IHNvY2tldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICByZW1vdGVQb3J0OiBzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlUG9ydFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3VsZFNlbmRNZXRyaWNzID0gISFvcHRpb25zWydncnBjLnNlcnZlcl9jYWxsX21ldHJpY19yZWNvcmRpbmcnXTtcbiAgICB9XG4gICAgaGFuZGxlVGltZW91dEhlYWRlcih0aW1lb3V0SGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGltZW91dEhlYWRlci50b1N0cmluZygpLm1hdGNoKERFQURMSU5FX1JFR0VYKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBJbnZhbGlkICR7R1JQQ19USU1FT1VUX0hFQURFUn0gdmFsdWUgXCIke3RpbWVvdXRIZWFkZXJ9XCJgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb25zdHJ1Y3RvciB0byBjb21wbGV0ZSBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IuXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoK21hdGNoWzFdICogZGVhZGxpbmVVbml0c1RvTXNbbWF0Y2hbMl1dKSB8IDA7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBub3cuc2V0TWlsbGlzZWNvbmRzKG5vdy5nZXRNaWxsaXNlY29uZHMoKSArIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ0RlYWRsaW5lIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICAgIGNoZWNrQ2FuY2VsbGVkKCkge1xuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxuICAgICAgICAgKiBmaXJlcy4gVGhhdCBjcmVhdGVzIGEgcmFjZSBjb25kaXRpb24gdGhhdCB0aGlzIGNoZWNrIHdvcmtzIGFyb3VuZCAqL1xuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsbGVkICYmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcbiAgICB9XG4gICAgbm90aWZ5T25DYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbE5vdGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxOb3RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25DYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsdXNoIGluY29taW5nIGRhdGEgZnJhbWVzXG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNlcnZlciBoYW5kbGVyIGNhbiBzdGFydCBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhvdXQgZXhwbGljaXRseSBzZW5kaW5nXG4gICAgICogbWV0YWRhdGEuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBzZW5kIGhlYWRlcnMgYmVmb3JlIHNlbmRpbmcgYW55XG4gICAgICogbWVzc2FnZXMuIFRoaXMgZnVuY3Rpb24gZG9lcyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBtYXliZVNlbmRNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhU2VudCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGEgbWVzc2FnZSB0byBhIGxlbmd0aC1kZWxpbWl0ZWQgYnl0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzZXJpYWxpemVNZXNzYWdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0aGlzLmhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IG1lc3NhZ2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVMZW5ndGggKyA1KTtcbiAgICAgICAgLyogTm90ZTogcmVzcG9uc2UgY29tcHJlc3Npb24gaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQsIHNvIHRoaXNcbiAgICAgICAgICogY29tcHJlc3NlZCBiaXQgaXMgYWx3YXlzIDAuICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShieXRlTGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50cyA9IG1lc3NhZ2Uuc3ViYXJyYXkoNSk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnIHx8IGVuY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgIGxldCBkZWNvbXByZXNzZXI7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVHdW56aXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29tcHJlc3NBbmRNYXliZVB1c2gocXVldWVFbnRyeSkge1xuICAgICAgICBpZiAocXVldWVFbnRyeS50eXBlICE9PSAnQ09NUFJFU1NFRCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBxdWV1ZSBlbnRyeSB0eXBlOiAke3F1ZXVlRW50cnkudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gcXVldWVFbnRyeS5jb21wcmVzc2VkTWVzc2FnZS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkXG4gICAgICAgICAgICA/IHRoaXMuaW5jb21pbmdFbmNvZGluZ1xuICAgICAgICAgICAgOiAnaWRlbnRpdHknO1xuICAgICAgICBsZXQgZGVjb21wcmVzc2VkTWVzc2FnZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NNZXNzYWdlKHF1ZXVlRW50cnkuY29tcHJlc3NlZE1lc3NhZ2UsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZUVudHJ5LnBhcnNlZE1lc3NhZ2UgPSB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYEVycm9yIGRlc2VyaWFsaXppbmcgcmVxdWVzdDogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVFbnRyeS50eXBlID0gJ1JFQURBQkxFJztcbiAgICAgICAgdGhpcy5tYXliZVB1c2hOZXh0TWVzc2FnZSgpO1xuICAgIH1cbiAgICBtYXliZVB1c2hOZXh0TWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXIgJiZcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWUubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWVbMF0udHlwZSAhPT0gJ0NPTVBSRVNTRUQnKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRRdWV1ZUVudHJ5ID0gdGhpcy5yZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0UXVldWVFbnRyeS50eXBlID09PSAnUkVBREFCTEUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG5leHRRdWV1ZUVudHJ5LnBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFF1ZXVlRW50cnkudHlwZSA9PT0gJ0hBTEZfQ0xPU0UnXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEYXRhRnJhbWUoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICcgcmVjZWl2ZWQgZGF0YSBmcmFtZSBvZiBzaXplICcgK1xuICAgICAgICAgICAgZGF0YS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmF3TWVzc2FnZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByYXdNZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgZGV0YWlsczogZS5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZUJ5dGVzIG9mIHJhd01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc3QgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ09NUFJFU1NFRCcsXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZE1lc3NhZ2U6IG1lc3NhZ2VCeXRlcyxcbiAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVhZFF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICB0aGlzLmRlY29tcHJlc3NBbmRNYXliZVB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNhbGxFdmVudFRyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFbmRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5yZWFkUXVldWUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSEFMRl9DTE9TRScsXG4gICAgICAgICAgICBjb21wcmVzc2VkTWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2U6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlY2VpdmVkSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZVB1c2hOZXh0TWVzc2FnZSgpO1xuICAgIH1cbiAgICBzdGFydChsaXN0ZW5lcikge1xuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICsgdGhpcy5oYW5kbGVyLnBhdGggKyAnIHN0YXJ0IGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IG1ldGFkYXRhID8gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMpLCBjdXN0b20pO1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKGhlYWRlcnMsIGRlZmF1bHRSZXNwb25zZU9wdGlvbnMpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBFcnJvciBzZXJpYWxpemluZyByZXNwb25zZTogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICByZXNwb25zZS5sZW5ndGggLSA1ID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtyZXNwb25zZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZVNlbmRNZXRhZGF0YSgpO1xuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICcgc2VudCBkYXRhIGZyYW1lIG9mIHNpemUgJyArXG4gICAgICAgICAgICByZXNwb25zZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShyZXNwb25zZSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRXJyb3Igd3JpdGluZyBtZXNzYWdlOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuY2FsbEV2ZW50VHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZE1lc3NhZ2VTZW50KCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgJyBlbmRlZCB3aXRoIHN0YXR1cyBjb2RlOiAnICtcbiAgICAgICAgICAgIGNvbnN0YW50c18xLlN0YXR1c1tzdGF0dXMuY29kZV0gK1xuICAgICAgICAgICAgJyBkZXRhaWxzOiAnICtcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgY29uc3Qgc3RhdHVzTWV0YWRhdGEgPSAoX2MgPSAoX2IgPSBzdGF0dXMubWV0YWRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbG9uZSgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRTZW5kTWV0cmljcykge1xuICAgICAgICAgICAgc3RhdHVzTWV0YWRhdGEuc2V0KG9yY2FfMS5HUlBDX01FVFJJQ1NfSEVBREVSLCB0aGlzLm1ldHJpY3NSZWNvcmRlci5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFTZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FudFRyYWlsZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ3dhbnRUcmFpbGVycycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50VHJhY2tlciAmJiAhdGhpcy5zdHJlYW1FbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25TdHJlYW1FbmQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1cy5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXMuZGV0YWlscykgfSwgc3RhdHVzTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlbmRUcmFpbGVycyh0cmFpbGVyc1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T25DYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T25DYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudFRyYWNrZXIgJiYgIXRoaXMuc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25TdHJlYW1FbmQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJhaWxlcnMtb25seSByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBbR1JQQ19TVEFUVVNfSEVBREVSXTogc3RhdHVzLmNvZGUsIFtHUlBDX01FU1NBR0VfSEVBREVSXTogZW5jb2RlVVJJKHN0YXR1cy5kZXRhaWxzKSB9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgc3RhdHVzTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKHRyYWlsZXJzVG9TZW5kLCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T25DYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgKyB0aGlzLmhhbmRsZXIucGF0aCArICcgc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1JlYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY2VpdmVkSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlUHVzaE5leHRNZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSAoX2EgPSB0aGlzLnN0cmVhbS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29ja2V0O1xuICAgICAgICBpZiAoc29ja2V0ID09PSBudWxsIHx8IHNvY2tldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ja2V0LnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucmVtb3RlUG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhZGxpbmU7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGdldEF1dGhDb250ZXh0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zdHJlYW0uc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvY2tldCkgaW5zdGFuY2VvZiB0bHNfMS5UTFNTb2NrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRoaXMuc3RyZWFtLnNlc3Npb24uc29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRTZWN1cml0eVR5cGU6ICdzc2wnLFxuICAgICAgICAgICAgICAgIHNzbFBlZXJDZXJ0aWZpY2F0ZTogcGVlckNlcnRpZmljYXRlLnJhdyA/IHBlZXJDZXJ0aWZpY2F0ZSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbkluZm87XG4gICAgfVxuICAgIGdldE1ldHJpY3NSZWNvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0cmljc1JlY29yZGVyO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBCYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbDtcbmZ1bmN0aW9uIGdldFNlcnZlckludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JzLCBzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICBwYXRoOiBoYW5kbGVyLnBhdGgsXG4gICAgICAgIHJlcXVlc3RTdHJlYW06IGhhbmRsZXIudHlwZSA9PT0gJ2NsaWVudFN0cmVhbScgfHwgaGFuZGxlci50eXBlID09PSAnYmlkaScsXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtOiBoYW5kbGVyLnR5cGUgPT09ICdzZXJ2ZXJTdHJlYW0nIHx8IGhhbmRsZXIudHlwZSA9PT0gJ2JpZGknLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGhhbmRsZXIuZGVzZXJpYWxpemUsXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBoYW5kbGVyLnNlcmlhbGl6ZSxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDYWxsID0gbmV3IEJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsKHN0cmVhbSwgaGVhZGVycywgY2FsbEV2ZW50VHJhY2tlciwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGludGVyY2VwdG9ycy5yZWR1Y2UoKGNhbGwsIGludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRvcihtZXRob2REZWZpbml0aW9uLCBjYWxsKTtcbiAgICB9LCBiYXNlQ2FsbCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = 'server';\nconst kMaxAge = Buffer.from('max_age');\nfunction serverCallTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'server_call', text);\n}\nfunction noop() { }\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */\nfunction deprecate(message) {\n    return function (target, context) {\n        return util.deprecate(target, message);\n    };\n}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nlet Server = (() => {\n    var _a;\n    let _instanceExtraInitializers = [];\n    let _start_decorators;\n    return _a = class Server {\n            constructor(options) {\n                var _b, _c, _d, _e, _f, _g;\n                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\n                this.http2Servers = new Map();\n                this.sessionIdleTimeouts = new Map();\n                this.handlers = new Map();\n                this.sessions = new Map();\n                /**\n                 * This field only exists to ensure that the start method throws an error if\n                 * it is called twice, as it did previously.\n                 */\n                this.started = false;\n                this.shutdown = false;\n                this.serverAddressString = 'null';\n                // Channelz Info\n                this.channelzEnabled = true;\n                this.options = options !== null && options !== void 0 ? options : {};\n                if (this.options['grpc.enable_channelz'] === 0) {\n                    this.channelzEnabled = false;\n                    this.channelzTrace = new channelz_1.ChannelzTraceStub();\n                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n                }\n                else {\n                    this.channelzTrace = new channelz_1.ChannelzTrace();\n                    this.callTracker = new channelz_1.ChannelzCallTracker();\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n                }\n                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);\n                this.channelzTrace.addTrace('CT_INFO', 'Server created');\n                this.maxConnectionAgeMs =\n                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n                this.maxConnectionAgeGraceMs =\n                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\n                this.keepaliveTimeMs =\n                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\n                this.keepaliveTimeoutMs =\n                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\n                this.sessionIdleTimeout =\n                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\n                this.commonServerOptions = {\n                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n                };\n                if ('grpc-node.max_session_memory' in this.options) {\n                    this.commonServerOptions.maxSessionMemory =\n                        this.options['grpc-node.max_session_memory'];\n                }\n                else {\n                    /* By default, set a very large max session memory limit, to effectively\n                     * disable enforcement of the limit. Some testing indicates that Node's\n                     * behavior degrades badly when this limit is reached, so we solve that\n                     * by disabling the check entirely. */\n                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n                }\n                if ('grpc.max_concurrent_streams' in this.options) {\n                    this.commonServerOptions.settings = {\n                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n                    };\n                }\n                this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];\n                this.trace('Server constructed');\n            }\n            getChannelzInfo() {\n                return {\n                    trace: this.channelzTrace,\n                    callTracker: this.callTracker,\n                    listenerChildren: this.listenerChildrenTracker.getChildLists(),\n                    sessionChildren: this.sessionChildrenTracker.getChildLists(),\n                };\n            }\n            getChannelzSessionInfo(session) {\n                var _b, _c, _d;\n                const sessionInfo = this.sessions.get(session);\n                const sessionSocket = session.socket;\n                const remoteAddress = sessionSocket.remoteAddress\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\n                    : null;\n                const localAddress = sessionSocket.localAddress\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\n                    : null;\n                let tlsInfo;\n                if (session.encrypted) {\n                    const tlsSocket = sessionSocket;\n                    const cipherInfo = tlsSocket.getCipher();\n                    const certificate = tlsSocket.getCertificate();\n                    const peerCertificate = tlsSocket.getPeerCertificate();\n                    tlsInfo = {\n                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,\n                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                        remoteCertificate: peerCertificate && 'raw' in peerCertificate\n                            ? peerCertificate.raw\n                            : null,\n                    };\n                }\n                else {\n                    tlsInfo = null;\n                }\n                const socketInfo = {\n                    remoteAddress: remoteAddress,\n                    localAddress: localAddress,\n                    security: tlsInfo,\n                    remoteName: null,\n                    streamsStarted: sessionInfo.streamTracker.callsStarted,\n                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                    streamsFailed: sessionInfo.streamTracker.callsFailed,\n                    messagesSent: sessionInfo.messagesSent,\n                    messagesReceived: sessionInfo.messagesReceived,\n                    keepAlivesSent: sessionInfo.keepAlivesSent,\n                    lastLocalStreamCreatedTimestamp: null,\n                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,\n                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null,\n                };\n                return socketInfo;\n            }\n            trace(text) {\n                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n            }\n            keepaliveTrace(text) {\n                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);\n            }\n            addProtoService() {\n                throw new Error('Not implemented. Use addService() instead');\n            }\n            addService(service, implementation) {\n                if (service === null ||\n                    typeof service !== 'object' ||\n                    implementation === null ||\n                    typeof implementation !== 'object') {\n                    throw new Error('addService() requires two objects as arguments');\n                }\n                const serviceKeys = Object.keys(service);\n                if (serviceKeys.length === 0) {\n                    throw new Error('Cannot add an empty service to a server');\n                }\n                serviceKeys.forEach(name => {\n                    const attrs = service[name];\n                    let methodType;\n                    if (attrs.requestStream) {\n                        if (attrs.responseStream) {\n                            methodType = 'bidi';\n                        }\n                        else {\n                            methodType = 'clientStream';\n                        }\n                    }\n                    else {\n                        if (attrs.responseStream) {\n                            methodType = 'serverStream';\n                        }\n                        else {\n                            methodType = 'unary';\n                        }\n                    }\n                    let implFn = implementation[name];\n                    let impl;\n                    if (implFn === undefined && typeof attrs.originalName === 'string') {\n                        implFn = implementation[attrs.originalName];\n                    }\n                    if (implFn !== undefined) {\n                        impl = implFn.bind(implementation);\n                    }\n                    else {\n                        impl = getDefaultHandler(methodType, name);\n                    }\n                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n                    if (success === false) {\n                        throw new Error(`Method handler for ${attrs.path} already provided.`);\n                    }\n                });\n            }\n            removeService(service) {\n                if (service === null || typeof service !== 'object') {\n                    throw new Error('removeService() requires object as argument');\n                }\n                const serviceKeys = Object.keys(service);\n                serviceKeys.forEach(name => {\n                    const attrs = service[name];\n                    this.unregister(attrs.path);\n                });\n            }\n            bind(port, creds) {\n                throw new Error('Not implemented. Use bindAsync() instead');\n            }\n            /**\n             * This API is experimental, so API stability is not guaranteed across minor versions.\n             * @param boundAddress\n             * @returns\n             */\n            experimentalRegisterListenerToChannelz(boundAddress) {\n                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {\n                    return {\n                        localAddress: boundAddress,\n                        remoteAddress: null,\n                        security: null,\n                        remoteName: null,\n                        streamsStarted: 0,\n                        streamsSucceeded: 0,\n                        streamsFailed: 0,\n                        messagesSent: 0,\n                        messagesReceived: 0,\n                        keepAlivesSent: 0,\n                        lastLocalStreamCreatedTimestamp: null,\n                        lastRemoteStreamCreatedTimestamp: null,\n                        lastMessageSentTimestamp: null,\n                        lastMessageReceivedTimestamp: null,\n                        localFlowControlWindow: null,\n                        remoteFlowControlWindow: null,\n                    };\n                }, this.channelzEnabled);\n            }\n            experimentalUnregisterListenerFromChannelz(channelzRef) {\n                (0, channelz_1.unregisterChannelzRef)(channelzRef);\n            }\n            createHttp2Server(credentials) {\n                let http2Server;\n                if (credentials._isSecure()) {\n                    const constructorOptions = credentials._getConstructorOptions();\n                    const contextOptions = credentials._getSecureContextOptions();\n                    const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });\n                    let areCredentialsValid = contextOptions !== null;\n                    this.trace('Initial credentials valid: ' + areCredentialsValid);\n                    http2Server = http2.createSecureServer(secureServerOptions);\n                    http2Server.prependListener('connection', (socket) => {\n                        if (!areCredentialsValid) {\n                            this.trace('Dropped connection from ' + JSON.stringify(socket.address()) + ' due to unloaded credentials');\n                            socket.destroy();\n                        }\n                    });\n                    http2Server.on('secureConnection', (socket) => {\n                        /* These errors need to be handled by the user of Http2SecureServer,\n                         * according to https://github.com/nodejs/node/issues/35824 */\n                        socket.on('error', (e) => {\n                            this.trace('An incoming TLS connection closed with error: ' + e.message);\n                        });\n                    });\n                    const credsWatcher = options => {\n                        if (options) {\n                            const secureServer = http2Server;\n                            try {\n                                secureServer.setSecureContext(options);\n                            }\n                            catch (e) {\n                                logging.log(constants_1.LogVerbosity.ERROR, 'Failed to set secure context with error ' + e.message);\n                                options = null;\n                            }\n                        }\n                        areCredentialsValid = options !== null;\n                        this.trace('Post-update credentials valid: ' + areCredentialsValid);\n                    };\n                    credentials._addWatcher(credsWatcher);\n                    http2Server.on('close', () => {\n                        credentials._removeWatcher(credsWatcher);\n                    });\n                }\n                else {\n                    http2Server = http2.createServer(this.commonServerOptions);\n                }\n                http2Server.setTimeout(0, noop);\n                this._setupHandlers(http2Server, credentials._getInterceptors());\n                return http2Server;\n            }\n            bindOneAddress(address, boundPortObject) {\n                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n                const http2Server = this.createHttp2Server(boundPortObject.credentials);\n                return new Promise((resolve, reject) => {\n                    const onError = (err) => {\n                        this.trace('Failed to bind ' +\n                            (0, subchannel_address_1.subchannelAddressToString)(address) +\n                            ' with error ' +\n                            err.message);\n                        resolve({\n                            port: 'port' in address ? address.port : 1,\n                            error: err.message,\n                        });\n                    };\n                    http2Server.once('error', onError);\n                    http2Server.listen(address, () => {\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === 'string') {\n                            boundSubchannelAddress = {\n                                path: boundAddress,\n                            };\n                        }\n                        else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port,\n                            };\n                        }\n                        const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                        this.http2Servers.set(http2Server, {\n                            channelzRef: channelzRef,\n                            sessions: new Set(),\n                            ownsChannelzRef: true\n                        });\n                        boundPortObject.listeningServers.add(http2Server);\n                        this.trace('Successfully bound ' +\n                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve({\n                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,\n                        });\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            }\n            async bindManyPorts(addressList, boundPortObject) {\n                if (addressList.length === 0) {\n                    return {\n                        count: 0,\n                        port: 0,\n                        errors: [],\n                    };\n                }\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {\n                    /* If binding to port 0, first try to bind the first address, then bind\n                     * the rest of the address list to the specific port that it binds. */\n                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\n                    if (firstAddressResult.error) {\n                        /* If the first address fails to bind, try the same operation starting\n                         * from the second item in the list. */\n                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\n                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });\n                    }\n                    else {\n                        const restAddresses = addressList\n                            .slice(1)\n                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)\n                            ? { host: address.host, port: firstAddressResult.port }\n                            : address);\n                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));\n                        const allResults = [firstAddressResult, ...restAddressResult];\n                        return {\n                            count: allResults.filter(result => result.error === undefined).length,\n                            port: firstAddressResult.port,\n                            errors: allResults\n                                .filter(result => result.error)\n                                .map(result => result.error),\n                        };\n                    }\n                }\n                else {\n                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));\n                    return {\n                        count: allResults.filter(result => result.error === undefined).length,\n                        port: allResults[0].port,\n                        errors: allResults\n                            .filter(result => result.error)\n                            .map(result => result.error),\n                    };\n                }\n            }\n            async bindAddressList(addressList, boundPortObject) {\n                const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n                if (bindResult.count > 0) {\n                    if (bindResult.count < addressList.length) {\n                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                    }\n                    return bindResult.port;\n                }\n                else {\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);\n                }\n            }\n            resolvePort(port) {\n                return new Promise((resolve, reject) => {\n                    let seenResolution = false;\n                    const resolverListener = (endpointList, attributes, serviceConfig, resolutionNote) => {\n                        if (seenResolution) {\n                            return true;\n                        }\n                        seenResolution = true;\n                        if (!endpointList.ok) {\n                            reject(new Error(endpointList.error.details));\n                            return true;\n                        }\n                        const addressList = [].concat(...endpointList.value.map(endpoint => endpoint.addresses));\n                        if (addressList.length === 0) {\n                            reject(new Error(`No addresses resolved for port ${port}`));\n                            return true;\n                        }\n                        resolve(addressList);\n                        return true;\n                    };\n                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\n                    resolver.updateResolution();\n                });\n            }\n            async bindPort(port, boundPortObject) {\n                const addressList = await this.resolvePort(port);\n                if (boundPortObject.cancelled) {\n                    this.completeUnbind(boundPortObject);\n                    throw new Error('bindAsync operation cancelled by unbind call');\n                }\n                const portNumber = await this.bindAddressList(addressList, boundPortObject);\n                if (boundPortObject.cancelled) {\n                    this.completeUnbind(boundPortObject);\n                    throw new Error('bindAsync operation cancelled by unbind call');\n                }\n                return portNumber;\n            }\n            normalizePort(port) {\n                const initialPortUri = (0, uri_parser_1.parseUri)(port);\n                if (initialPortUri === null) {\n                    throw new Error(`Could not parse port \"${port}\"`);\n                }\n                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n                if (portUri === null) {\n                    throw new Error(`Could not get a default scheme for port \"${port}\"`);\n                }\n                return portUri;\n            }\n            bindAsync(port, creds, callback) {\n                if (this.shutdown) {\n                    throw new Error('bindAsync called after shutdown');\n                }\n                if (typeof port !== 'string') {\n                    throw new TypeError('port must be a string');\n                }\n                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n                    throw new TypeError('creds must be a ServerCredentials object');\n                }\n                if (typeof callback !== 'function') {\n                    throw new TypeError('callback must be a function');\n                }\n                this.trace('bindAsync port=' + port);\n                const portUri = this.normalizePort(port);\n                const deferredCallback = (error, port) => {\n                    process.nextTick(() => callback(error, port));\n                };\n                /* First, if this port is already bound or that bind operation is in\n                 * progress, use that result. */\n                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n                if (boundPortObject) {\n                    if (!creds._equals(boundPortObject.credentials)) {\n                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\n                        return;\n                    }\n                    /* If that operation has previously been cancelled by an unbind call,\n                     * uncancel it. */\n                    boundPortObject.cancelled = false;\n                    if (boundPortObject.completionPromise) {\n                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));\n                    }\n                    else {\n                        deferredCallback(null, boundPortObject.portNumber);\n                    }\n                    return;\n                }\n                boundPortObject = {\n                    mapKey: (0, uri_parser_1.uriToString)(portUri),\n                    originalUri: portUri,\n                    completionPromise: null,\n                    cancelled: false,\n                    portNumber: 0,\n                    credentials: creds,\n                    listeningServers: new Set(),\n                };\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n                const completionPromise = this.bindPort(portUri, boundPortObject);\n                boundPortObject.completionPromise = completionPromise;\n                /* If the port number is 0, defer populating the map entry until after the\n                 * bind operation completes and we have a specific port number. Otherwise,\n                 * populate it immediately. */\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                    completionPromise.then(portNum => {\n                        const finalUri = {\n                            scheme: portUri.scheme,\n                            authority: portUri.authority,\n                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),\n                        };\n                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\n                        boundPortObject.completionPromise = null;\n                        boundPortObject.portNumber = portNum;\n                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n                        callback(null, portNum);\n                    }, error => {\n                        callback(error, 0);\n                    });\n                }\n                else {\n                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n                    completionPromise.then(portNum => {\n                        boundPortObject.completionPromise = null;\n                        boundPortObject.portNumber = portNum;\n                        callback(null, portNum);\n                    }, error => {\n                        callback(error, 0);\n                    });\n                }\n            }\n            registerInjectorToChannelz() {\n                return (0, channelz_1.registerChannelzSocket)('injector', () => {\n                    return {\n                        localAddress: null,\n                        remoteAddress: null,\n                        security: null,\n                        remoteName: null,\n                        streamsStarted: 0,\n                        streamsSucceeded: 0,\n                        streamsFailed: 0,\n                        messagesSent: 0,\n                        messagesReceived: 0,\n                        keepAlivesSent: 0,\n                        lastLocalStreamCreatedTimestamp: null,\n                        lastRemoteStreamCreatedTimestamp: null,\n                        lastMessageSentTimestamp: null,\n                        lastMessageReceivedTimestamp: null,\n                        localFlowControlWindow: null,\n                        remoteFlowControlWindow: null,\n                    };\n                }, this.channelzEnabled);\n            }\n            /**\n             * This API is experimental, so API stability is not guaranteed across minor versions.\n             * @param credentials\n             * @param channelzRef\n             * @returns\n             */\n            experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n                    throw new TypeError('creds must be a ServerCredentials object');\n                }\n                if (this.channelzEnabled) {\n                    this.listenerChildrenTracker.refChild(channelzRef);\n                }\n                const server = this.createHttp2Server(credentials);\n                const sessionsSet = new Set();\n                this.http2Servers.set(server, {\n                    channelzRef: channelzRef,\n                    sessions: sessionsSet,\n                    ownsChannelzRef\n                });\n                return {\n                    injectConnection: (connection) => {\n                        server.emit('connection', connection);\n                    },\n                    drain: (graceTimeMs) => {\n                        var _b, _c;\n                        for (const session of sessionsSet) {\n                            this.closeSession(session);\n                        }\n                        (_c = (_b = setTimeout(() => {\n                            for (const session of sessionsSet) {\n                                session.destroy(http2.constants.NGHTTP2_CANCEL);\n                            }\n                        }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n                    },\n                    destroy: () => {\n                        this.closeServer(server);\n                        for (const session of sessionsSet) {\n                            this.closeSession(session);\n                        }\n                    }\n                };\n            }\n            createConnectionInjector(credentials) {\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n                    throw new TypeError('creds must be a ServerCredentials object');\n                }\n                const channelzRef = this.registerInjectorToChannelz();\n                return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\n            }\n            closeServer(server, callback) {\n                this.trace('Closing server with address ' + JSON.stringify(server.address()));\n                const serverInfo = this.http2Servers.get(server);\n                server.close(() => {\n                    if (serverInfo && serverInfo.ownsChannelzRef) {\n                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\n                    }\n                    this.http2Servers.delete(server);\n                    callback === null || callback === void 0 ? void 0 : callback();\n                });\n            }\n            closeSession(session, callback) {\n                var _b;\n                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n                const sessionInfo = this.sessions.get(session);\n                const closeCallback = () => {\n                    if (sessionInfo) {\n                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\n                    }\n                    callback === null || callback === void 0 ? void 0 : callback();\n                };\n                if (session.closed) {\n                    queueMicrotask(closeCallback);\n                }\n                else {\n                    session.close(closeCallback);\n                }\n            }\n            completeUnbind(boundPortObject) {\n                for (const server of boundPortObject.listeningServers) {\n                    const serverInfo = this.http2Servers.get(server);\n                    this.closeServer(server, () => {\n                        boundPortObject.listeningServers.delete(server);\n                    });\n                    if (serverInfo) {\n                        for (const session of serverInfo.sessions) {\n                            this.closeSession(session);\n                        }\n                    }\n                }\n                this.boundPorts.delete(boundPortObject.mapKey);\n            }\n            /**\n             * Unbind a previously bound port, or cancel an in-progress bindAsync\n             * operation. If port 0 was bound, only the actual bound port can be\n             * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n             * bound port result was 54321, it can be unbound as \"localhost:54321\".\n             * @param port\n             */\n            unbind(port) {\n                this.trace('unbind port=' + port);\n                const portUri = this.normalizePort(port);\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                    throw new Error('Cannot unbind port 0');\n                }\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n                if (boundPortObject) {\n                    this.trace('unbinding ' +\n                        boundPortObject.mapKey +\n                        ' originally bound as ' +\n                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\n                    /* If the bind operation is pending, the cancelled flag will trigger\n                     * the unbind operation later. */\n                    if (boundPortObject.completionPromise) {\n                        boundPortObject.cancelled = true;\n                    }\n                    else {\n                        this.completeUnbind(boundPortObject);\n                    }\n                }\n            }\n            /**\n             * Gracefully close all connections associated with a previously bound port.\n             * After the grace time, forcefully close all remaining open connections.\n             *\n             * If port 0 was bound, only the actual bound port can be\n             * drained. For example, if bindAsync was called with \"localhost:0\" and the\n             * bound port result was 54321, it can be drained as \"localhost:54321\".\n             * @param port\n             * @param graceTimeMs\n             * @returns\n             */\n            drain(port, graceTimeMs) {\n                var _b, _c;\n                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\n                const portUri = this.normalizePort(port);\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                    throw new Error('Cannot drain port 0');\n                }\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n                if (!boundPortObject) {\n                    return;\n                }\n                const allSessions = new Set();\n                for (const http2Server of boundPortObject.listeningServers) {\n                    const serverEntry = this.http2Servers.get(http2Server);\n                    if (serverEntry) {\n                        for (const session of serverEntry.sessions) {\n                            allSessions.add(session);\n                            this.closeSession(session, () => {\n                                allSessions.delete(session);\n                            });\n                        }\n                    }\n                }\n                /* After the grace time ends, send another goaway to all remaining sessions\n                 * with the CANCEL code. */\n                (_c = (_b = setTimeout(() => {\n                    for (const session of allSessions) {\n                        session.destroy(http2.constants.NGHTTP2_CANCEL);\n                    }\n                }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            forceShutdown() {\n                for (const boundPortObject of this.boundPorts.values()) {\n                    boundPortObject.cancelled = true;\n                }\n                this.boundPorts.clear();\n                // Close the server if it is still running.\n                for (const server of this.http2Servers.keys()) {\n                    this.closeServer(server);\n                }\n                // Always destroy any available sessions. It's possible that one or more\n                // tryShutdown() calls are in progress. Don't wait on them to finish.\n                this.sessions.forEach((channelzInfo, session) => {\n                    this.closeSession(session);\n                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n                    // recognize destroy(code) as a valid signature.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    session.destroy(http2.constants.NGHTTP2_CANCEL);\n                });\n                this.sessions.clear();\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n                this.shutdown = true;\n            }\n            register(name, handler, serialize, deserialize, type) {\n                if (this.handlers.has(name)) {\n                    return false;\n                }\n                this.handlers.set(name, {\n                    func: handler,\n                    serialize,\n                    deserialize,\n                    type,\n                    path: name,\n                });\n                return true;\n            }\n            unregister(name) {\n                return this.handlers.delete(name);\n            }\n            /**\n             * @deprecated No longer needed as of version 1.10.x\n             */\n            start() {\n                if (this.http2Servers.size === 0 ||\n                    [...this.http2Servers.keys()].every(server => !server.listening)) {\n                    throw new Error('server must be bound in order to start');\n                }\n                if (this.started === true) {\n                    throw new Error('server is already started');\n                }\n                this.started = true;\n            }\n            tryShutdown(callback) {\n                var _b;\n                const wrappedCallback = (error) => {\n                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n                    callback(error);\n                };\n                let pendingChecks = 0;\n                function maybeCallback() {\n                    pendingChecks--;\n                    if (pendingChecks === 0) {\n                        wrappedCallback();\n                    }\n                }\n                this.shutdown = true;\n                for (const [serverKey, server] of this.http2Servers.entries()) {\n                    pendingChecks++;\n                    const serverString = server.channelzRef.name;\n                    this.trace('Waiting for server ' + serverString + ' to close');\n                    this.closeServer(serverKey, () => {\n                        this.trace('Server ' + serverString + ' finished closing');\n                        maybeCallback();\n                    });\n                    for (const session of server.sessions.keys()) {\n                        pendingChecks++;\n                        const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\n                        this.trace('Waiting for session ' + sessionString + ' to close');\n                        this.closeSession(session, () => {\n                            this.trace('Session ' + sessionString + ' finished closing');\n                            maybeCallback();\n                        });\n                    }\n                }\n                if (pendingChecks === 0) {\n                    wrappedCallback();\n                }\n            }\n            addHttp2Port() {\n                throw new Error('Not yet implemented');\n            }\n            /**\n             * Get the channelz reference object for this server. The returned value is\n             * garbage if channelz is disabled for this server.\n             * @returns\n             */\n            getChannelzRef() {\n                return this.channelzRef;\n            }\n            _verifyContentType(stream, headers) {\n                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n                if (typeof contentType !== 'string' ||\n                    !contentType.startsWith('application/grpc')) {\n                    stream.respond({\n                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n                    }, { endStream: true });\n                    return false;\n                }\n                return true;\n            }\n            _retrieveHandler(path) {\n                serverCallTrace('Received call to method ' +\n                    path +\n                    ' at address ' +\n                    this.serverAddressString);\n                const handler = this.handlers.get(path);\n                if (handler === undefined) {\n                    serverCallTrace('No handler registered for method ' +\n                        path +\n                        '. Sending UNIMPLEMENTED status.');\n                    return null;\n                }\n                return handler;\n            }\n            _respondWithError(err, stream, channelzSessionInfo = null) {\n                var _b, _c;\n                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\n                stream.respond(trailersToSend, { endStream: true });\n                this.callTracker.addCallFailed();\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            }\n            _channelzHandler(extraInterceptors, stream, headers) {\n                // for handling idle timeout\n                this.onStreamOpened(stream);\n                const channelzSessionInfo = this.sessions.get(stream.session);\n                this.callTracker.addCallStarted();\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n                if (!this._verifyContentType(stream, headers)) {\n                    this.callTracker.addCallFailed();\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n                    return;\n                }\n                const path = headers[HTTP2_HEADER_PATH];\n                const handler = this._retrieveHandler(path);\n                if (!handler) {\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n                    return;\n                }\n                const callEventTracker = {\n                    addMessageSent: () => {\n                        if (channelzSessionInfo) {\n                            channelzSessionInfo.messagesSent += 1;\n                            channelzSessionInfo.lastMessageSentTimestamp = new Date();\n                        }\n                    },\n                    addMessageReceived: () => {\n                        if (channelzSessionInfo) {\n                            channelzSessionInfo.messagesReceived += 1;\n                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n                        }\n                    },\n                    onCallEnd: status => {\n                        if (status.code === constants_1.Status.OK) {\n                            this.callTracker.addCallSucceeded();\n                        }\n                        else {\n                            this.callTracker.addCallFailed();\n                        }\n                    },\n                    onStreamEnd: success => {\n                        if (channelzSessionInfo) {\n                            if (success) {\n                                channelzSessionInfo.streamTracker.addCallSucceeded();\n                            }\n                            else {\n                                channelzSessionInfo.streamTracker.addCallFailed();\n                            }\n                        }\n                    },\n                };\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);\n                if (!this._runHandlerForCall(call, handler)) {\n                    this.callTracker.addCallFailed();\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n                    call.sendStatus({\n                        code: constants_1.Status.INTERNAL,\n                        details: `Unknown handler type: ${handler.type}`,\n                    });\n                }\n            }\n            _streamHandler(extraInterceptors, stream, headers) {\n                // for handling idle timeout\n                this.onStreamOpened(stream);\n                if (this._verifyContentType(stream, headers) !== true) {\n                    return;\n                }\n                const path = headers[HTTP2_HEADER_PATH];\n                const handler = this._retrieveHandler(path);\n                if (!handler) {\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n                    return;\n                }\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);\n                if (!this._runHandlerForCall(call, handler)) {\n                    call.sendStatus({\n                        code: constants_1.Status.INTERNAL,\n                        details: `Unknown handler type: ${handler.type}`,\n                    });\n                }\n            }\n            _runHandlerForCall(call, handler) {\n                const { type } = handler;\n                if (type === 'unary') {\n                    handleUnary(call, handler);\n                }\n                else if (type === 'clientStream') {\n                    handleClientStreaming(call, handler);\n                }\n                else if (type === 'serverStream') {\n                    handleServerStreaming(call, handler);\n                }\n                else if (type === 'bidi') {\n                    handleBidiStreaming(call, handler);\n                }\n                else {\n                    return false;\n                }\n                return true;\n            }\n            _setupHandlers(http2Server, extraInterceptors) {\n                if (http2Server === null) {\n                    return;\n                }\n                const serverAddress = http2Server.address();\n                let serverAddressString = 'null';\n                if (serverAddress) {\n                    if (typeof serverAddress === 'string') {\n                        serverAddressString = serverAddress;\n                    }\n                    else {\n                        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n                    }\n                }\n                this.serverAddressString = serverAddressString;\n                const handler = this.channelzEnabled\n                    ? this._channelzHandler\n                    : this._streamHandler;\n                const sessionHandler = this.channelzEnabled\n                    ? this._channelzSessionHandler(http2Server)\n                    : this._sessionHandler(http2Server);\n                http2Server.on('stream', handler.bind(this, extraInterceptors));\n                http2Server.on('session', sessionHandler);\n            }\n            _sessionHandler(http2Server) {\n                return (session) => {\n                    var _b, _c;\n                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\n                    let connectionAgeTimer = null;\n                    let connectionAgeGraceTimer = null;\n                    let keepaliveTimer = null;\n                    let sessionClosedByServer = false;\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        // Apply a random jitter within a +/-10% range\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                        connectionAgeTimer = setTimeout(() => {\n                            var _b, _c;\n                            sessionClosedByServer = true;\n                            this.trace('Connection dropped by max connection age: ' +\n                                ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n                            try {\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n                            }\n                            catch (e) {\n                                // The goaway can't be sent because the session is already closed\n                                session.destroy();\n                                return;\n                            }\n                            session.close();\n                            /* Allow a grace period after sending the GOAWAY before forcibly\n                             * closing the connection. */\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                                connectionAgeGraceTimer = setTimeout(() => {\n                                    session.destroy();\n                                }, this.maxConnectionAgeGraceMs);\n                                (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\n                            }\n                        }, this.maxConnectionAgeMs + jitter);\n                        (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\n                    }\n                    const clearKeepaliveTimeout = () => {\n                        if (keepaliveTimer) {\n                            clearTimeout(keepaliveTimer);\n                            keepaliveTimer = null;\n                        }\n                    };\n                    const canSendPing = () => {\n                        return (!session.destroyed &&\n                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n                            this.keepaliveTimeMs > 0);\n                    };\n                    /* eslint-disable-next-line prefer-const */\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n                    const maybeStartKeepalivePingTimer = () => {\n                        var _b;\n                        if (!canSendPing()) {\n                            return;\n                        }\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n                        keepaliveTimer = setTimeout(() => {\n                            clearKeepaliveTimeout();\n                            sendPing();\n                        }, this.keepaliveTimeMs);\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n                    };\n                    sendPing = () => {\n                        var _b;\n                        if (!canSendPing()) {\n                            return;\n                        }\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n                        let pingSendError = '';\n                        try {\n                            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n                                clearKeepaliveTimeout();\n                                if (err) {\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\n                                    sessionClosedByServer = true;\n                                    session.close();\n                                }\n                                else {\n                                    this.keepaliveTrace('Received ping response');\n                                    maybeStartKeepalivePingTimer();\n                                }\n                            });\n                            if (!pingSentSuccessfully) {\n                                pingSendError = 'Ping returned false';\n                            }\n                        }\n                        catch (e) {\n                            // grpc/grpc-node#2139\n                            pingSendError =\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\n                        }\n                        if (pingSendError) {\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n                            this.trace('Connection dropped due to ping send error: ' + pingSendError);\n                            sessionClosedByServer = true;\n                            session.close();\n                            return;\n                        }\n                        keepaliveTimer = setTimeout(() => {\n                            clearKeepaliveTimeout();\n                            this.keepaliveTrace('Ping timeout passed without response');\n                            this.trace('Connection dropped by keepalive timeout');\n                            sessionClosedByServer = true;\n                            session.close();\n                        }, this.keepaliveTimeoutMs);\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n                    };\n                    maybeStartKeepalivePingTimer();\n                    session.on('close', () => {\n                        var _b, _c;\n                        if (!sessionClosedByServer) {\n                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\n                        }\n                        if (connectionAgeTimer) {\n                            clearTimeout(connectionAgeTimer);\n                        }\n                        if (connectionAgeGraceTimer) {\n                            clearTimeout(connectionAgeGraceTimer);\n                        }\n                        clearKeepaliveTimeout();\n                        if (idleTimeoutObj !== null) {\n                            clearTimeout(idleTimeoutObj.timeout);\n                            this.sessionIdleTimeouts.delete(session);\n                        }\n                        (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\n                    });\n                };\n            }\n            _channelzSessionHandler(http2Server) {\n                return (session) => {\n                    var _b, _c, _d, _e;\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\n                    const channelzSessionInfo = {\n                        ref: channelzRef,\n                        streamTracker: new channelz_1.ChannelzCallTracker(),\n                        messagesSent: 0,\n                        messagesReceived: 0,\n                        keepAlivesSent: 0,\n                        lastMessageSentTimestamp: null,\n                        lastMessageReceivedTimestamp: null,\n                    };\n                    (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\n                    this.sessions.set(session, channelzSessionInfo);\n                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n                    this.trace('Connection established by client ' + clientAddress);\n                    this.sessionChildrenTracker.refChild(channelzRef);\n                    let connectionAgeTimer = null;\n                    let connectionAgeGraceTimer = null;\n                    let keepaliveTimeout = null;\n                    let sessionClosedByServer = false;\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        // Apply a random jitter within a +/-10% range\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                        connectionAgeTimer = setTimeout(() => {\n                            var _b;\n                            sessionClosedByServer = true;\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n                            try {\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n                            }\n                            catch (e) {\n                                // The goaway can't be sent because the session is already closed\n                                session.destroy();\n                                return;\n                            }\n                            session.close();\n                            /* Allow a grace period after sending the GOAWAY before forcibly\n                             * closing the connection. */\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                                connectionAgeGraceTimer = setTimeout(() => {\n                                    session.destroy();\n                                }, this.maxConnectionAgeGraceMs);\n                                (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\n                            }\n                        }, this.maxConnectionAgeMs + jitter);\n                        (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\n                    }\n                    const clearKeepaliveTimeout = () => {\n                        if (keepaliveTimeout) {\n                            clearTimeout(keepaliveTimeout);\n                            keepaliveTimeout = null;\n                        }\n                    };\n                    const canSendPing = () => {\n                        return (!session.destroyed &&\n                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n                            this.keepaliveTimeMs > 0);\n                    };\n                    /* eslint-disable-next-line prefer-const */\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n                    const maybeStartKeepalivePingTimer = () => {\n                        var _b;\n                        if (!canSendPing()) {\n                            return;\n                        }\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n                        keepaliveTimeout = setTimeout(() => {\n                            clearKeepaliveTimeout();\n                            sendPing();\n                        }, this.keepaliveTimeMs);\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n                    };\n                    sendPing = () => {\n                        var _b;\n                        if (!canSendPing()) {\n                            return;\n                        }\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n                        let pingSendError = '';\n                        try {\n                            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n                                clearKeepaliveTimeout();\n                                if (err) {\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\n                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +\n                                        err.message +\n                                        ' return in ' +\n                                        duration);\n                                    sessionClosedByServer = true;\n                                    session.close();\n                                }\n                                else {\n                                    this.keepaliveTrace('Received ping response');\n                                    maybeStartKeepalivePingTimer();\n                                }\n                            });\n                            if (!pingSentSuccessfully) {\n                                pingSendError = 'Ping returned false';\n                            }\n                        }\n                        catch (e) {\n                            // grpc/grpc-node#2139\n                            pingSendError =\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\n                        }\n                        if (pingSendError) {\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);\n                            sessionClosedByServer = true;\n                            session.close();\n                            return;\n                        }\n                        channelzSessionInfo.keepAlivesSent += 1;\n                        keepaliveTimeout = setTimeout(() => {\n                            clearKeepaliveTimeout();\n                            this.keepaliveTrace('Ping timeout passed without response');\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n                            sessionClosedByServer = true;\n                            session.close();\n                        }, this.keepaliveTimeoutMs);\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n                    };\n                    maybeStartKeepalivePingTimer();\n                    session.on('close', () => {\n                        var _b;\n                        if (!sessionClosedByServer) {\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n                        }\n                        this.sessionChildrenTracker.unrefChild(channelzRef);\n                        (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                        if (connectionAgeTimer) {\n                            clearTimeout(connectionAgeTimer);\n                        }\n                        if (connectionAgeGraceTimer) {\n                            clearTimeout(connectionAgeGraceTimer);\n                        }\n                        clearKeepaliveTimeout();\n                        if (idleTimeoutObj !== null) {\n                            clearTimeout(idleTimeoutObj.timeout);\n                            this.sessionIdleTimeouts.delete(session);\n                        }\n                        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\n                        this.sessions.delete(session);\n                    });\n                };\n            }\n            enableIdleTimeout(session) {\n                var _b, _c;\n                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n                    return null;\n                }\n                const idleTimeoutObj = {\n                    activeStreams: 0,\n                    lastIdle: Date.now(),\n                    onClose: this.onStreamClose.bind(this, session),\n                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),\n                };\n                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n                this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n                const { socket } = session;\n                this.trace('Enable idle timeout for ' +\n                    socket.remoteAddress +\n                    ':' +\n                    socket.remotePort);\n                return idleTimeoutObj;\n            }\n            onIdleTimeout(ctx, session) {\n                const { socket } = session;\n                const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n                // if it is called while we have activeStreams - timer will not be rescheduled\n                // until last active stream is closed, then it will call .refresh() on the timer\n                // important part is to not clearTimeout(timer) or it becomes unusable\n                // for future refreshes\n                if (sessionInfo !== undefined &&\n                    sessionInfo.activeStreams === 0) {\n                    if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n                        ctx.trace('Session idle timeout triggered for ' +\n                            (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) +\n                            ':' +\n                            (socket === null || socket === void 0 ? void 0 : socket.remotePort) +\n                            ' last idle at ' +\n                            sessionInfo.lastIdle);\n                        ctx.closeSession(session);\n                    }\n                    else {\n                        sessionInfo.timeout.refresh();\n                    }\n                }\n            }\n            onStreamOpened(stream) {\n                const session = stream.session;\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n                if (idleTimeoutObj) {\n                    idleTimeoutObj.activeStreams += 1;\n                    stream.once('close', idleTimeoutObj.onClose);\n                }\n            }\n            onStreamClose(session) {\n                var _b, _c;\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n                if (idleTimeoutObj) {\n                    idleTimeoutObj.activeStreams -= 1;\n                    if (idleTimeoutObj.activeStreams === 0) {\n                        idleTimeoutObj.lastIdle = Date.now();\n                        idleTimeoutObj.timeout.refresh();\n                        this.trace('Session onStreamClose' +\n                            ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) +\n                            ':' +\n                            ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) +\n                            ' at ' +\n                            idleTimeoutObj.lastIdle);\n                    }\n                }\n            }\n        },\n        (() => {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];\n            __esDecorate(_a, null, _start_decorators, { kind: \"method\", name: \"start\", static: false, private: false, access: { has: obj => \"start\" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        })(),\n        _a;\n})();\nexports.Server = Server;\nasync function handleUnary(call, handler) {\n    let stream;\n    function respond(err, value, trailer, flags) {\n        if (err) {\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n            return;\n        }\n        call.sendMessage(value, () => {\n            call.sendStatus({\n                code: constants_1.Status.OK,\n                details: 'OK',\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null,\n            });\n        });\n    }\n    let requestMetadata;\n    let requestMessage = null;\n    call.start({\n        onReceiveMetadata(metadata) {\n            requestMetadata = metadata;\n            call.startRead();\n        },\n        onReceiveMessage(message) {\n            if (requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received a second request message for server streaming method ${handler.path}`,\n                    metadata: null,\n                });\n                return;\n            }\n            requestMessage = message;\n            call.startRead();\n        },\n        onReceiveHalfClose() {\n            if (!requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received no request message for server streaming method ${handler.path}`,\n                    metadata: null,\n                });\n                return;\n            }\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n            try {\n                handler.func(stream, respond);\n            }\n            catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null,\n                });\n            }\n        },\n        onCancel() {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit('cancelled', 'cancelled');\n            }\n        },\n    });\n}\nfunction handleClientStreaming(call, handler) {\n    let stream;\n    function respond(err, value, trailer, flags) {\n        if (err) {\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n            return;\n        }\n        call.sendMessage(value, () => {\n            call.sendStatus({\n                code: constants_1.Status.OK,\n                details: 'OK',\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null,\n            });\n        });\n    }\n    call.start({\n        onReceiveMetadata(metadata) {\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n            try {\n                handler.func(stream, respond);\n            }\n            catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null,\n                });\n            }\n        },\n        onReceiveMessage(message) {\n            stream.push(message);\n        },\n        onReceiveHalfClose() {\n            stream.push(null);\n        },\n        onCancel() {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit('cancelled', 'cancelled');\n                stream.destroy();\n            }\n        },\n    });\n}\nfunction handleServerStreaming(call, handler) {\n    let stream;\n    let requestMetadata;\n    let requestMessage = null;\n    call.start({\n        onReceiveMetadata(metadata) {\n            requestMetadata = metadata;\n            call.startRead();\n        },\n        onReceiveMessage(message) {\n            if (requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received a second request message for server streaming method ${handler.path}`,\n                    metadata: null,\n                });\n                return;\n            }\n            requestMessage = message;\n            call.startRead();\n        },\n        onReceiveHalfClose() {\n            if (!requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received no request message for server streaming method ${handler.path}`,\n                    metadata: null,\n                });\n                return;\n            }\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n            try {\n                handler.func(stream);\n            }\n            catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null,\n                });\n            }\n        },\n        onCancel() {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit('cancelled', 'cancelled');\n                stream.destroy();\n            }\n        },\n    });\n}\nfunction handleBidiStreaming(call, handler) {\n    let stream;\n    call.start({\n        onReceiveMetadata(metadata) {\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n            try {\n                handler.func(stream);\n            }\n            catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null,\n                });\n            }\n        },\n        onReceiveMessage(message) {\n            stream.push(message);\n        },\n        onReceiveHalfClose() {\n            stream.push(null);\n        },\n        onCancel() {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit('cancelled', 'cancelled');\n                stream.destroy();\n            }\n        },\n    });\n}\n//# sourceMappingURL=server.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUZBQXVGO0FBQ2hIO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLGdEQUFnRCx5RkFBeUY7QUFDekksZ0VBQWdFLDJDQUEyQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxXQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxxRUFBcUUsK0RBQStEO0FBQzlPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0JBQXdCLGlFQUFpRTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixrQkFBa0IsK0JBQStCLG9CQUFvQjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxvQkFBb0I7QUFDN0Y7QUFDQSx1Q0FBdUMsYUFBYSxXQUFXLDRCQUE0QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdRQUF3UTtBQUMvVCxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSw0RUFBNEU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkIsR0FBRywwQkFBMEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdFQUF3RSxtREFBbUQsdUJBQXVCO0FBQzFNLHdFQUF3RSx3RUFBd0U7QUFDaEosU0FBUztBQUNUO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXIuanM/OGVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc2VydmVyX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jYWxsXCIpO1xuY29uc3Qgc2VydmVyX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY3JlZGVudGlhbHNcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IHNlcnZlcl9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1pbnRlcmNlcHRvcnNcIik7XG5jb25zdCBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMgPSB+KDEgPDwgMzEpO1xuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX01TID0gMjAwMDA7XG5jb25zdCBNQVhfQ09OTkVDVElPTl9JRExFX01TID0gfigxIDw8IDMxKTtcbmNvbnN0IHsgSFRUUDJfSEVBREVSX1BBVEggfSA9IGh0dHAyLmNvbnN0YW50cztcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcic7XG5jb25zdCBrTWF4QWdlID0gQnVmZmVyLmZyb20oJ21heF9hZ2UnKTtcbmZ1bmN0aW9uIHNlcnZlckNhbGxUcmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdzZXJ2ZXJfY2FsbCcsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuLyoqXG4gKiBEZWNvcmF0b3IgdG8gd3JhcCBhIGNsYXNzIG1ldGhvZCB3aXRoIHV0aWwuZGVwcmVjYXRlXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBvdXRwdXQgaWYgdGhlIGRlcHJlY2F0ZWQgbWV0aG9kIGlzIGNhbGxlZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdXRpbC5kZXByZWNhdGUodGFyZ2V0LCBtZXNzYWdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgZGV0YWlsczogYFRoZSBzZXJ2ZXIgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBtZXRob2QgJHttZXRob2ROYW1lfWAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRIYW5kbGVyKGhhbmRsZXJUeXBlLCBtZXRob2ROYW1lKSB7XG4gICAgY29uc3QgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlID0gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpO1xuICAgIHN3aXRjaCAoaGFuZGxlclR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5hcnknOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdjbGllbnRTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzZXJ2ZXJTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiaWRpJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoYW5kbGVyVHlwZSAke2hhbmRsZXJUeXBlfWApO1xuICAgIH1cbn1cbmxldCBTZXJ2ZXIgPSAoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX3N0YXJ0X2RlY29yYXRvcnM7XG4gICAgcmV0dXJuIF9hID0gY2xhc3MgU2VydmVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMgPSAoX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBmaWVsZCBvbmx5IGV4aXN0cyB0byBlbnN1cmUgdGhhdCB0aGUgc3RhcnQgbWV0aG9kIHRocm93cyBhbiBlcnJvciBpZlxuICAgICAgICAgICAgICAgICAqIGl0IGlzIGNhbGxlZCB0d2ljZSwgYXMgaXQgZGlkIHByZXZpb3VzbHkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyA9ICdudWxsJztcbiAgICAgICAgICAgICAgICAvLyBDaGFubmVseiBJbmZvXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZVN0dWIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcikoJ3NlcnZlcicsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU2VydmVyIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyA9XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbkFnZUdyYWNlTXMgPVxuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLm9wdGlvbnNbJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX2dyYWNlX21zJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUztcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMub3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBLRUVQQUxJVkVfTUFYX1RJTUVfTVM7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPVxuICAgICAgICAgICAgICAgICAgICAoX2UgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogS0VFUEFMSVZFX1RJTUVPVVRfTVM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXQgPVxuICAgICAgICAgICAgICAgICAgICAoX2YgPSB0aGlzLm9wdGlvbnNbJ2dycGMubWF4X2Nvbm5lY3Rpb25faWRsZV9tcyddKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBNQVhfQ09OTkVDVElPTl9JRExFX01TO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1snZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQnkgZGVmYXVsdCwgc2V0IGEgdmVyeSBsYXJnZSBtYXggc2Vzc2lvbiBtZW1vcnkgbGltaXQsIHRvIGVmZmVjdGl2ZWx5XG4gICAgICAgICAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAqIGJ5IGRpc2FibGluZyB0aGUgY2hlY2sgZW50aXJlbHkuICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zLnNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJ10sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gKF9nID0gdGhpcy5vcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU2VydmVyIGNvbnN0cnVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2U6IHRoaXMuY2hhbm5lbHpUcmFjZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQ2hpbGRyZW46IHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2hpbGRyZW46IHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldENoYW5uZWx6U2Vzc2lvbkluZm8oc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHNlc3Npb24uc29ja2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgdGxzSW5mbztcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYiA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlID8gY2VydGlmaWNhdGUucmF3IDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiBwZWVyQ2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gcGVlckNlcnRpZmljYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwZWVyQ2VydGlmaWNhdGUucmF3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGxzSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHNlc3Npb25JbmZvLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogc2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IHNlc3Npb25JbmZvLmtlZXBBbGl2ZXNTZW50LFxuICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogc2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiAoX2MgPSBzZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IChfZCA9IHNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UodGV4dCkge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2tlZXBhbGl2ZScsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRQcm90b1NlcnZpY2UoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBhZGRTZXJ2aWNlKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VydmljZShzZXJ2aWNlLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzZXJ2aWNlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW1wbGVtZW50YXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkU2VydmljZSgpIHJlcXVpcmVzIHR3byBvYmplY3RzIGFzIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFuIGVtcHR5IHNlcnZpY2UgdG8gYSBzZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VydmljZUtleXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWV0aG9kVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudFN0cmVhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlclN0cmVhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbXBsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbEZuID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGF0dHJzLm9yaWdpbmFsTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcGxGbiA9IGltcGxlbWVudGF0aW9uW2F0dHJzLm9yaWdpbmFsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcGxGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBsID0gaW1wbEZuLmJpbmQoaW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wbCA9IGdldERlZmF1bHRIYW5kbGVyKG1ldGhvZFR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLnJlZ2lzdGVyKGF0dHJzLnBhdGgsIGltcGwsIGF0dHJzLnJlc3BvbnNlU2VyaWFsaXplLCBhdHRycy5yZXF1ZXN0RGVzZXJpYWxpemUsIG1ldGhvZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kIGhhbmRsZXIgZm9yICR7YXR0cnMucGF0aH0gYWxyZWFkeSBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlU2VydmljZShzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHwgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlU2VydmljZSgpIHJlcXVpcmVzIG9iamVjdCBhcyBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICAgICAgICAgIHNlcnZpY2VLZXlzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gc2VydmljZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZChwb3J0LCBjcmVkcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLiBVc2UgYmluZEFzeW5jKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwsIHNvIEFQSSBzdGFiaWxpdHkgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIG1pbm9yIHZlcnNpb25zLlxuICAgICAgICAgICAgICogQHBhcmFtIGJvdW5kQWRkcmVzc1xuICAgICAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsUmVnaXN0ZXJMaXN0ZW5lclRvQ2hhbm5lbHooYm91bmRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQpKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShib3VuZEFkZHJlc3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGJvdW5kQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN1cml0eTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlcmltZW50YWxVbnJlZ2lzdGVyTGlzdGVuZXJGcm9tQ2hhbm5lbHooY2hhbm5lbHpSZWYpIHtcbiAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0ZUh0dHAyU2VydmVyKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGh0dHAyU2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChjcmVkZW50aWFscy5faXNTZWN1cmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3Rvck9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0Q29uc3RydWN0b3JPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRPcHRpb25zID0gY3JlZGVudGlhbHMuX2dldFNlY3VyZUNvbnRleHRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyZVNlcnZlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbW1vblNlcnZlck9wdGlvbnMpLCBjb25zdHJ1Y3Rvck9wdGlvbnMpLCBjb250ZXh0T3B0aW9ucyksIHsgZW5hYmxlVHJhY2U6IHRoaXMub3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSA9PT0gMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZUNyZWRlbnRpYWxzVmFsaWQgPSBjb250ZXh0T3B0aW9ucyAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnSW5pdGlhbCBjcmVkZW50aWFscyB2YWxpZDogJyArIGFyZUNyZWRlbnRpYWxzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlY3VyZVNlcnZlcihzZWN1cmVTZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucHJlcGVuZExpc3RlbmVyKCdjb25uZWN0aW9uJywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVDcmVkZW50aWFsc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRHJvcHBlZCBjb25uZWN0aW9uIGZyb20gJyArIEpTT04uc3RyaW5naWZ5KHNvY2tldC5hZGRyZXNzKCkpICsgJyBkdWUgdG8gdW5sb2FkZWQgY3JlZGVudGlhbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3NlY3VyZUNvbm5lY3Rpb24nLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGVzZSBlcnJvcnMgbmVlZCB0byBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyIG9mIEh0dHAyU2VjdXJlU2VydmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU4MjQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0FuIGluY29taW5nIFRMUyBjb25uZWN0aW9uIGNsb3NlZCB3aXRoIGVycm9yOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3JlZHNXYXRjaGVyID0gb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyZVNlcnZlciA9IGh0dHAyU2VydmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyZVNlcnZlci5zZXRTZWN1cmVDb250ZXh0KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gc2V0IHNlY3VyZSBjb250ZXh0IHdpdGggZXJyb3IgJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZUNyZWRlbnRpYWxzVmFsaWQgPSBvcHRpb25zICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUG9zdC11cGRhdGUgY3JlZGVudGlhbHMgdmFsaWQ6ICcgKyBhcmVDcmVkZW50aWFsc1ZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHMuX2FkZFdhdGNoZXIoY3JlZHNXYXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHMuX3JlbW92ZVdhdGNoZXIoY3JlZHNXYXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlcnZlcih0aGlzLmNvbW1vblNlcnZlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5zZXRUaW1lb3V0KDAsIG5vb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwSGFuZGxlcnMoaHR0cDJTZXJ2ZXIsIGNyZWRlbnRpYWxzLl9nZXRJbnRlcmNlcHRvcnMoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHAyU2VydmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZE9uZUFkZHJlc3MoYWRkcmVzcywgYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQXR0ZW1wdGluZyB0byBiaW5kICcgKyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gdGhpcy5jcmVhdGVIdHRwMlNlcnZlcihib3VuZFBvcnRPYmplY3QuY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGYWlsZWQgdG8gYmluZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAncG9ydCcgaW4gYWRkcmVzcyA/IGFkZHJlc3MucG9ydCA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZEFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm91bmRTdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGJvdW5kQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYm91bmRBZGRyZXNzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IGJvdW5kQWRkcmVzcy5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselJlZiA9IHRoaXMuZXhwZXJpbWVudGFsUmVnaXN0ZXJMaXN0ZW5lclRvQ2hhbm5lbHooYm91bmRTdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJzLnNldChodHRwMlNlcnZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6UmVmOiBjaGFubmVselJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bnNDaGFubmVselJlZjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycy5hZGQoaHR0cDJTZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU3VjY2Vzc2Z1bGx5IGJvdW5kICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAncG9ydCcgaW4gYm91bmRTdWJjaGFubmVsQWRkcmVzcyA/IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MucG9ydCA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIGJpbmRNYW55UG9ydHMoYWRkcmVzc0xpc3QsIGJvdW5kUG9ydE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzc0xpc3RbMF0pICYmIGFkZHJlc3NMaXN0WzBdLnBvcnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgYmluZGluZyB0byBwb3J0IDAsIGZpcnN0IHRyeSB0byBiaW5kIHRoZSBmaXJzdCBhZGRyZXNzLCB0aGVuIGJpbmRcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIHJlc3Qgb2YgdGhlIGFkZHJlc3MgbGlzdCB0byB0aGUgc3BlY2lmaWMgcG9ydCB0aGF0IGl0IGJpbmRzLiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCB0aGlzLmJpbmRPbmVBZGRyZXNzKGFkZHJlc3NMaXN0WzBdLCBib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RBZGRyZXNzUmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgZmlyc3QgYWRkcmVzcyBmYWlscyB0byBiaW5kLCB0cnkgdGhlIHNhbWUgb3BlcmF0aW9uIHN0YXJ0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBmcm9tIHRoZSBzZWNvbmQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RBZGRyZXNzUmVzdWx0ID0gYXdhaXQgdGhpcy5iaW5kTWFueVBvcnRzKGFkZHJlc3NMaXN0LnNsaWNlKDEpLCBib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdEFkZHJlc3NSZXN1bHQpLCB7IGVycm9yczogW2ZpcnN0QWRkcmVzc1Jlc3VsdC5lcnJvciwgLi4ucmVzdEFkZHJlc3NSZXN1bHQuZXJyb3JzXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYWRkcmVzcyA9PiAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgaG9zdDogYWRkcmVzcy5ob3N0LCBwb3J0OiBmaXJzdEFkZHJlc3NSZXN1bHQucG9ydCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RBZGRyZXNzUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdEFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiB0aGlzLmJpbmRPbmVBZGRyZXNzKGFkZHJlc3MsIGJvdW5kUG9ydE9iamVjdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbFJlc3VsdHMgPSBbZmlyc3RBZGRyZXNzUmVzdWx0LCAuLi5yZXN0QWRkcmVzc1Jlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBhbGxSZXN1bHRzLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LmVycm9yID09PSB1bmRlZmluZWQpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBmaXJzdEFkZHJlc3NSZXN1bHQucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGFsbFJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LmVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+IHRoaXMuYmluZE9uZUFkZHJlc3MoYWRkcmVzcywgYm91bmRQb3J0T2JqZWN0KSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGFsbFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IgPT09IHVuZGVmaW5lZCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYWxsUmVzdWx0c1swXS5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBhbGxSZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LmVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC5lcnJvciksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgYmluZEFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kUmVzdWx0ID0gYXdhaXQgdGhpcy5iaW5kTWFueVBvcnRzKGFkZHJlc3NMaXN0LCBib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kUmVzdWx0LmNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA8IGFkZHJlc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sIGBXQVJOSU5HIE9ubHkgJHtiaW5kUmVzdWx0LmNvdW50fSBhZGRyZXNzZXMgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kUmVzdWx0LnBvcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclN0cmluZyA9IGBObyBhZGRyZXNzIGFkZGVkIG91dCBvZiB0b3RhbCAke2FkZHJlc3NMaXN0Lmxlbmd0aH0gcmVzb2x2ZWRgO1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yU3RyaW5nfSBlcnJvcnM6IFske2JpbmRSZXN1bHQuZXJyb3JzLmpvaW4oJywnKX1dYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZVBvcnQocG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWVuUmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlckxpc3RlbmVyID0gKGVuZHBvaW50TGlzdCwgYXR0cmlidXRlcywgc2VydmljZUNvbmZpZywgcmVzb2x1dGlvbk5vdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlblJlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRwb2ludExpc3Qub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVuZHBvaW50TGlzdC5lcnJvci5kZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzTGlzdCA9IFtdLmNvbmNhdCguLi5lbmRwb2ludExpc3QudmFsdWUubWFwKGVuZHBvaW50ID0+IGVuZHBvaW50LmFkZHJlc3NlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vIGFkZHJlc3NlcyByZXNvbHZlZCBmb3IgcG9ydCAke3BvcnR9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoMCwgcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcikocG9ydCwgcmVzb2x2ZXJMaXN0ZW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgYmluZFBvcnQocG9ydCwgYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBhd2FpdCB0aGlzLnJlc29sdmVQb3J0KHBvcnQpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVVbmJpbmQoYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQXN5bmMgb3BlcmF0aW9uIGNhbmNlbGxlZCBieSB1bmJpbmQgY2FsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0TnVtYmVyID0gYXdhaXQgdGhpcy5iaW5kQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kUG9ydE9iamVjdC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBc3luYyBvcGVyYXRpb24gY2FuY2VsbGVkIGJ5IHVuYmluZCBjYWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3J0TnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplUG9ydChwb3J0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFBvcnRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShwb3J0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgcG9ydCBcIiR7cG9ydH1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0VXJpID0gKDAsIHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZSkoaW5pdGlhbFBvcnRVcmkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3J0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBhIGRlZmF1bHQgc2NoZW1lIGZvciBwb3J0IFwiJHtwb3J0fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3J0VXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZEFzeW5jKHBvcnQsIGNyZWRzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNodXRkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmluZEFzeW5jIGNhbGxlZCBhZnRlciBzaHV0ZG93bicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvcnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BvcnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3JlZHMgPT09IG51bGwgfHwgIShjcmVkcyBpbnN0YW5jZW9mIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjcmVkcyBtdXN0IGJlIGEgU2VydmVyQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2JpbmRBc3luYyBwb3J0PScgKyBwb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0VXJpID0gdGhpcy5ub3JtYWxpemVQb3J0KHBvcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkQ2FsbGJhY2sgPSAoZXJyb3IsIHBvcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYWxsYmFjayhlcnJvciwgcG9ydCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogRmlyc3QsIGlmIHRoaXMgcG9ydCBpcyBhbHJlYWR5IGJvdW5kIG9yIHRoYXQgYmluZCBvcGVyYXRpb24gaXMgaW5cbiAgICAgICAgICAgICAgICAgKiBwcm9ncmVzcywgdXNlIHRoYXQgcmVzdWx0LiAqL1xuICAgICAgICAgICAgICAgIGxldCBib3VuZFBvcnRPYmplY3QgPSB0aGlzLmJvdW5kUG9ydHMuZ2V0KCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBvcnRVcmkpKTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlZHMuX2VxdWFscyhib3VuZFBvcnRPYmplY3QuY3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihgJHtwb3J0fSBhbHJlYWR5IGJvdW5kIHdpdGggaW5jb21wYXRpYmxlIGNyZWRlbnRpYWxzYCksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoYXQgb3BlcmF0aW9uIGhhcyBwcmV2aW91c2x5IGJlZW4gY2FuY2VsbGVkIGJ5IGFuIHVuYmluZCBjYWxsLFxuICAgICAgICAgICAgICAgICAgICAgKiB1bmNhbmNlbCBpdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY29tcGxldGlvblByb21pc2UudGhlbihwb3J0TnVtID0+IGNhbGxiYWNrKG51bGwsIHBvcnROdW0pLCBlcnJvciA9PiBjYWxsYmFjayhlcnJvciwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhudWxsLCBib3VuZFBvcnRPYmplY3QucG9ydE51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEtleTogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocG9ydFVyaSksXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVXJpOiBwb3J0VXJpLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydE51bWJlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IGNyZWRzLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5pbmdTZXJ2ZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBvcnRVcmkucGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvblByb21pc2UgPSB0aGlzLmJpbmRQb3J0KHBvcnRVcmksIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlID0gY29tcGxldGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIHBvcnQgbnVtYmVyIGlzIDAsIGRlZmVyIHBvcHVsYXRpbmcgdGhlIG1hcCBlbnRyeSB1bnRpbCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAgKiBiaW5kIG9wZXJhdGlvbiBjb21wbGV0ZXMgYW5kIHdlIGhhdmUgYSBzcGVjaWZpYyBwb3J0IG51bWJlci4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgICAgICAqIHBvcHVsYXRlIGl0IGltbWVkaWF0ZWx5LiAqL1xuICAgICAgICAgICAgICAgIGlmICgoc3BsaXRQb3J0ID09PSBudWxsIHx8IHNwbGl0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXRQb3J0LnBvcnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlLnRoZW4ocG9ydE51bSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFVyaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWU6IHBvcnRVcmkuc2NoZW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml0eTogcG9ydFVyaS5hdXRob3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogKDAsIHVyaV9wYXJzZXJfMS5jb21iaW5lSG9zdFBvcnQpKHsgaG9zdDogc3BsaXRQb3J0Lmhvc3QsIHBvcnQ6IHBvcnROdW0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0Lm1hcEtleSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKGZpbmFsVXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QucG9ydE51bWJlciA9IHBvcnROdW07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMuc2V0KGJvdW5kUG9ydE9iamVjdC5tYXBLZXksIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwb3J0TnVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm91bmRQb3J0cy5zZXQoYm91bmRQb3J0T2JqZWN0Lm1hcEtleSwgYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UudGhlbihwb3J0TnVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QucG9ydE51bWJlciA9IHBvcnROdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwb3J0TnVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpc3RlckluamVjdG9yVG9DaGFubmVseigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoJ2luamVjdG9yJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsLCBzbyBBUEkgc3RhYmlsaXR5IGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBtaW5vciB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjcmVkZW50aWFsc1xuICAgICAgICAgICAgICogQHBhcmFtIGNoYW5uZWx6UmVmXG4gICAgICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleHBlcmltZW50YWxDcmVhdGVDb25uZWN0aW9uSW5qZWN0b3JXaXRoQ2hhbm5lbHpSZWYoY3JlZGVudGlhbHMsIGNoYW5uZWx6UmVmLCBvd25zQ2hhbm5lbHpSZWYgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjcmVkZW50aWFscyA9PT0gbnVsbCB8fCAhKGNyZWRlbnRpYWxzIGluc3RhbmNlb2Ygc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NyZWRzIG11c3QgYmUgYSBTZXJ2ZXJDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLmNyZWF0ZUh0dHAyU2VydmVyKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVycy5zZXQoc2VydmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6UmVmOiBjaGFubmVselJlZixcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbnM6IHNlc3Npb25zU2V0LFxuICAgICAgICAgICAgICAgICAgICBvd25zQ2hhbm5lbHpSZWZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RDb25uZWN0aW9uOiAoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLmVtaXQoJ2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhaW46IChncmFjZVRpbWVNcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vzc2lvbiBvZiBzZXNzaW9uc1NldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gKF9iID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGdyYWNlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlcnZlcihzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JlYXRlQ29ubmVjdGlvbkluamVjdG9yKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzID09PSBudWxsIHx8ICEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY3JlZHMgbXVzdCBiZSBhIFNlcnZlckNyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselJlZiA9IHRoaXMucmVnaXN0ZXJJbmplY3RvclRvQ2hhbm5lbHooKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBlcmltZW50YWxDcmVhdGVDb25uZWN0aW9uSW5qZWN0b3JXaXRoQ2hhbm5lbHpSZWYoY3JlZGVudGlhbHMsIGNoYW5uZWx6UmVmLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3NlU2VydmVyKHNlcnZlciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdDbG9zaW5nIHNlcnZlciB3aXRoIGFkZHJlc3MgJyArIEpTT04uc3RyaW5naWZ5KHNlcnZlci5hZGRyZXNzKCkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KHNlcnZlcik7XG4gICAgICAgICAgICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm8gJiYgc2VydmVySW5mby5vd25zQ2hhbm5lbHpSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChzZXJ2ZXJJbmZvLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoc2VydmVySW5mby5jaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlcnMuZGVsZXRlKHNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VTZXNzaW9uKHNlc3Npb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nsb3Npbmcgc2Vzc2lvbiBpbml0aWF0ZWQgYnkgJyArICgoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQoc2Vzc2lvbkluZm8ucmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoc2Vzc2lvbkluZm8ucmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbG9zZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoY2xvc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGxldGVVbmJpbmQoYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgYm91bmRQb3J0T2JqZWN0Lmxpc3RlbmluZ1NlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2VydmVyKHNlcnZlciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0Lmxpc3RlbmluZ1NlcnZlcnMuZGVsZXRlKHNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVySW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlcnZlckluZm8uc2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMuZGVsZXRlKGJvdW5kUG9ydE9iamVjdC5tYXBLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmJpbmQgYSBwcmV2aW91c2x5IGJvdW5kIHBvcnQsIG9yIGNhbmNlbCBhbiBpbi1wcm9ncmVzcyBiaW5kQXN5bmNcbiAgICAgICAgICAgICAqIG9wZXJhdGlvbi4gSWYgcG9ydCAwIHdhcyBib3VuZCwgb25seSB0aGUgYWN0dWFsIGJvdW5kIHBvcnQgY2FuIGJlXG4gICAgICAgICAgICAgKiB1bmJvdW5kLiBGb3IgZXhhbXBsZSwgaWYgYmluZEFzeW5jIHdhcyBjYWxsZWQgd2l0aCBcImxvY2FsaG9zdDowXCIgYW5kIHRoZVxuICAgICAgICAgICAgICogYm91bmQgcG9ydCByZXN1bHQgd2FzIDU0MzIxLCBpdCBjYW4gYmUgdW5ib3VuZCBhcyBcImxvY2FsaG9zdDo1NDMyMVwiLlxuICAgICAgICAgICAgICogQHBhcmFtIHBvcnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdW5iaW5kKHBvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCd1bmJpbmQgcG9ydD0nICsgcG9ydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFVyaSA9IHRoaXMubm9ybWFsaXplUG9ydChwb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBvcnRVcmkucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKChzcGxpdFBvcnQgPT09IG51bGwgfHwgc3BsaXRQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdFBvcnQucG9ydCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5iaW5kIHBvcnQgMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZFBvcnRPYmplY3QgPSB0aGlzLmJvdW5kUG9ydHMuZ2V0KCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBvcnRVcmkpKTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3VuYmluZGluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5tYXBLZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBvcmlnaW5hbGx5IGJvdW5kIGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykoYm91bmRQb3J0T2JqZWN0Lm9yaWdpbmFsVXJpKSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiaW5kIG9wZXJhdGlvbiBpcyBwZW5kaW5nLCB0aGUgY2FuY2VsbGVkIGZsYWcgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSB1bmJpbmQgb3BlcmF0aW9uIGxhdGVyLiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVVbmJpbmQoYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JhY2VmdWxseSBjbG9zZSBhbGwgY29ubmVjdGlvbnMgYXNzb2NpYXRlZCB3aXRoIGEgcHJldmlvdXNseSBib3VuZCBwb3J0LlxuICAgICAgICAgICAgICogQWZ0ZXIgdGhlIGdyYWNlIHRpbWUsIGZvcmNlZnVsbHkgY2xvc2UgYWxsIHJlbWFpbmluZyBvcGVuIGNvbm5lY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElmIHBvcnQgMCB3YXMgYm91bmQsIG9ubHkgdGhlIGFjdHVhbCBib3VuZCBwb3J0IGNhbiBiZVxuICAgICAgICAgICAgICogZHJhaW5lZC4gRm9yIGV4YW1wbGUsIGlmIGJpbmRBc3luYyB3YXMgY2FsbGVkIHdpdGggXCJsb2NhbGhvc3Q6MFwiIGFuZCB0aGVcbiAgICAgICAgICAgICAqIGJvdW5kIHBvcnQgcmVzdWx0IHdhcyA1NDMyMSwgaXQgY2FuIGJlIGRyYWluZWQgYXMgXCJsb2NhbGhvc3Q6NTQzMjFcIi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBwb3J0XG4gICAgICAgICAgICAgKiBAcGFyYW0gZ3JhY2VUaW1lTXNcbiAgICAgICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWluKHBvcnQsIGdyYWNlVGltZU1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdkcmFpbiBwb3J0PScgKyBwb3J0ICsgJyBncmFjZVRpbWVNcz0nICsgZ3JhY2VUaW1lTXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRVcmkgPSB0aGlzLm5vcm1hbGl6ZVBvcnQocG9ydCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwb3J0VXJpLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICgoc3BsaXRQb3J0ID09PSBudWxsIHx8IHNwbGl0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXRQb3J0LnBvcnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRyYWluIHBvcnQgMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZFBvcnRPYmplY3QgPSB0aGlzLmJvdW5kUG9ydHMuZ2V0KCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBvcnRVcmkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kUG9ydE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFNlc3Npb25zID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaHR0cDJTZXJ2ZXIgb2YgYm91bmRQb3J0T2JqZWN0Lmxpc3RlbmluZ1NlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyRW50cnkgPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoaHR0cDJTZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vzc2lvbiBvZiBzZXJ2ZXJFbnRyeS5zZXNzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNlc3Npb25zLmFkZChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBZnRlciB0aGUgZ3JhY2UgdGltZSBlbmRzLCBzZW5kIGFub3RoZXIgZ29hd2F5IHRvIGFsbCByZW1haW5pbmcgc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAgKiB3aXRoIHRoZSBDQU5DRUwgY29kZS4gKi9cbiAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIGFsbFNlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmRlc3Ryb3koaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGdyYWNlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcmNlU2h1dGRvd24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBib3VuZFBvcnRPYmplY3Qgb2YgdGhpcy5ib3VuZFBvcnRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGUgc2VydmVyIGlmIGl0IGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgdGhpcy5odHRwMlNlcnZlcnMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXJ2ZXIoc2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGRlc3Ryb3kgYW55IGF2YWlsYWJsZSBzZXNzaW9ucy4gSXQncyBwb3NzaWJsZSB0aGF0IG9uZSBvciBtb3JlXG4gICAgICAgICAgICAgICAgLy8gdHJ5U2h1dGRvd24oKSBjYWxscyBhcmUgaW4gcHJvZ3Jlc3MuIERvbid0IHdhaXQgb24gdGhlbSB0byBmaW5pc2guXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChjaGFubmVsekluZm8sIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhc3QgTkdIVFRQMl9DQU5DRUwgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHNlZW0gdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb2duaXplIGRlc3Ryb3koY29kZSkgYXMgYSB2YWxpZCBzaWduYXR1cmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2h1dGRvd24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYzogaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIG5lZWRlZCBhcyBvZiB2ZXJzaW9uIDEuMTAueFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5odHRwMlNlcnZlcnMuc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBbLi4udGhpcy5odHRwMlNlcnZlcnMua2V5cygpXS5ldmVyeShzZXJ2ZXIgPT4gIXNlcnZlci5saXN0ZW5pbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmVyIG11c3QgYmUgYm91bmQgaW4gb3JkZXIgdG8gc3RhcnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeVNodXRkb3duKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgcGVuZGluZ0NoZWNrcyA9IDA7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoZWNrcy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0NoZWNrcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2VydmVyS2V5LCBzZXJ2ZXJdIG9mIHRoaXMuaHR0cDJTZXJ2ZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN0cmluZyA9IHNlcnZlci5jaGFubmVselJlZi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdXYWl0aW5nIGZvciBzZXJ2ZXIgJyArIHNlcnZlclN0cmluZyArICcgdG8gY2xvc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlcnZlcihzZXJ2ZXJLZXksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciAnICsgc2VydmVyU3RyaW5nICsgJyBmaW5pc2hlZCBjbG9zaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2VydmVyLnNlc3Npb25zLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoZWNrcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblN0cmluZyA9IChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1dhaXRpbmcgZm9yIHNlc3Npb24gJyArIHNlc3Npb25TdHJpbmcgKyAnIHRvIGNsb3NlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU2Vzc2lvbiAnICsgc2Vzc2lvblN0cmluZyArICcgZmluaXNoZWQgY2xvc2luZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEh0dHAyUG9ydCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIHNlcnZlci4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICAgICAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIHNlcnZlci5cbiAgICAgICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc1todHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VHlwZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgIWNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2dycGMnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfVU5TVVBQT1JURURfTUVESUFfVFlQRSxcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmV0cmlldmVIYW5kbGVyKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDYWxsVHJhY2UoJ1JlY2VpdmVkIGNhbGwgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyBhdCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckNhbGxUcmFjZSgnTm8gaGFuZGxlciByZWdpc3RlcmVkIGZvciBtZXRob2QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcuIFNlbmRpbmcgVU5JTVBMRU1FTlRFRCBzdGF0dXMuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXNwb25kV2l0aEVycm9yKGVyciwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgJ2dycGMtc3RhdHVzJzogKF9iID0gZXJyLmNvZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ2dycGMtbWVzc2FnZSc6IGVyci5kZXRhaWxzLCBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfT0ssIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV06ICdhcHBsaWNhdGlvbi9ncnBjK3Byb3RvJyB9LCAoX2MgPSBlcnIubWV0YWRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0h0dHAySGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVzcG9uZCh0cmFpbGVyc1RvU2VuZCwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NoYW5uZWx6SGFuZGxlcihleHRyYUludGVyY2VwdG9ycywgc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGhhbmRsaW5nIGlkbGUgdGltZW91dFxuICAgICAgICAgICAgICAgIHRoaXMub25TdHJlYW1PcGVuZWQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc3RyZWFtLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBjaGFubmVselNlc3Npb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRXZlbnRUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLm1lc3NhZ2VzU2VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gKDAsIHNlcnZlcl9pbnRlcmNlcHRvcnNfMS5nZXRTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsKShbLi4uZXh0cmFJbnRlcmNlcHRvcnMsIC4uLnRoaXMuaW50ZXJjZXB0b3JzXSwgc3RyZWFtLCBoZWFkZXJzLCBjYWxsRXZlbnRUcmFja2VyLCBoYW5kbGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N0cmVhbUhhbmRsZXIoZXh0cmFJbnRlcmNlcHRvcnMsIHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBoYW5kbGluZyBpZGxlIHRpbWVvdXRcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RyZWFtT3BlbmVkKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZFdpdGhFcnJvcihnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UocGF0aCksIHN0cmVhbSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuZ2V0U2VydmVySW50ZXJjZXB0aW5nQ2FsbCkoWy4uLmV4dHJhSW50ZXJjZXB0b3JzLCAuLi50aGlzLmludGVyY2VwdG9yc10sIHN0cmVhbSwgaGVhZGVycywgbnVsbCwgaGFuZGxlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5rbm93biBoYW5kbGVyIHR5cGU6ICR7aGFuZGxlci50eXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY2xpZW50U3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzZXJ2ZXJTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJpZGlTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NldHVwSGFuZGxlcnMoaHR0cDJTZXJ2ZXIsIGV4dHJhSW50ZXJjZXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VydmVyQWRkcmVzc1N0cmluZyA9ICdudWxsJztcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcnZlckFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gc2VydmVyQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzLmFkZHJlc3MgKyAnOicgKyBzZXJ2ZXJBZGRyZXNzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gc2VydmVyQWRkcmVzc1N0cmluZztcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jaGFubmVsekhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9zdHJlYW1IYW5kbGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25IYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jaGFubmVselNlc3Npb25IYW5kbGVyKGh0dHAyU2VydmVyKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3Nlc3Npb25IYW5kbGVyKGh0dHAyU2VydmVyKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc3RyZWFtJywgaGFuZGxlci5iaW5kKHRoaXMsIGV4dHJhSW50ZXJjZXB0b3JzKSk7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3Nlc3Npb24nLCBzZXNzaW9uSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc2Vzc2lvbkhhbmRsZXIoaHR0cDJTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KGh0dHAyU2VydmVyKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlc3Npb25zLmFkZChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0aW9uQWdlR3JhY2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRsZVRpbWVvdXRPYmogPSB0aGlzLmVuYWJsZUlkbGVUaW1lb3V0KHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgIT09IFVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSByYW5kb20gaml0dGVyIHdpdGhpbiBhICsvLTEwJSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgLyAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiBqaXR0ZXJNYWduaXR1ZGUgKiAyIC0gaml0dGVyTWFnbml0dWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFnZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBtYXggY29ubmVjdGlvbiBhZ2U6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nb2F3YXkoaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1IsIH4oMSA8PCAzMSksIGtNYXhBZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ29hd2F5IGNhbid0IGJlIHNlbnQgYmVjYXVzZSB0aGUgc2Vzc2lvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWxsb3cgYSBncmFjZSBwZXJpb2QgYWZ0ZXIgc2VuZGluZyB0aGUgR09BV0FZIGJlZm9yZSBmb3JjaWJseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4Q29ubmVjdGlvbkFnZUdyYWNlTXMgIT09IFVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlR3JhY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubWF4Q29ubmVjdGlvbkFnZUdyYWNlTXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBjb25uZWN0aW9uQWdlR3JhY2VUaW1lci51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICsgaml0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IGNvbm5lY3Rpb25BZ2VUaW1lci51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoY29ubmVjdGlvbkFnZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhcktlZXBhbGl2ZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoa2VlcGFsaXZlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuU2VuZFBpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFzZXNzaW9uLmRlc3Ryb3llZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zIDwgS0VFUEFMSVZFX01BWF9USU1FX01TICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdCAqL1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VuZFBpbmc7IC8vIGhvaXN0ZWQgZm9yIHVzZSBpbiBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhblNlbmRQaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTdGFydGluZyBrZWVwYWxpdmUgdGltZXIgZm9yICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVNcyArICdtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2VlcGFsaXZlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFBpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhblNlbmRQaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBpbmdTZW5kRXJyb3IgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGluZ1NlbnRTdWNjZXNzZnVsbHkgPSBzZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgZmFpbGVkIHdpdGggZXJyb3I6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwaW5nU2VudFN1Y2Nlc3NmdWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5nU2VuZEVycm9yID0gJ1BpbmcgcmV0dXJuZWQgZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJycpIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBzZW5kIGZhaWxlZDogJyArIHBpbmdTZW5kRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZHJvcHBlZCBkdWUgdG8gcGluZyBzZW5kIGVycm9yOiAnICsgcGluZ1NlbmRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcGFsaXZlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdDb25uZWN0aW9uIGRyb3BwZWQgYnkga2VlcGFsaXZlIHRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGtlZXBhbGl2ZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChrZWVwYWxpdmVUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKGBDb25uZWN0aW9uIGRyb3BwZWQgYnkgY2xpZW50ICR7KF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25BZ2VUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWdlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkbGVUaW1lb3V0T2JqLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5kZWxldGUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoaHR0cDJTZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NoYW5uZWx6U2Vzc2lvbkhhbmRsZXIoaHR0cDJTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQpKChfYyA9IChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ3Vua25vd24nLCB0aGlzLmdldENoYW5uZWx6U2Vzc2lvbkluZm8uYmluZCh0aGlzLCBzZXNzaW9uKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjaGFubmVselJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVRyYWNrZXI6IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcikpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zZXNzaW9ucy5hZGQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuc2V0KHNlc3Npb24sIGNoYW5uZWx6U2Vzc2lvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRBZGRyZXNzID0gYCR7c2Vzc2lvbi5zb2NrZXQucmVtb3RlQWRkcmVzc306JHtzZXNzaW9uLnNvY2tldC5yZW1vdGVQb3J0fWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGVzdGFibGlzaGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZXN0YWJsaXNoZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0aW9uQWdlR3JhY2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZWVwYWxpdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuZW5hYmxlSWRsZVRpbWVvdXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHJhbmRvbSBqaXR0ZXIgd2l0aGluIGEgKy8tMTAlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSB0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyAvIDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIGppdHRlck1hZ25pdHVkZSAqIDIgLSBqaXR0ZXJNYWduaXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IG1heCBjb25uZWN0aW9uIGFnZSBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmdvYXdheShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUiwgfigxIDw8IDMxKSwga01heEFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBnb2F3YXkgY2FuJ3QgYmUgc2VudCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBhIGdyYWNlIHBlcmlvZCBhZnRlciBzZW5kaW5nIHRoZSBHT0FXQVkgYmVmb3JlIGZvcmNpYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY2xvc2luZyB0aGUgY29ubmVjdGlvbi4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgKyBqaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gY29ubmVjdGlvbkFnZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChjb25uZWN0aW9uQWdlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFyS2VlcGFsaXZlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZWVwYWxpdmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5TZW5kUGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIXNlc3Npb24uZGVzdHJveWVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZW5kUGluZzsgLy8gaG9pc3RlZCBmb3IgdXNlIGluIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGtlZXBhbGl2ZVRpbWVvdXQudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGtlZXBhbGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZW5kUGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGluZ1NlbmRFcnJvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaW5nU2VudFN1Y2Nlc3NmdWxseSA9IHNlc3Npb24ucGluZygoZXJyLCBkdXJhdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgZHVlIHRvIGVycm9yIG9mIGEgcGluZyBmcmFtZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyByZXR1cm4gaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGluZ1NlbnRTdWNjZXNzZnVsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9ICdQaW5nIHJldHVybmVkIGZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdycGMvZ3JwYy1ub2RlIzIxMzlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5nU2VuZEVycm9yID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICcnKSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGluZ1NlbmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1Bpbmcgc2VuZCBmYWlsZWQ6ICcgKyBwaW5nU2VuZEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGR1ZSB0byBwaW5nIHNlbmQgZXJyb3I6ICcgKyBwaW5nU2VuZEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmtlZXBBbGl2ZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyB0aW1lb3V0IHBhc3NlZCB3aXRob3V0IHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBrZWVwYWxpdmUgdGltZW91dCBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGtlZXBhbGl2ZVRpbWVvdXQudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGtlZXBhbGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFnZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGxlVGltZW91dE9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZGxlVGltZW91dE9iai50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZGxlVGltZW91dHMuZGVsZXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KGh0dHAyU2VydmVyKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5hYmxlSWRsZVRpbWVvdXQoc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0ID49IE1BWF9DT05ORUNUSU9OX0lETEVfTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVUaW1lb3V0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW1zOiAwLFxuICAgICAgICAgICAgICAgICAgICBsYXN0SWRsZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogdGhpcy5vblN0cmVhbUNsb3NlLmJpbmQodGhpcywgc2Vzc2lvbiksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQodGhpcy5vbklkbGVUaW1lb3V0LCB0aGlzLnNlc3Npb25JZGxlVGltZW91dCwgdGhpcywgc2Vzc2lvbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBpZGxlVGltZW91dE9iai50aW1lb3V0KS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5zZXQoc2Vzc2lvbiwgaWRsZVRpbWVvdXRPYmopO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc29ja2V0IH0gPSBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0VuYWJsZSBpZGxlIHRpbWVvdXQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3RlQWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdGVQb3J0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRsZVRpbWVvdXRPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbklkbGVUaW1lb3V0KGN0eCwgc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc29ja2V0IH0gPSBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gY3R4LnNlc3Npb25JZGxlVGltZW91dHMuZ2V0KHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGNhbGxlZCB3aGlsZSB3ZSBoYXZlIGFjdGl2ZVN0cmVhbXMgLSB0aW1lciB3aWxsIG5vdCBiZSByZXNjaGVkdWxlZFxuICAgICAgICAgICAgICAgIC8vIHVudGlsIGxhc3QgYWN0aXZlIHN0cmVhbSBpcyBjbG9zZWQsIHRoZW4gaXQgd2lsbCBjYWxsIC5yZWZyZXNoKCkgb24gdGhlIHRpbWVyXG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IHBhcnQgaXMgdG8gbm90IGNsZWFyVGltZW91dCh0aW1lcikgb3IgaXQgYmVjb21lcyB1bnVzYWJsZVxuICAgICAgICAgICAgICAgIC8vIGZvciBmdXR1cmUgcmVmcmVzaGVzXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25JbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkluZm8uYWN0aXZlU3RyZWFtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHNlc3Npb25JbmZvLmxhc3RJZGxlID49IGN0eC5zZXNzaW9uSWRsZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFjZSgnU2Vzc2lvbiBpZGxlIHRpbWVvdXQgdHJpZ2dlcmVkIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc29ja2V0ID09PSBudWxsIHx8IHNvY2tldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ja2V0LnJlbW90ZUFkZHJlc3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlUG9ydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgbGFzdCBpZGxlIGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JbmZvLmxhc3RJZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby50aW1lb3V0LnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uU3RyZWFtT3BlbmVkKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBzdHJlYW0uc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0T2JqLmFjdGl2ZVN0cmVhbXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgaWRsZVRpbWVvdXRPYmoub25DbG9zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdHJlYW1DbG9zZShzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0T2JqLmFjdGl2ZVN0cmVhbXMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqLmFjdGl2ZVN0cmVhbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0T2JqLmxhc3RJZGxlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0T2JqLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU2Vzc2lvbiBvblN0cmVhbUNsb3NlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVtb3RlUG9ydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmoubGFzdElkbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfc3RhcnRfZGVjb3JhdG9ycyA9IFtkZXByZWNhdGUoJ0NhbGxpbmcgc3RhcnQoKSBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LiBJdCBjYW4gYmUgc2FmZWx5IG9taXR0ZWQuJyldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKF9hLCBudWxsLCBfc3RhcnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInN0YXJ0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzdGFydFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnN0YXJ0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgX2E7XG59KSgpO1xuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyKSB7XG4gICAgbGV0IHN0cmVhbTtcbiAgICBmdW5jdGlvbiByZXNwb25kKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cygoMCwgc2VydmVyX2NhbGxfMS5zZXJ2ZXJFcnJvclRvU3RhdHVzKShlcnIsIHRyYWlsZXIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKHZhbHVlLCAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFpbGVyICE9PSBudWxsICYmIHRyYWlsZXIgIT09IHZvaWQgMCA/IHRyYWlsZXIgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1ldGFkYXRhO1xuICAgIGxldCByZXF1ZXN0TWVzc2FnZSA9IG51bGw7XG4gICAgY2FsbC5zdGFydCh7XG4gICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICByZXF1ZXN0TWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIGNhbGwuc3RhcnRSZWFkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBhIHNlY29uZCByZXF1ZXN0IG1lc3NhZ2UgZm9yIHNlcnZlciBzdHJlYW1pbmcgbWV0aG9kICR7aGFuZGxlci5wYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNhbGwuc3RhcnRSZWFkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG5vIHJlcXVlc3QgbWVzc2FnZSBmb3Igc2VydmVyIHN0cmVhbWluZyBtZXRob2QgJHtoYW5kbGVyLnBhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsKGhhbmRsZXIucGF0aCwgY2FsbCwgcmVxdWVzdE1ldGFkYXRhLCByZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VydmVyIG1ldGhvZCBoYW5kbGVyIHRocmV3IGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2FuY2VsKCkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcikge1xuICAgIGxldCBzdHJlYW07XG4gICAgZnVuY3Rpb24gcmVzcG9uZChlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoKDAsIHNlcnZlcl9jYWxsXzEuc2VydmVyRXJyb3JUb1N0YXR1cykoZXJyLCB0cmFpbGVyKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZSh2YWx1ZSwgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ09LJyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogdHJhaWxlciAhPT0gbnVsbCAmJiB0cmFpbGVyICE9PSB2b2lkIDAgPyB0cmFpbGVyIDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FsbC5zdGFydCh7XG4gICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsKGhhbmRsZXIucGF0aCwgY2FsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtLCByZXNwb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlcnZlciBtZXRob2QgaGFuZGxlciB0aHJldyBlcnJvciAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBvblJlY2VpdmVIYWxmQ2xvc2UoKSB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIpIHtcbiAgICBsZXQgc3RyZWFtO1xuICAgIGxldCByZXF1ZXN0TWV0YWRhdGE7XG4gICAgbGV0IHJlcXVlc3RNZXNzYWdlID0gbnVsbDtcbiAgICBjYWxsLnN0YXJ0KHtcbiAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJlcXVlc3RNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIGEgc2Vjb25kIHJlcXVlc3QgbWVzc2FnZSBmb3Igc2VydmVyIHN0cmVhbWluZyBtZXRob2QgJHtoYW5kbGVyLnBhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbm8gcmVxdWVzdCBtZXNzYWdlIGZvciBzZXJ2ZXIgc3RyZWFtaW5nIG1ldGhvZCAke2hhbmRsZXIucGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCByZXF1ZXN0TWV0YWRhdGEsIHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZXJ2ZXIgbWV0aG9kIGhhbmRsZXIgdGhyZXcgZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQmlkaVN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKSB7XG4gICAgbGV0IHN0cmVhbTtcbiAgICBjYWxsLnN0YXJ0KHtcbiAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlckR1cGxleFN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VydmVyIG1ldGhvZCBoYW5kbGVyIHRocmV3IGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNhbmNlbCgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateRetryThrottling = validateRetryThrottling;\nexports.validateServiceConfig = validateServiceConfig;\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if ('service' in obj && obj.service !== '') {\n        if (typeof obj.service !== 'string') {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if ('method' in obj && obj.method !== '') {\n            if (typeof obj.method !== 'string') {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method,\n            };\n        }\n        else {\n            return {\n                service: obj.service,\n            };\n        }\n    }\n    else {\n        if ('method' in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n    }\n    if (!('initialBackoff' in obj) ||\n        typeof obj.initialBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');\n    }\n    if (!('maxBackoff' in obj) ||\n        typeof obj.maxBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');\n    }\n    if (!('backoffMultiplier' in obj) ||\n        typeof obj.backoffMultiplier !== 'number' ||\n        obj.backoffMultiplier <= 0) {\n        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n    }\n    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n    }\n    for (const value of obj.retryableStatusCodes) {\n        if (typeof value === 'number') {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n            }\n        }\n        else if (typeof value === 'string') {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n            }\n        }\n        else {\n            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes,\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n    }\n    if ('hedgingDelay' in obj &&\n        (typeof obj.hedgingDelay !== 'string' ||\n            !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n    }\n    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes) {\n            if (typeof value === 'number') {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');\n                }\n            }\n            else if (typeof value === 'string') {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');\n                }\n            }\n            else {\n                throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts,\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: [],\n    };\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\n        throw new Error('Invalid method config: invalid name array');\n    }\n    for (const name of obj.name) {\n        result.name.push(validateName(name));\n    }\n    if ('waitForReady' in obj) {\n        if (typeof obj.waitForReady !== 'boolean') {\n            throw new Error('Invalid method config: invalid waitForReady');\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if ('timeout' in obj) {\n        if (typeof obj.timeout === 'object') {\n            if (!('seconds' in obj.timeout) ||\n                !(typeof obj.timeout.seconds === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.seconds');\n            }\n            if (!('nanos' in obj.timeout) ||\n                !(typeof obj.timeout.nanos === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.nanos');\n            }\n            result.timeout = obj.timeout;\n        }\n        else if (typeof obj.timeout === 'string' &&\n            DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout\n                .substring(0, obj.timeout.length - 1)\n                .split('.');\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\n            };\n        }\n        else {\n            throw new Error('Invalid method config: invalid timeout');\n        }\n    }\n    if ('maxRequestBytes' in obj) {\n        if (typeof obj.maxRequestBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if ('maxResponseBytes' in obj) {\n        if (typeof obj.maxResponseBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if ('retryPolicy' in obj) {\n        if ('hedgingPolicy' in obj) {\n            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n        }\n        else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    }\n    else if ('hedgingPolicy' in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!('maxTokens' in obj) ||\n        typeof obj.maxTokens !== 'number' ||\n        obj.maxTokens <= 0 ||\n        obj.maxTokens > 1000) {\n        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n    }\n    if (!('tokenRatio' in obj) ||\n        typeof obj.tokenRatio !== 'number' ||\n        obj.tokenRatio <= 0) {\n        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3),\n    };\n}\nfunction validateLoadBalancingConfig(obj) {\n    if (!(typeof obj === 'object' && obj !== null)) {\n        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);\n    }\n    const keys = Object.keys(obj);\n    if (keys.length > 1) {\n        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);\n    }\n    if (keys.length === 0) {\n        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');\n    }\n    return {\n        [keys[0]]: obj[keys[0]],\n    };\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n    };\n    if ('loadBalancingPolicy' in obj) {\n        if (typeof obj.loadBalancingPolicy === 'string') {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\n        }\n    }\n    if ('loadBalancingConfig' in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig) {\n                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n            }\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\n        }\n    }\n    if ('methodConfig' in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig) {\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if ('retryThrottling' in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig) {\n        for (const name of methodConfig.name) {\n            for (const seenName of seenMethodNames) {\n                if (name.service === seenName.service &&\n                    name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nfunction validateCanaryConfig(obj) {\n    if (!('serviceConfig' in obj)) {\n        throw new Error('Invalid service config choice: missing service config');\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\n    };\n    if ('clientLanguage' in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage) {\n                if (typeof lang === 'string') {\n                    result.clientLanguage.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n    }\n    if ('clientHostname' in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname) {\n                if (typeof lang === 'string') {\n                    result.clientHostname.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientHostname');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n    }\n    if ('percentage' in obj) {\n        if (typeof obj.percentage === 'number' &&\n            0 <= obj.percentage &&\n            obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid percentage');\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        'clientLanguage',\n        'percentage',\n        'clientHostname',\n        'serviceConfig',\n    ];\n    for (const field in obj) {\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error('Invalid service config list');\n    }\n    for (const config of obj) {\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */\n        if (typeof validatedConfig.percentage === 'number' &&\n            percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname) {\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage) {\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord) {\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n            const recordString = record.join('').substring('grpc_config='.length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2aWNlLWNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLG1CQUFtQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsbUJBQW1CO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxhQUFhLEdBQUcsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2aWNlLWNvbmZpZy5qcz9mMjBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nID0gdmFsaWRhdGVSZXRyeVRocm90dGxpbmc7XG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZztcbi8qIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGdSRkMgQTIgYW5kIHRoZSBzZXJ2aWNlIGNvbmZpZyBzcGVjOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTItc2VydmljZS1jb25maWdzLWluLWRucy5tZFxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2Mvc2VydmljZV9jb25maWcubWQuIEVhY2hcbiAqIGZ1bmN0aW9uIGhlcmUgdGFrZXMgYW4gb2JqZWN0IHdpdGggdW5rbm93biBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgaXRzXG4gKiBzcGVjaWZpYyBvYmplY3QgdHlwZSBpZiB0aGUgaW5wdXQgaGFzIHRoZSByaWdodCBzdHJ1Y3R1cmUsIGFuZCB0aHJvd3MgYW5cbiAqIGVycm9yIG90aGVyd2lzZS4gKi9cbi8qIFRoZSBhbnkgdHlwZSBpcyBwdXJwb3NlbHkgdXNlZCBoZXJlLiBBbGwgZnVuY3Rpb25zIHZhbGlkYXRlIHRoZWlyIGlucHV0IGF0XG4gKiBydW50aW1lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBSZWNvZ25pemVzIGEgbnVtYmVyIHdpdGggdXAgdG8gOSBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGZvbGxvd2VkIGJ5XG4gKiBhbiBcInNcIiwgcmVwcmVzZW50aW5nIGEgbnVtYmVyIG9mIHNlY29uZHMuXG4gKi9cbmNvbnN0IERVUkFUSU9OX1JFR0VYID0gL15cXGQrKFxcLlxcZHsxLDl9KT9zJC87XG4vKipcbiAqIENsaWVudCBsYW5ndWFnZSBuYW1lIHVzZWQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhpcyBjbGllbnQgbWF0Y2hlcyBhXG4gKiBgU2VydmljZUNvbmZpZ0NhbmFyeUNvbmZpZ2AncyBgY2xpZW50TGFuZ3VhZ2VgIGxpc3QuXG4gKi9cbmNvbnN0IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcgPSAnbm9kZSc7XG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUob2JqKSB7XG4gICAgLy8gSW4gdGhpcyBjb250ZXh0LCBhbmQgdW5zZXQgZmllbGQgYW5kICcnIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAgaWYgKCdzZXJ2aWNlJyBpbiBvYmogJiYgb2JqLnNlcnZpY2UgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnNlcnZpY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBpbnZhbGlkIHNlcnZpY2U6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmoubWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgbWV0aG9kOiBleHBlY3RlZCB0eXBlIHN0cmluZywgZ290ICR7dHlwZW9mIG9iai5zZXJ2aWNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBvYmouc2VydmljZSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG9iai5tZXRob2QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBvYmouc2VydmljZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICgnbWV0aG9kJyBpbiBvYmogJiYgb2JqLm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBtZXRob2Qgc2V0IHdpdGggZW1wdHkgb3IgdW5zZXQgc2VydmljZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJ5UG9saWN5KG9iaikge1xuICAgIGlmICghKCdtYXhBdHRlbXB0cycgaW4gb2JqKSB8fFxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvYmoubWF4QXR0ZW1wdHMpIHx8XG4gICAgICAgIG9iai5tYXhBdHRlbXB0cyA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiBtYXhBdHRlbXB0cyBtdXN0IGJlIGFuIGludGVnZXIgYXQgbGVhc3QgMicpO1xuICAgIH1cbiAgICBpZiAoISgnaW5pdGlhbEJhY2tvZmYnIGluIG9iaikgfHxcbiAgICAgICAgdHlwZW9mIG9iai5pbml0aWFsQmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLmluaXRpYWxCYWNrb2ZmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IGluaXRpYWxCYWNrb2ZmIG11c3QgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBvZiBhIHBvc2l0aXZlIGludGVnZXIgb3IgZGVjaW1hbCBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICghKCdtYXhCYWNrb2ZmJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLm1heEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QmFja29mZiBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGRlY2ltYWwgZm9sbG93ZWQgYnkgcycpO1xuICAgIH1cbiAgICBpZiAoISgnYmFja29mZk11bHRpcGxpZXInIGluIG9iaikgfHxcbiAgICAgICAgdHlwZW9mIG9iai5iYWNrb2ZmTXVsdGlwbGllciAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLmJhY2tvZmZNdWx0aXBsaWVyIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiBiYWNrb2ZmTXVsdGlwbGllciBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIGlmICghKCdyZXRyeWFibGVTdGF0dXNDb2RlcycgaW4gb2JqICYmIEFycmF5LmlzQXJyYXkob2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAob2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIG11c3QgYmUgbm9uLWVtcHR5Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG5vdCBpbiBzdGF0dXMgY29kZSByYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgYSBzdGF0dXMgY29kZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcbiAgICAgICAgaW5pdGlhbEJhY2tvZmY6IG9iai5pbml0aWFsQmFja29mZixcbiAgICAgICAgbWF4QmFja29mZjogb2JqLm1heEJhY2tvZmYsXG4gICAgICAgIGJhY2tvZmZNdWx0aXBsaWVyOiBvYmouYmFja29mZk11bHRpcGxpZXIsXG4gICAgICAgIHJldHJ5YWJsZVN0YXR1c0NvZGVzOiBvYmoucmV0cnlhYmxlU3RhdHVzQ29kZXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSGVkZ2luZ1BvbGljeShvYmopIHtcbiAgICBpZiAoISgnbWF4QXR0ZW1wdHMnIGluIG9iaikgfHxcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIob2JqLm1heEF0dGVtcHRzKSB8fFxuICAgICAgICBvYmoubWF4QXR0ZW1wdHMgPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBtYXhBdHRlbXB0cyBtdXN0IGJlIGFuIGludGVnZXIgYXQgbGVhc3QgMicpO1xuICAgIH1cbiAgICBpZiAoJ2hlZGdpbmdEZWxheScgaW4gb2JqICYmXG4gICAgICAgICh0eXBlb2Ygb2JqLmhlZGdpbmdEZWxheSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5oZWRnaW5nRGVsYXkpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogaGVkZ2luZ0RlbGF5IG11c3QgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBvZiBhIHBvc2l0aXZlIGludGVnZXIgZm9sbG93ZWQgYnkgcycpO1xuICAgIH1cbiAgICBpZiAoJ25vbkZhdGFsU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5ub25GYXRhbFN0YXR1c0NvZGVzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5ub25GYXRhbFN0YXR1c0NvZGVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBub25GYXRhbFN0YXR1c0NvZGVzIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBtYXhBdHRlbXB0czogb2JqLm1heEF0dGVtcHRzLFxuICAgIH07XG4gICAgaWYgKG9iai5oZWRnaW5nRGVsYXkpIHtcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdEZWxheSA9IG9iai5oZWRnaW5nRGVsYXk7XG4gICAgfVxuICAgIGlmIChvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xuICAgICAgICByZXN1bHQubm9uRmF0YWxTdGF0dXNDb2RlcyA9IG9iai5ub25GYXRhbFN0YXR1c0NvZGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RDb25maWcob2JqKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogW10sXG4gICAgfTtcbiAgICBpZiAoISgnbmFtZScgaW4gb2JqKSB8fCAhQXJyYXkuaXNBcnJheShvYmoubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbmFtZSBhcnJheScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb2JqLm5hbWUpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUucHVzaCh2YWxpZGF0ZU5hbWUobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoJ3dhaXRGb3JSZWFkeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLndhaXRGb3JSZWFkeSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB3YWl0Rm9yUmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdEZvclJlYWR5ID0gb2JqLndhaXRGb3JSZWFkeTtcbiAgICB9XG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWNvbmRzJyBpbiBvYmoudGltZW91dCkgfHxcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5zZWNvbmRzID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0LnNlY29uZHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCduYW5vcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQubmFub3MgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQubmFub3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0gb2JqLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgRFVSQVRJT05fUkVHRVgudGVzdChvYmoudGltZW91dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQYXJ0cyA9IG9iai50aW1lb3V0XG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCBvYmoudGltZW91dC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kczogdGltZW91dFBhcnRzWzBdIHwgMCxcbiAgICAgICAgICAgICAgICBuYW5vczogKChfYSA9IHRpbWVvdXRQYXJ0c1sxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgfCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ21heFJlcXVlc3RCeXRlcycgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlcXVlc3RCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXF1ZXN0Qnl0ZXMgPSBvYmoubWF4UmVxdWVzdEJ5dGVzO1xuICAgIH1cbiAgICBpZiAoJ21heFJlc3BvbnNlQnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXNwb25zZUJ5dGVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1heFJlc3BvbnNlQnl0ZXMgPSBvYmoubWF4UmVzcG9uc2VCeXRlcztcbiAgICB9XG4gICAgaWYgKCdyZXRyeVBvbGljeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICgnaGVkZ2luZ1BvbGljeScgaW4gb2JqKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogcmV0cnlQb2xpY3kgYW5kIGhlZGdpbmdQb2xpY3kgY2Fubm90IGJvdGggYmUgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucmV0cnlQb2xpY3kgPSB2YWxpZGF0ZVJldHJ5UG9saWN5KG9iai5yZXRyeVBvbGljeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoJ2hlZGdpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICByZXN1bHQuaGVkZ2luZ1BvbGljeSA9IHZhbGlkYXRlSGVkZ2luZ1BvbGljeShvYmouaGVkZ2luZ1BvbGljeSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmopIHtcbiAgICBpZiAoISgnbWF4VG9rZW5zJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoubWF4VG9rZW5zICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBvYmoubWF4VG9rZW5zIDw9IDAgfHxcbiAgICAgICAgb2JqLm1heFRva2VucyA+IDEwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogbWF4VG9rZW5zIG11c3QgYmUgYSBudW1iZXIgaW4gKDAsIDEwMDBdJyk7XG4gICAgfVxuICAgIGlmICghKCd0b2tlblJhdGlvJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoudG9rZW5SYXRpbyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLnRva2VuUmF0aW8gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmV0cnlUaHJvdHRsaW5nOiB0b2tlblJhdGlvIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF4VG9rZW5zOiArb2JqLm1heFRva2Vucy50b0ZpeGVkKDMpLFxuICAgICAgICB0b2tlblJhdGlvOiArb2JqLnRva2VuUmF0aW8udG9GaXhlZCgzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKG9iaikge1xuICAgIGlmICghKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxvYWRCYWxhbmNpbmdDb25maWc6IHVuZXhwZWN0ZWQgdHlwZSAke3R5cGVvZiBvYmp9YCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxvYWRCYWxhbmNpbmdDb25maWc6IHVuZXhwZWN0ZWQgbXVsdGlwbGUga2V5cyAke2tleXN9YCk7XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZCBiYWxhbmNpbmcgcG9saWN5IG5hbWUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW2tleXNbMF1dOiBvYmpba2V5c1swXV0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgIH07XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nUG9saWN5ID0gb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ1BvbGljeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbG9hZEJhbGFuY2luZ0NvbmZpZycgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ0NvbmZpZy5wdXNoKHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JldHJ5VGhyb3R0bGluZycgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdC5yZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmoucmV0cnlUaHJvdHRsaW5nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xuICAgIGNvbnN0IHNlZW5NZXRob2ROYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZW5OYW1lIG9mIHNlZW5NZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWc6IGR1cGxpY2F0ZSBuYW1lICR7bmFtZS5zZXJ2aWNlfS8ke25hbWUubWV0aG9kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5NZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhvYmopIHtcbiAgICBpZiAoISgnc2VydmljZUNvbmZpZycgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBtaXNzaW5nIHNlcnZpY2UgY29uZmlnJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VydmljZUNvbmZpZzogdmFsaWRhdGVTZXJ2aWNlQ29uZmlnKG9iai5zZXJ2aWNlQ29uZmlnKSxcbiAgICB9O1xuICAgIGlmICgnY2xpZW50TGFuZ3VhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50TGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50TGFuZ3VhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2NsaWVudEhvc3RuYW1lJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudEhvc3RuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNsaWVudEhvc3RuYW1lID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2Ygb2JqLmNsaWVudEhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdwZXJjZW50YWdlJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoucGVyY2VudGFnZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIDAgPD0gb2JqLnBlcmNlbnRhZ2UgJiZcbiAgICAgICAgICAgIG9iai5wZXJjZW50YWdlIDw9IDEwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnRhZ2UgPSBvYmoucGVyY2VudGFnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgcGVyY2VudGFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoYXQgbm8gdW5leHBlY3RlZCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICBjb25zdCBhbGxvd2VkRmllbGRzID0gW1xuICAgICAgICAnY2xpZW50TGFuZ3VhZ2UnLFxuICAgICAgICAncGVyY2VudGFnZScsXG4gICAgICAgICdjbGllbnRIb3N0bmFtZScsXG4gICAgICAgICdzZXJ2aWNlQ29uZmlnJyxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgZmllbGQgaW4gb2JqKSB7XG4gICAgICAgIGlmICghYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IHVuZXhwZWN0ZWQgZmllbGQgJHtmaWVsZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcob2JqLCBwZXJjZW50YWdlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGxpc3QnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZENvbmZpZyA9IHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIC8qIEZvciBlYWNoIGZpZWxkLCB3ZSBjaGVjayBpZiBpdCBpcyBwcmVzZW50LCB0aGVuIG9ubHkgZGlzY2FyZCB0aGVcbiAgICAgICAgICogY29uZmlnIGlmIHRoZSBmaWVsZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSkge1xuICAgICAgICAgICAgbGV0IGhvc3RuYW1lTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBob3N0bmFtZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdG5hbWUgPT09IG9zLmhvc3RuYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhvc3RuYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRlZENvbmZpZy5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZ3VhZ2Ugb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlID09PSBDTElFTlRfTEFOR1VBR0VfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQ29uZmlnLnNlcnZpY2VDb25maWc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWF0Y2hpbmcgc2VydmljZSBjb25maWcgZm91bmQnKTtcbn1cbi8qKlxuICogRmluZCB0aGUgXCJncnBjX2NvbmZpZ1wiIHJlY29yZCBhbW9uZyB0aGUgVFhUIHJlY29yZHMsIHBhcnNlIGl0cyB2YWx1ZSBhcyBKU09OLCB2YWxpZGF0ZSBpdHMgY29udGVudHMsXG4gKiBhbmQgc2VsZWN0IGEgc2VydmljZSBjb25maWcgd2l0aCBzZWxlY3Rpb24gZmllbGRzIHRoYXQgYWxsIG1hdGNoIHRoaXMgY2xpZW50LiBNb3N0IG9mIHRoZXNlIHN0ZXBzXG4gKiBjYW4gZmFpbCB3aXRoIGFuIGVycm9yOyB0aGUgY2FsbGVyIG11c3QgaGFuZGxlIGFueSBlcnJvcnMgdGhyb3duIHRoaXMgd2F5LlxuICogQHBhcmFtIHR4dFJlY29yZCBUaGUgVFhUIHJlY29yZCBhcnJheSB0aGF0IGlzIG91dHB1dCBmcm9tIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGRucy5yZXNvbHZlVHh0XG4gKiBAcGFyYW0gcGVyY2VudGFnZSBBIG51bWJlciBjaG9zZW4gZnJvbSB0aGUgcmFuZ2UgWzAsIDEwMCkgdGhhdCBpcyB1c2VkIHRvIHNlbGVjdCB3aGljaCBjb25maWcgdG8gdXNlXG4gKiBAcmV0dXJuIFRoZSBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gdXNlLCBnaXZlbiB0aGUgcGVyY2VudGFnZSB2YWx1ZSwgb3IgbnVsbCBpZiB0aGUgc2VydmljZSBjb25maWdcbiAqICAgICBkYXRhIGhhcyBhIHZhbGlkIGZvcm1hdCBidXQgbm9uZSBvZiB0aGUgb3B0aW9ucyBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKHR4dFJlY29yZCwgcGVyY2VudGFnZSkge1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHR4dFJlY29yZCkge1xuICAgICAgICBpZiAocmVjb3JkLmxlbmd0aCA+IDAgJiYgcmVjb3JkWzBdLnN0YXJ0c1dpdGgoJ2dycGNfY29uZmlnPScpKSB7XG4gICAgICAgICAgICAvKiBUcmVhdCB0aGUgbGlzdCBvZiBzdHJpbmdzIGluIHRoaXMgcmVjb3JkIGFzIGEgc2luZ2xlIHN0cmluZyBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAgKiBcImdycGNfY29uZmlnPVwiIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIHJlc3Qgc2hvdWxkIGJlIGEgSlNPTiBzdHJpbmcgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlY29yZFN0cmluZyA9IHJlY29yZC5qb2luKCcnKS5zdWJzdHJpbmcoJ2dycGNfY29uZmlnPScubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEpzb24gPSBKU09OLnBhcnNlKHJlY29yZFN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcocmVjb3JkSnNvbiwgcGVyY2VudGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/single-subchannel-channel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/single-subchannel-channel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2025 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SingleSubchannelChannel = void 0;\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nclass SubchannelCallWrapper {\n    constructor(subchannel, method, filterStackFactory, options, callNumber) {\n        var _a, _b;\n        this.subchannel = subchannel;\n        this.method = method;\n        this.options = options;\n        this.callNumber = callNumber;\n        this.childCall = null;\n        this.pendingMessage = null;\n        this.readPending = false;\n        this.halfClosePending = false;\n        this.pendingStatus = null;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        const splitPath = this.method.split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n          * by '/', the first item should be empty and the second should be the\n          * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.options.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n          * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n        const timeout = (0, deadline_1.getRelativeTimeout)(options.deadline);\n        if (timeout !== Infinity) {\n            if (timeout <= 0) {\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            }\n            else {\n                setTimeout(() => {\n                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n                }, timeout);\n            }\n        }\n        this.filterStack = filterStackFactory.createFilter();\n    }\n    cancelWithStatus(status, details) {\n        if (this.childCall) {\n            this.childCall.cancelWithStatus(status, details);\n        }\n        else {\n            this.pendingStatus = {\n                code: status,\n                details: details,\n                metadata: new metadata_1.Metadata()\n            };\n        }\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.childCall) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.subchannel.getAddress();\n    }\n    async start(metadata, listener) {\n        if (this.pendingStatus) {\n            listener.onReceiveStatus(this.pendingStatus);\n            return;\n        }\n        if (this.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            listener.onReceiveStatus({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Subchannel not ready',\n                metadata: new metadata_1.Metadata()\n            });\n            return;\n        }\n        const filteredMetadata = await this.filterStack.sendMetadata(Promise.resolve(metadata));\n        let credsMetadata;\n        try {\n            credsMetadata = await this.subchannel.getCallCredentials()\n                .generateMetadata({ method_name: this.method, service_url: this.serviceUrl });\n        }\n        catch (e) {\n            const error = e;\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n            listener.onReceiveStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata(),\n            });\n            return;\n        }\n        credsMetadata.merge(filteredMetadata);\n        const childListener = {\n            onReceiveMetadata: async (metadata) => {\n                listener.onReceiveMetadata(await this.filterStack.receiveMetadata(metadata));\n            },\n            onReceiveMessage: async (message) => {\n                this.readFilterPending = true;\n                const filteredMessage = await this.filterStack.receiveMessage(message);\n                this.readFilterPending = false;\n                listener.onReceiveMessage(filteredMessage);\n                if (this.pendingStatus) {\n                    listener.onReceiveStatus(this.pendingStatus);\n                }\n            },\n            onReceiveStatus: async (status) => {\n                const filteredStatus = await this.filterStack.receiveTrailers(status);\n                if (this.readFilterPending) {\n                    this.pendingStatus = filteredStatus;\n                }\n                else {\n                    listener.onReceiveStatus(filteredStatus);\n                }\n            }\n        };\n        this.childCall = this.subchannel.createCall(credsMetadata, this.options.host, this.method, childListener);\n        if (this.readPending) {\n            this.childCall.startRead();\n        }\n        if (this.pendingMessage) {\n            this.childCall.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n        }\n        if (this.halfClosePending && !this.writeFilterPending) {\n            this.childCall.halfClose();\n        }\n    }\n    async sendMessageWithContext(context, message) {\n        this.writeFilterPending = true;\n        const filteredMessage = await this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags }));\n        this.writeFilterPending = false;\n        if (this.childCall) {\n            this.childCall.sendMessageWithContext(context, filteredMessage.message);\n            if (this.halfClosePending) {\n                this.childCall.halfClose();\n            }\n        }\n        else {\n            this.pendingMessage = { context, message: filteredMessage.message };\n        }\n    }\n    startRead() {\n        if (this.childCall) {\n            this.childCall.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        if (this.childCall && !this.writeFilterPending) {\n            this.childCall.halfClose();\n        }\n        else {\n            this.halfClosePending = true;\n        }\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    setCredentials(credentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getAuthContext() {\n        if (this.childCall) {\n            return this.childCall.getAuthContext();\n        }\n        else {\n            return null;\n        }\n    }\n}\nclass SingleSubchannelChannel {\n    constructor(subchannel, target, options) {\n        this.subchannel = subchannel;\n        this.target = target;\n        this.channelzEnabled = false;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.channelzEnabled = options['grpc.enable_channelz'] !== 0;\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)((0, uri_parser_1.uriToString)(target), () => ({\n            target: `${(0, uri_parser_1.uriToString)(target)} (${subchannel.getAddress()})`,\n            state: this.subchannel.getConnectivityState(),\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        }), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.childrenTracker.refChild(subchannel.getChannelzRef());\n        }\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([new compression_filter_1.CompressionFilterFactory(this, options)]);\n    }\n    close() {\n        if (this.channelzEnabled) {\n            this.childrenTracker.unrefChild(this.subchannel.getChannelzRef());\n        }\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        throw new Error(\"Method not implemented.\");\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline) {\n        const callOptions = {\n            deadline: deadline,\n            host: (0, resolver_1.getDefaultAuthority)(this.target),\n            flags: constants_1.Propagate.DEFAULTS,\n            parentCall: null\n        };\n        return new SubchannelCallWrapper(this.subchannel, method, this.filterStackFactory, callOptions, (0, call_number_1.getNextCallNumber)());\n    }\n}\nexports.SingleSubchannelChannel = SingleSubchannelChannel;\n//# sourceMappingURL=single-subchannel-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zaW5nbGUtc3ViY2hhbm5lbC1jaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9ELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZLEVBQUUsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsR0FBRyxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3REFBd0Q7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQiwwTEFBMEwsY0FBYztBQUM1TztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHdDQUF3QztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QyxHQUFHLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2luZ2xlLXN1YmNoYW5uZWwtY2hhbm5lbC5qcz81MjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI1IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbmdsZVN1YmNoYW5uZWxDaGFubmVsID0gdm9pZCAwO1xuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgY29tcHJlc3Npb25fZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1maWx0ZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY29udHJvbF9wbGFuZV9zdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2wtcGxhbmUtc3RhdHVzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY2xhc3MgU3ViY2hhbm5lbENhbGxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsLCBtZXRob2QsIGZpbHRlclN0YWNrRmFjdG9yeSwgb3B0aW9ucywgY2FsbE51bWJlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5jaGlsZENhbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZVBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSB0aGlzLm1ldGhvZC5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgc2VydmljZU5hbWUgPSAnJztcbiAgICAgICAgLyogVGhlIHN0YW5kYXJkIHBhdGggZm9ybWF0IGlzIFwiL3tzZXJ2aWNlTmFtZX0ve21ldGhvZE5hbWV9XCIsIHNvIGlmIHdlIHNwbGl0XG4gICAgICAgICAgKiBieSAnLycsIHRoZSBmaXJzdCBpdGVtIHNob3VsZCBiZSBlbXB0eSBhbmQgdGhlIHNlY29uZCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAgKiBzZXJ2aWNlIG5hbWUgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgc2VydmljZU5hbWUgPSBzcGxpdFBhdGhbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSAoX2IgPSAoX2EgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRoaXMub3B0aW9ucy5ob3N0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAvKiBDdXJyZW50bHksIGNhbGwgY3JlZGVudGlhbHMgYXJlIG9ubHkgYWxsb3dlZCBvbiBIVFRQUyBjb25uZWN0aW9ucywgc28gd2VcbiAgICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VVcmwgPSBgaHR0cHM6Ly8ke2hvc3RuYW1lfS8ke3NlcnZpY2VOYW1lfWA7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKG9wdGlvbnMuZGVhZGxpbmUpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVELCAnRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVELCAnRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRDYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZENhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnU3ViY2hhbm5lbCBub3QgcmVhZHknLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1ldGFkYXRhID0gYXdhaXQgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKG1ldGFkYXRhKSk7XG4gICAgICAgIGxldCBjcmVkc01ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3JlZHNNZXRhZGF0YSA9IGF3YWl0IHRoaXMuc3ViY2hhbm5lbC5nZXRDYWxsQ3JlZGVudGlhbHMoKVxuICAgICAgICAgICAgICAgIC5nZW5lcmF0ZU1ldGFkYXRhKHsgbWV0aG9kX25hbWU6IHRoaXMubWV0aG9kLCBzZXJ2aWNlX3VybDogdGhpcy5zZXJ2aWNlVXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjcmVkc01ldGFkYXRhLm1lcmdlKGZpbHRlcmVkTWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBjaGlsZExpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IGFzeW5jIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKGF3YWl0IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKGZpbHRlcmVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1N0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBhc3luYyAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRTdGF0dXMgPSBhd2FpdCB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVUcmFpbGVycyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IGZpbHRlcmVkU3RhdHVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hpbGRDYWxsID0gdGhpcy5zdWJjaGFubmVsLmNyZWF0ZUNhbGwoY3JlZHNNZXRhZGF0YSwgdGhpcy5vcHRpb25zLmhvc3QsIHRoaXMubWV0aG9kLCBjaGlsZExpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRDYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkQ2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYWxmQ2xvc2VQZW5kaW5nICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWVzc2FnZShQcm9taXNlLnJlc29sdmUoeyBtZXNzYWdlOiBtZXNzYWdlLCBmbGFnczogY29udGV4dC5mbGFncyB9KSk7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYWxmQ2xvc2VQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlOiBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkQ2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRDYWxsICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZENhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbGZDbG9zZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRDYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENhbGwuZ2V0QXV0aENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlU3ViY2hhbm5lbENoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWwsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gb3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSAhPT0gMDtcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKSgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpLCAoKSA9PiAoe1xuICAgICAgICAgICAgdGFyZ2V0OiBgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpfSAoJHtzdWJjaGFubmVsLmdldEFkZHJlc3MoKX0pYCxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKClcbiAgICAgICAgfSksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbbmV3IGNvbXByZXNzaW9uX2ZpbHRlcl8xLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSh0aGlzLCBvcHRpb25zKV0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHRoaXMuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgIH1cbiAgICBnZXRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZWFkbGluZTogZGVhZGxpbmUsXG4gICAgICAgICAgICBob3N0OiAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KSh0aGlzLnRhcmdldCksXG4gICAgICAgICAgICBmbGFnczogY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFRkFVTFRTLFxuICAgICAgICAgICAgcGFyZW50Q2FsbDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN1YmNoYW5uZWxDYWxsV3JhcHBlcih0aGlzLnN1YmNoYW5uZWwsIG1ldGhvZCwgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnksIGNhbGxPcHRpb25zLCAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW5nbGVTdWJjaGFubmVsQ2hhbm5lbCA9IFNpbmdsZVN1YmNoYW5uZWxDaGFubmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2luZ2xlLXN1YmNoYW5uZWwtY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/single-subchannel-channel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */\nclass StatusBuilder {\n    constructor() {\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */\n    withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */\n    withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */\n    withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */\n    build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder;\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0YXR1cy1idWlsZGVyLmpzP2JmMjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IHZvaWQgMDtcbi8qKlxuICogQSBidWlsZGVyIGZvciBnUlBDIHN0YXR1cyBvYmplY3RzLlxuICovXG5jbGFzcyBTdGF0dXNCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0dXMgY29kZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoQ29kZShjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGRldGFpbHMgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aERldGFpbHMoZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtZXRhZGF0YSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBzdGF0dXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSB0aGlzLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBTdGF0dXNCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(maxReadMessageLength) {\n        this.maxReadMessageLength = maxReadMessageLength;\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n                        }\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHNCQUFzQixLQUFLLDBCQUEwQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanM/OWVlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJlYW1EZWNvZGVyID0gdm9pZCAwO1xudmFyIFJlYWRTdGF0ZTtcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIk5PX0RBVEFcIl0gPSAwXSA9IFwiTk9fREFUQVwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX1NJWkVcIl0gPSAxXSA9IFwiUkVBRElOR19TSVpFXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfTUVTU0FHRVwiXSA9IDJdID0gXCJSRUFESU5HX01FU1NBR0VcIjtcbn0pKFJlYWRTdGF0ZSB8fCAoUmVhZFN0YXRlID0ge30pKTtcbmNsYXNzIFN0cmVhbURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGggPSBtYXhSZWFkTWVzc2FnZUxlbmd0aDtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcbiAgICAgICAgbGV0IHRvUmVhZDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuTk9fREFUQTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19TSVpFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMucmVhZFBhcnRpYWxTaXplLCA0IC0gdGhpcy5yZWFkU2l6ZVJlbWFpbmluZywgcmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZFNpemVSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRoaXMucmVhZE1lc3NhZ2VTaXplID4gdGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7dGhpcy5yZWFkTWVzc2FnZVNpemV9IHZzICR7dGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gdGhpcy5yZWFkTWVzc2FnZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZWFkQ29tcHJlc3NGbGFnLCB0aGlzLnJlYWRQYXJ0aWFsU2l6ZV0sIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UucHVzaChkYXRhLnNsaWNlKHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkTWVzc2FnZVJlbWFpbmluZyA+PTAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSByZWFkIGEgZnVsbCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlQnVmZmVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlID0gQnVmZmVyLmNvbmNhdChmcmFtZWRNZXNzYWdlQnVmZmVycywgdGhpcy5yZWFkTWVzc2FnZVNpemUgKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVhZCBzdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW1EZWNvZGVyID0gU3RyZWFtRGVjb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndpointMap = void 0;\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nexports.subchannelAddressEqual = subchannelAddressEqual;\nexports.subchannelAddressToString = subchannelAddressToString;\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\nexports.endpointEqual = endpointEqual;\nexports.endpointToString = endpointToString;\nexports.endpointHasAddress = endpointHasAddress;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return 'port' in address;\n}\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return (isTcpSubchannelAddress(address2) &&\n            address1.host === address2.host &&\n            address1.port === address2.port);\n    }\n    else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        if ((0, net_1.isIPv6)(address.host)) {\n            return '[' + address.host + ']:' + address.port;\n        }\n        else {\n            return address.host + ':' + address.port;\n        }\n    }\n    else {\n        return address.path;\n    }\n}\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,\n        };\n    }\n    else {\n        return {\n            path: addressString,\n        };\n    }\n}\nfunction endpointEqual(endpoint1, endpoint2) {\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n        return false;\n    }\n    for (let i = 0; i < endpoint1.addresses.length; i++) {\n        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction endpointToString(endpoint) {\n    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');\n}\nfunction endpointHasAddress(endpoint, expectedAddress) {\n    for (const address of endpoint.addresses) {\n        if (subchannelAddressEqual(address, expectedAddress)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction endpointEqualUnordered(endpoint1, endpoint2) {\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n        return false;\n    }\n    for (const address1 of endpoint1.addresses) {\n        let matchFound = false;\n        for (const address2 of endpoint2.addresses) {\n            if (subchannelAddressEqual(address1, address2)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nclass EndpointMap {\n    constructor() {\n        this.map = new Set();\n    }\n    get size() {\n        return this.map.size;\n    }\n    getForSubchannelAddress(address) {\n        for (const entry of this.map) {\n            if (endpointHasAddress(entry.key, address)) {\n                return entry.value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Delete any entries in this map with keys that are not in endpoints\n     * @param endpoints\n     */\n    deleteMissing(endpoints) {\n        const removedValues = [];\n        for (const entry of this.map) {\n            let foundEntry = false;\n            for (const endpoint of endpoints) {\n                if (endpointEqualUnordered(endpoint, entry.key)) {\n                    foundEntry = true;\n                }\n            }\n            if (!foundEntry) {\n                removedValues.push(entry.value);\n                this.map.delete(entry);\n            }\n        }\n        return removedValues;\n    }\n    get(endpoint) {\n        for (const entry of this.map) {\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                return entry.value;\n            }\n        }\n        return undefined;\n    }\n    set(endpoint, mapEntry) {\n        for (const entry of this.map) {\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                entry.value = mapEntry;\n                return;\n            }\n        }\n        this.map.add({ key: endpoint, value: mapEntry });\n    }\n    delete(endpoint) {\n        for (const entry of this.map) {\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                this.map.delete(entry);\n                return;\n            }\n        }\n    }\n    has(endpoint) {\n        for (const entry of this.map) {\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    clear() {\n        this.map.clear();\n    }\n    *keys() {\n        for (const entry of this.map) {\n            yield entry.key;\n        }\n    }\n    *values() {\n        for (const entry of this.map) {\n            yield entry.value;\n        }\n    }\n    *entries() {\n        for (const entry of this.map) {\n            yield [entry.key, entry.value];\n        }\n    }\n}\nexports.EndpointMap = EndpointMap;\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtYWRkcmVzcy5qcz9iZmI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVuZHBvaW50TWFwID0gdm9pZCAwO1xuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IHN1YmNoYW5uZWxBZGRyZXNzRXF1YWw7XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcztcbmV4cG9ydHMuZW5kcG9pbnRFcXVhbCA9IGVuZHBvaW50RXF1YWw7XG5leHBvcnRzLmVuZHBvaW50VG9TdHJpbmcgPSBlbmRwb2ludFRvU3RyaW5nO1xuZXhwb3J0cy5lbmRwb2ludEhhc0FkZHJlc3MgPSBlbmRwb2ludEhhc0FkZHJlc3M7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5mdW5jdGlvbiBpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gJ3BvcnQnIGluIGFkZHJlc3M7XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGFkZHJlc3MxLCBhZGRyZXNzMikge1xuICAgIGlmICghYWRkcmVzczEgJiYgIWFkZHJlc3MyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFkZHJlc3MxIHx8ICFhZGRyZXNzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MxKSkge1xuICAgICAgICByZXR1cm4gKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5ob3N0ID09PSBhZGRyZXNzMi5ob3N0ICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5wb3J0ID09PSBhZGRyZXNzMi5wb3J0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiYgYWRkcmVzczEucGF0aCA9PT0gYWRkcmVzczIucGF0aDtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NikoYWRkcmVzcy5ob3N0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGFkZHJlc3MuaG9zdCArICddOicgKyBhZGRyZXNzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5wYXRoO1xuICAgIH1cbn1cbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmZ1bmN0aW9uIHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzc1N0cmluZywgcG9ydCkge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUCkoYWRkcmVzc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IGFkZHJlc3NTdHJpbmcsXG4gICAgICAgICAgICBwb3J0OiBwb3J0ICE9PSBudWxsICYmIHBvcnQgIT09IHZvaWQgMCA/IHBvcnQgOiBERUZBVUxUX1BPUlQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmRwb2ludEVxdWFsKGVuZHBvaW50MSwgZW5kcG9pbnQyKSB7XG4gICAgaWYgKGVuZHBvaW50MS5hZGRyZXNzZXMubGVuZ3RoICE9PSBlbmRwb2ludDIuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kcG9pbnQxLmFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoZW5kcG9pbnQxLmFkZHJlc3Nlc1tpXSwgZW5kcG9pbnQyLmFkZHJlc3Nlc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50VG9TdHJpbmcoZW5kcG9pbnQpIHtcbiAgICByZXR1cm4gKCdbJyArIGVuZHBvaW50LmFkZHJlc3Nlcy5tYXAoc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykuam9pbignLCAnKSArICddJyk7XG59XG5mdW5jdGlvbiBlbmRwb2ludEhhc0FkZHJlc3MoZW5kcG9pbnQsIGV4cGVjdGVkQWRkcmVzcykge1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBlbmRwb2ludC5hZGRyZXNzZXMpIHtcbiAgICAgICAgaWYgKHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzcywgZXhwZWN0ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludDEsIGVuZHBvaW50Mikge1xuICAgIGlmIChlbmRwb2ludDEuYWRkcmVzc2VzLmxlbmd0aCAhPT0gZW5kcG9pbnQyLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFkZHJlc3MxIG9mIGVuZHBvaW50MS5hZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzMiBvZiBlbmRwb2ludDIuYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChhZGRyZXNzMSwgYWRkcmVzczIpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaEZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBFbmRwb2ludE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gICAgfVxuICAgIGdldEZvclN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50SGFzQWRkcmVzcyhlbnRyeS5rZXksIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbnkgZW50cmllcyBpbiB0aGlzIG1hcCB3aXRoIGtleXMgdGhhdCBhcmUgbm90IGluIGVuZHBvaW50c1xuICAgICAqIEBwYXJhbSBlbmRwb2ludHNcbiAgICAgKi9cbiAgICBkZWxldGVNaXNzaW5nKGVuZHBvaW50cykge1xuICAgICAgICBjb25zdCByZW1vdmVkVmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEVudHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludEVxdWFsVW5vcmRlcmVkKGVuZHBvaW50LCBlbnRyeS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmRFbnRyeSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRWYWx1ZXMucHVzaChlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZFZhbHVlcztcbiAgICB9XG4gICAgZ2V0KGVuZHBvaW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludEVxdWFsVW5vcmRlcmVkKGVuZHBvaW50LCBlbnRyeS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldChlbmRwb2ludCwgbWFwRW50cnkpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50RXF1YWxVbm9yZGVyZWQoZW5kcG9pbnQsIGVudHJ5LmtleSkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS52YWx1ZSA9IG1hcEVudHJ5O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcC5hZGQoeyBrZXk6IGVuZHBvaW50LCB2YWx1ZTogbWFwRW50cnkgfSk7XG4gICAgfVxuICAgIGRlbGV0ZShlbmRwb2ludCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhcyhlbmRwb2ludCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgfVxuICAgICprZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICB5aWVsZCBlbnRyeS5rZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgeWllbGQgZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHlpZWxkIFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW5kcG9pbnRNYXAgPSBFbmRwb2ludE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'subchannel_call';\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nfunction mapHttpStatusCode(code) {\n    const details = `Received HTTP status code ${code}`;\n    let mappedStatusCode;\n    switch (code) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n            mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n        case 401:\n            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n        case 403:\n            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n        case 404:\n            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n            mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n        default:\n            mappedStatusCode = constants_1.Status.UNKNOWN;\n    }\n    return {\n        code: mappedStatusCode,\n        details: details,\n        metadata: new metadata_1.Metadata()\n    };\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId) {\n        var _a;\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        this.serverEndedCall = false;\n        this.connectionDropped = false;\n        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n        http2Stream.on('response', (headers, flags) => {\n            let headersString = '';\n            for (const header of Object.keys(headers)) {\n                headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n            }\n            this.trace('Received server headers:\\n' + headersString);\n            this.httpStatusCode = headers[':status'];\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            }\n            else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on('trailers', (headers) => {\n            this.handleTrailers(headers);\n        });\n        http2Stream.on('data', (data) => {\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */\n            if (this.statusOutput) {\n                return;\n            }\n            this.trace('receive HTTP/2 data frame of length ' + data.length);\n            let messages;\n            try {\n                messages = this.decoder.write(data);\n            }\n            catch (e) {\n                /* Some servers send HTML error pages along with HTTP status codes.\n                 * When the client attempts to parse this as a length-delimited\n                 * message, the parsed message size is greater than the default limit,\n                 * resulting in a message decoding error. In that situation, the HTTP\n                 * error code information is more useful to the user than the\n                 * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,\n                 * we delay processing the HTTP status until after the stream ends, to\n                 * prioritize reporting the gRPC status from trailers if it is present,\n                 * but when there is a message parsing error we end the stream early\n                 * before processing trailers. */\n                if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {\n                    const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n                    this.cancelWithStatus(mappedStatus.code, mappedStatus.details);\n                }\n                else {\n                    this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n                }\n                return;\n            }\n            for (const message of messages) {\n                this.trace('parsed message of length ' + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on('end', () => {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on('close', () => {\n            this.serverEndedCall = true;\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */\n            process.nextTick(() => {\n                var _a;\n                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */\n                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = '';\n                switch (http2Stream.rstCode) {\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */\n                        if (this.finalStatus !== null) {\n                            return;\n                        }\n                        if (this.httpStatusCode && this.httpStatusCode !== 200) {\n                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n                            code = mappedStatus.code;\n                            details = mappedStatus.details;\n                        }\n                        else {\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\n                        }\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = 'Stream refused by server';\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL\n                         * code from connection drops. We want to prioritize reporting\n                         * an unavailable status when that happens. */\n                        if (this.connectionDropped) {\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = 'Connection dropped';\n                        }\n                        else {\n                            code = constants_1.Status.CANCELLED;\n                            details = 'Call cancelled';\n                        }\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = 'Bandwidth exhausted or memory limit exceeded';\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = 'Protocol not secure enough';\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        }\n                        else {\n                            if (this.internalError.code === 'ECONNRESET' ||\n                                this.internalError.code === 'ETIMEDOUT') {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            }\n                            else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */\n                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode,\n                });\n            });\n        });\n        http2Stream.on('error', (err) => {\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */\n            /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */\n            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                this.trace('Node error event: message=' +\n                    err.message +\n                    ' code=' +\n                    err.code +\n                    ' errno=' +\n                    getSystemErrorName(err.errno) +\n                    ' syscall=' +\n                    err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    getDeadlineInfo() {\n        return [`remote_addr=${this.getPeer()}`];\n    }\n    onDisconnect() {\n        this.connectionDropped = true;\n        /* Give the call an event loop cycle to finish naturally before reporting\n         * the disconnection as an error. */\n        setImmediate(() => {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Connection dropped',\n                metadata: new metadata_1.Metadata(),\n            });\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */\n        if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace('ended with status: code=' +\n                this.finalStatus.code +\n                ' details=\"' +\n                this.finalStatus.details +\n                '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */\n            this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    !this.isReadFilterPending &&\n                    !this.isPushPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(() => {\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.serverEndedCall = true;\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let status;\n        if (typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            this.trace('received status code ' + receivedStatus + ' from server');\n            metadata.remove('grpc-status');\n            let details = '';\n            if (typeof metadataMap['grpc-message'] === 'string') {\n                try {\n                    details = decodeURI(metadataMap['grpc-message']);\n                }\n                catch (e) {\n                    details = metadataMap['grpc-message'];\n                }\n                metadata.remove('grpc-message');\n                this.trace('received status details string \"' + details + '\" from server');\n            }\n            status = {\n                code: receivedStatus,\n                details: details,\n                metadata: metadata\n            };\n        }\n        else if (this.httpStatusCode) {\n            status = mapHttpStatusCode(this.httpStatusCode);\n            status.metadata = metadata;\n        }\n        else {\n            status = {\n                code: constants_1.Status.UNKNOWN,\n                details: 'No status information received',\n                metadata: metadata\n            };\n        }\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream.destroyed) {\n            return;\n        }\n        /* If the server ended the call, sending an RST_STREAM is redundant, so we\n         * just half close on the client side instead to finish closing the stream.\n         */\n        if (this.serverEndedCall) {\n            this.http2Stream.end();\n        }\n        else {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    getAuthContext() {\n        return this.transport.getAuthContext();\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */\n        this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        const cb = (error) => {\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */\n            process.nextTick(() => {\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) ===\n                    'ERR_STREAM_WRITE_AFTER_END') {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace('sending data chunk of length ' + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        }\n        catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata(),\n            });\n        }\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.trace('calling end() on HTTP/2 stream');\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;\n//# sourceMappingURL=subchannel-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQixzQ0FBc0MsMkJBQTJCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQTREO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanM/YjJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWxfY2FsbCc7XG4vKipcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwZXMgZG9uJ3QgaGF2ZSB0aGF0IGZ1bmN0aW9uIGZvciBzb21lIHJlYXNvbiBzbyBJIGp1c3QgbWFkZSBteVxuICogb3duLlxuICogQHBhcmFtIGVycm5vXG4gKi9cbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xuICAgICAgICBpZiAobnVtID09PSBlcnJubykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XG59XG5mdW5jdGlvbiBtYXBIdHRwU3RhdHVzQ29kZShjb2RlKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGBSZWNlaXZlZCBIVFRQIHN0YXR1cyBjb2RlICR7Y29kZX1gO1xuICAgIGxldCBtYXBwZWRTdGF0dXNDb2RlO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IGhhbmRsZSAxMDAgYW5kIDEwMVxuICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICBtYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgICBtYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgIGNhc2UgNTAyOlxuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICBtYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV047XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG1hcHBlZFN0YXR1c0NvZGUsXG4gICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXG4gICAgfTtcbn1cbmNsYXNzIEh0dHAyU3ViY2hhbm5lbENhbGwge1xuICAgIGNvbnN0cnVjdG9yKGh0dHAyU3RyZWFtLCBjYWxsRXZlbnRUcmFja2VyLCBsaXN0ZW5lciwgdHJhbnNwb3J0LCBjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtID0gaHR0cDJTdHJlYW07XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlciA9IGNhbGxFdmVudFRyYWNrZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuY2FsbElkID0gY2FsbElkO1xuICAgICAgICB0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYW4gJ2VuZCcgZXZlbnQgaGFzIGNvbWUgZnJvbSB0aGUgaHR0cDIgc3RyZWFtLCBzbyB0aGVyZVxuICAgICAgICAgKiB3aWxsIGJlIG5vIG1vcmUgZGF0YSBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdHVzT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgLy8gVGhpcyBpcyBwb3B1bGF0ZWQgKG5vbi1udWxsKSBpZiBhbmQgb25seSBpZiB0aGUgY2FsbCBoYXMgZW5kZWRcbiAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyRW5kZWRDYWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRyb3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGggPSAoX2EgPSB0cmFuc3BvcnQuZ2V0T3B0aW9ucygpWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIobWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigncmVzcG9uc2UnLCAoaGVhZGVycywgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgaGVhZGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XG4gICAgICAgICAgICB0aGlzLmh0dHBTdGF0dXNDb2RlID0gaGVhZGVyc1snOnN0YXR1cyddO1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXQsIGFsbG93IHRoZSBodHRwMiBzdHJlYW0gdG9cbiAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBTb21lIHNlcnZlcnMgc2VuZCBIVE1MIGVycm9yIHBhZ2VzIGFsb25nIHdpdGggSFRUUCBzdGF0dXMgY29kZXMuXG4gICAgICAgICAgICAgICAgICogV2hlbiB0aGUgY2xpZW50IGF0dGVtcHRzIHRvIHBhcnNlIHRoaXMgYXMgYSBsZW5ndGgtZGVsaW1pdGVkXG4gICAgICAgICAgICAgICAgICogbWVzc2FnZSwgdGhlIHBhcnNlZCBtZXNzYWdlIHNpemUgaXMgZ3JlYXRlciB0aGFuIHRoZSBkZWZhdWx0IGxpbWl0LFxuICAgICAgICAgICAgICAgICAqIHJlc3VsdGluZyBpbiBhIG1lc3NhZ2UgZGVjb2RpbmcgZXJyb3IuIEluIHRoYXQgc2l0dWF0aW9uLCB0aGUgSFRUUFxuICAgICAgICAgICAgICAgICAqIGVycm9yIGNvZGUgaW5mb3JtYXRpb24gaXMgbW9yZSB1c2VmdWwgdG8gdGhlIHVzZXIgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAgKiBSRVNPVVJDRV9FWEhBVVNURUQgZXJyb3IgaXMsIHNvIHdlIHJlcG9ydCB0aGF0IGluc3RlYWQuIE5vcm1hbGx5LFxuICAgICAgICAgICAgICAgICAqIHdlIGRlbGF5IHByb2Nlc3NpbmcgdGhlIEhUVFAgc3RhdHVzIHVudGlsIGFmdGVyIHRoZSBzdHJlYW0gZW5kcywgdG9cbiAgICAgICAgICAgICAgICAgKiBwcmlvcml0aXplIHJlcG9ydGluZyB0aGUgZ1JQQyBzdGF0dXMgZnJvbSB0cmFpbGVycyBpZiBpdCBpcyBwcmVzZW50LFxuICAgICAgICAgICAgICAgICAqIGJ1dCB3aGVuIHRoZXJlIGlzIGEgbWVzc2FnZSBwYXJzaW5nIGVycm9yIHdlIGVuZCB0aGUgc3RyZWFtIGVhcmx5XG4gICAgICAgICAgICAgICAgICogYmVmb3JlIHByb2Nlc3NpbmcgdHJhaWxlcnMuICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaHR0cFN0YXR1c0NvZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmh0dHBTdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkU3RhdHVzID0gbWFwSHR0cFN0YXR1c0NvZGUodGhpcy5odHRwU3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhtYXBwZWRTdGF0dXMuY29kZSwgbWFwcGVkU3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3BhcnNlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckVuZGVkQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICAvKiBVc2UgcHJvY2Vzcy5uZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgdGhpcyBjb2RlIGhhcHBlbnMgYWZ0ZXIgYW55XG4gICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XG4gICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIGh0dHAyU3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYSBmaW5hbCBzdGF0dXMgd2l0aCBhbiBPSyBzdGF0dXMgY29kZSwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoYXQgKi9cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGh0dHAyU3RyZWFtLnJzdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzdHJlYW0gY29tcGxldGVkIHByb3Blcmx5IGFuZCB3ZSBqdXN0IGhhdmVuJ3QgZnVsbHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHR0cFN0YXR1c0NvZGUgJiYgdGhpcy5odHRwU3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkU3RhdHVzID0gbWFwSHR0cFN0YXR1c0NvZGUodGhpcy5odHRwU3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IG1hcHBlZFN0YXR1cy5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtYXBwZWRTdGF0dXMuZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IChDYWxsIGVuZGVkIHdpdGhvdXQgZ1JQQyBzdGF0dXMpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX1JFRlVTRURfU1RSRUFNOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnU3RyZWFtIHJlZnVzZWQgYnkgc2VydmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJ1ZyByZXBvcnRzIGluZGljYXRlIHRoYXQgTm9kZSBzeW50aGVzaXplcyBhIE5HSFRUUDJfQ0FOQ0VMXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjb2RlIGZyb20gY29ubmVjdGlvbiBkcm9wcy4gV2Ugd2FudCB0byBwcmlvcml0aXplIHJlcG9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogYW4gdW5hdmFpbGFibGUgc3RhdHVzIHdoZW4gdGhhdCBoYXBwZW5zLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkRyb3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ29ubmVjdGlvbiBkcm9wcGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQmFuZHdpZHRoIGV4aGF1c3RlZCBvciBtZW1vcnkgbGltaXQgZXhjZWVkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIGNvZGUgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIHNvIHRoYXQgcGVvcGxlIGZpbmQgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiBzZWFyY2hlcywgYnV0IGFsc28gaW5jbHVkZSB0aGUgbW9yZSByZWNvZ25pemFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IChJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgXCJSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAuLi5cIiBlcnJvciBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaGVyZSBmb3IgY29udGludWl0eSB3aXRoIGVycm9ycyByZXBvcnRlZCBvbmxpbmUsIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtb3N0IGNhc2VzLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gdHJpZ2dlcmVkIGJ5IGludGVybmFsIGNsaWVudCBlcnJvcjogJHt0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0cmFpbGVycyB3ZXJlIHJlY2VpdmVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLCBiZWNhdXNlIHN0YXR1cyBjb2RlcyBlbWl0dGVkIGhlcmUgY29ycmVzcG9uZCB0byBtb3JlXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgcGxhY2UuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciBoZXJlIHRvIHN0b3AgXCJVbmNhdWdodCBFcnJvclwiIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgICogXCJjbG9zZVwiIGV2ZW50cywgd2hlcmUgd2Ugd2lsbCBoYW5kbGUgdGhlIGVycm9yIG1vcmUgZ3JhbnVsYXJseSAqL1xuICAgICAgICAgICAgLyogU3BlY2lmaWNhbGx5IGxvb2tpbmcgZm9yIHN0cmVhbSBlcnJvcnMgdGhhdCB3ZXJlICpub3QqIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvOGI4NjIwZDU4MDMxNDA1MDE3NTk4MzQwMmRmZGRmMjY3NGU4ZTIyYS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMjI2N1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vZGUgZXJyb3IgZXZlbnQ6IG1lc3NhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgZXJybm89JyArXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcbiAgICAgICAgICAgICAgICAgICAgJyBzeXNjYWxsPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIFtgcmVtb3RlX2FkZHI9JHt0aGlzLmdldFBlZXIoKX1gXTtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Ecm9wcGVkID0gdHJ1ZTtcbiAgICAgICAgLyogR2l2ZSB0aGUgY2FsbCBhbiBldmVudCBsb29wIGN5Y2xlIHRvIGZpbmlzaCBuYXR1cmFsbHkgYmVmb3JlIHJlcG9ydGluZ1xuICAgICAgICAgKiB0aGUgZGlzY29ubmVjdGlvbiBhcyBhbiBlcnJvci4gKi9cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAqIGNsZWFudXAgY29kZSBpbiB0aGlzIGNsYXNzIGZyb20gYW55IGVycm9ycyB0aGF0IG1heSBiZSB0aHJvd24gaW4gdGhlXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5IGF0IHRoZSB0b3AgbGV2ZWwsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgdGhyb3duIGVycm9yIGlmXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXG4gICAgICAgICAgICAgKiBlbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNsb3N1cmUgY29tcGxldGVzLiBUaGUgY2FsbCBzdHJlYW0gYWxyZWFkeSBkb2VzXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbElkICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBjYWxsLlxuICAgICAqL1xuICAgIGVuZENhbGwoc3RhdHVzKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaXMgT0sgYW5kIGEgbmV3IHN0YXR1cyBjb21lcyBpbiAoZS5nLiBmcm9tIGFcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SHR0cDJTdHJlYW0oKTtcbiAgICB9XG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxuICAgICAgICAgICAgICogcHJvY2Vzc2VkICovXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVzaFBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UubGVuZ3RoIDogbnVsbCkpO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXG4gICAgICAgICAgICAgKiBpZ25vcmVkLCBhbmQgY2FuIGNhdXNlIG91dC1vZi1vcmRlciBvcGVyYXRpb24gZXJyb3JzIGhpZ2hlciB1cCBpbiB0aGVcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJFbmRlZENhbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25TdHJlYW1FbmQodHJ1ZSk7XG4gICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHNlcnZlciB0cmFpbGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5nZXRNYXAoKTtcbiAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBjb2RlICcgKyByZWNlaXZlZFN0YXR1cyArICcgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1zdGF0dXMnKTtcbiAgICAgICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1tZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZWNlaXZlZFN0YXR1cyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmh0dHBTdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBtYXBIdHRwU3RhdHVzQ29kZSh0aGlzLmh0dHBTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBzdGF0dXMgaW5mb3JtYXRpb24gcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgZW5kZWQgd2hlbiBoYW5kbGluZyBoZWFkZXJzLlxuICAgICAgICB0aGlzLmVuZENhbGwoc3RhdHVzKTtcbiAgICB9XG4gICAgZGVzdHJveUh0dHAyU3RyZWFtKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRoZSBodHRwMiBzdHJlYW0gY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gZGVzdHJveWVkIGlmIGNhbmNlbFdpdGhTdGF0dXNcbiAgICAgICAgLy8gaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVybmFsIGh0dHAyIGVycm9yLlxuICAgICAgICBpZiAodGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiB0aGUgc2VydmVyIGVuZGVkIHRoZSBjYWxsLCBzZW5kaW5nIGFuIFJTVF9TVFJFQU0gaXMgcmVkdW5kYW50LCBzbyB3ZVxuICAgICAgICAgKiBqdXN0IGhhbGYgY2xvc2Ugb24gdGhlIGNsaWVudCBzaWRlIGluc3RlYWQgdG8gZmluaXNoIGNsb3NpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnNlcnZlckVuZGVkQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdHJlYW0sIHBhcnRseSB0byBhdm9pZCBhIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBkZXRlY3QgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXG4gICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2xvc2UgaHR0cDIgc3RyZWFtIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsU3RhdHVzO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0UGVlck5hbWUoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmdldEF1dGhDb250ZXh0KCk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2Ugc2hvdWxkIG5vdCBlbWl0IGFueSBtb3JlXG4gICAgICAgICAqIG1lc3NhZ2VzIGFuZCB3ZSBzaG91bGQgY29tbXVuaWNhdGUgdGhhdCB0aGUgc3RyZWFtIGhhcyBlbmRlZCAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5QdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobmV4dE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIE9ubHkgcmVzdW1lIHJlYWRpbmcgZnJvbSB0aGUgaHR0cDJTdHJlYW0gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGVuZGluZ1xuICAgICAgICAgKiBtZXNzYWdlcyB0byBlbWl0ICovXG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNiID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvKiBuZXh0VGljayBoZXJlIGVuc3VyZXMgdGhhdCBubyBzdHJlYW0gYWN0aW9uIGNhbiBiZSB0YWtlbiBpbiB0aGUgY2FsbFxuICAgICAgICAgICAgICogc3RhY2sgb2YgdGhlIHdyaXRlIGNhbGxiYWNrLCBpbiBvcmRlciB0byBob3BlZnVsbHkgd29yayBhcm91bmRcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkxNDcgKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICBpZiAoKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGBXcml0ZSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNlKCdzZW5kaW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlU2VudCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS53cml0ZShtZXNzYWdlLCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgV3JpdGUgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2VuZCgpIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYWxsaW5nIGVuZCgpIG9uIEhUVFAvMiBzdHJlYW0nKTtcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENhbGwgPSBIdHRwMlN1YmNoYW5uZWxDYWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child) {\n        this.child = child;\n        this.healthy = true;\n        this.healthListeners = new Set();\n        this.refcount = 0;\n        this.dataWatchers = new Set();\n        child.addHealthStateWatcher(childHealthy => {\n            /* A change to the child health state only affects this wrapper's overall\n             * health state if this wrapper is reporting healthy. */\n            if (this.healthy) {\n                this.updateHealthListeners();\n            }\n        });\n    }\n    updateHealthListeners() {\n        for (const listener of this.healthListeners) {\n            listener(this.isHealthy());\n        }\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n        this.refcount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            this.destroy();\n        }\n    }\n    destroy() {\n        for (const watcher of this.dataWatchers) {\n            watcher.destroy();\n        }\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    isHealthy() {\n        return this.healthy && this.child.isHealthy();\n    }\n    addHealthStateWatcher(listener) {\n        this.healthListeners.add(listener);\n    }\n    removeHealthStateWatcher(listener) {\n        this.healthListeners.delete(listener);\n    }\n    addDataWatcher(dataWatcher) {\n        dataWatcher.setSubchannel(this.getRealSubchannel());\n        this.dataWatchers.add(dataWatcher);\n    }\n    setHealthy(healthy) {\n        if (healthy !== this.healthy) {\n            this.healthy = healthy;\n            /* A change to this wrapper's health state only affects the overall\n             * reported health state if the child is healthy. */\n            if (this.child.isHealthy()) {\n                this.updateHealthListeners();\n            }\n        }\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n    getCallCredentials() {\n        return this.child.getCallCredentials();\n    }\n    getChannel() {\n        return this.child.getChannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWludGVyZmFjZS5qcz83OWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IHZvaWQgMDtcbmNsYXNzIEJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLmhlYWx0aHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmhlYWx0aExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YVdhdGNoZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBjaGlsZC5hZGRIZWFsdGhTdGF0ZVdhdGNoZXIoY2hpbGRIZWFsdGh5ID0+IHtcbiAgICAgICAgICAgIC8qIEEgY2hhbmdlIHRvIHRoZSBjaGlsZCBoZWFsdGggc3RhdGUgb25seSBhZmZlY3RzIHRoaXMgd3JhcHBlcidzIG92ZXJhbGxcbiAgICAgICAgICAgICAqIGhlYWx0aCBzdGF0ZSBpZiB0aGlzIHdyYXBwZXIgaXMgcmVwb3J0aW5nIGhlYWx0aHkuICovXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFsdGh5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFsdGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlYWx0aExpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmhlYWx0aExpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcy5pc0hlYWx0aHkoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgfVxuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICB0aGlzLmNoaWxkLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZjb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyIG9mIHRoaXMuZGF0YVdhdGNoZXJzKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgaXNIZWFsdGh5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFsdGh5ICYmIHRoaXMuY2hpbGQuaXNIZWFsdGh5KCk7XG4gICAgfVxuICAgIGFkZEhlYWx0aFN0YXRlV2F0Y2hlcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmhlYWx0aExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVIZWFsdGhTdGF0ZVdhdGNoZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5oZWFsdGhMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYWRkRGF0YVdhdGNoZXIoZGF0YVdhdGNoZXIpIHtcbiAgICAgICAgZGF0YVdhdGNoZXIuc2V0U3ViY2hhbm5lbCh0aGlzLmdldFJlYWxTdWJjaGFubmVsKCkpO1xuICAgICAgICB0aGlzLmRhdGFXYXRjaGVycy5hZGQoZGF0YVdhdGNoZXIpO1xuICAgIH1cbiAgICBzZXRIZWFsdGh5KGhlYWx0aHkpIHtcbiAgICAgICAgaWYgKGhlYWx0aHkgIT09IHRoaXMuaGVhbHRoeSkge1xuICAgICAgICAgICAgdGhpcy5oZWFsdGh5ID0gaGVhbHRoeTtcbiAgICAgICAgICAgIC8qIEEgY2hhbmdlIHRvIHRoaXMgd3JhcHBlcidzIGhlYWx0aCBzdGF0ZSBvbmx5IGFmZmVjdHMgdGhlIG92ZXJhbGxcbiAgICAgICAgICAgICAqIHJlcG9ydGVkIGhlYWx0aCBzdGF0ZSBpZiB0aGUgY2hpbGQgaXMgaGVhbHRoeS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkLmlzSGVhbHRoeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFsdGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gQmFzZVN1YmNoYW5uZWxXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubchannelPool = void 0;\nexports.getSubchannelPool = getSubchannelPool;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */\n    constructor() {\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // eslint-disable-disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool();\n    }\n}\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDBCQUEwQixtQkFBTyxDQUFDLHFHQUFtQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzP2IwYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSB2b2lkIDA7XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XG5jb25zdCBjaGFubmVsX29wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtb3B0aW9uc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWxcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKTtcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gY2hlY2tzIGZvciBkcm9wcGluZyBzdWJjaGFubmVscyB0aGF0IGhhdmUgbm9cbiAqIG90aGVyIHJlZmVyZW5jZXNcbiAqL1xuY29uc3QgUkVGX0NIRUNLX0lOVEVSVkFMID0gMTAwMDA7XG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XG4gICAgLyoqXG4gICAgICogQSBwb29sIG9mIHN1YmNoYW5uZWxzIHVzZSBmb3IgbWFraW5nIGNvbm5lY3Rpb25zLiBTdWJjaGFubmVscyB3aXRoIHRoZVxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXIgb2YgYSB0YXNrIHBlcmZvcm1pbmcgYSBwZXJpb2RpYyBzdWJjaGFubmVsIGNsZWFudXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVmcyBhbGwgdW51c2VkIHN1YmNoYW5uZWxzIGFuZCBjYW5jZWxzIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsXG4gICAgICogc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICovXG4gICAgdW5yZWZVbnVzZWRTdWJjaGFubmVscygpIHtcbiAgICAgICAgbGV0IGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IHRydWU7XG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxuICAgICAgICAgKiBoYXZlIGEgcHJvdG90eXBlLCB3aGljaCBtZWFucyB0aGF0IGZvciAoLi4uIGluIC4uLikgbG9vcHMgb3ZlciB0aGVtXG4gICAgICAgICAqIGRvIG5vdCBuZWVkIHRvIGJlIGZpbHRlcmVkICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKHZhbHVlID0+ICF2YWx1ZS5zdWJjaGFubmVsLnVucmVmSWZPbmVSZWYoKSk7XG4gICAgICAgICAgICBpZiAocmVmZWRTdWJjaGFubmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWxsU3ViY2hhbm5lbHNVbnJlZmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBGb3IgZWFjaCBzdWJjaGFubmVsIGluIHRoZSBwb29sLCB0cnkgdG8gdW5yZWYgaXQgaWYgaXQgaGFzXG4gICAgICAgICAgICAgKiBleGFjdGx5IG9uZSByZWYgKHdoaWNoIGlzIHRoZSByZWYgZnJvbSB0aGUgcG9vbCBpdHNlbGYpLiBJZiB0aGF0XG4gICAgICAgICAgICAgKiBkb2VzIGhhcHBlbiwgcmVtb3ZlIHRoZSBzdWJjaGFubmVsIGZyb20gdGhlIHBvb2wgKi9cbiAgICAgICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XSA9IHJlZmVkU3ViY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgLyogQ3VycmVudGx5IHdlIGRvIG5vdCBkZWxldGUga2V5cyB3aXRoIGVtcHR5IHZhbHVlcy4gSWYgdGhhdCByZXN1bHRzXG4gICAgICAgICAqIGluIHNpZ25pZmljYW50IG1lbW9yeSB1c2FnZSB3ZSBzaG91bGQgY2hhbmdlIGl0LiAqL1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGNsZWFudXAgdGFzayBpZiBhbGwgc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICAgIGlmIChhbGxTdWJjaGFubmVsc1VucmVmZWQgJiYgdGhpcy5jbGVhbnVwVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgY2xlYW51cCB0YXNrIGlzIHNwYXduZWQuXG4gICAgICovXG4gICAgZW5zdXJlQ2xlYW51cFRhc2soKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNsZWFudXBUaW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XG4gICAgICAgICAgICB9LCBSRUZfQ0hFQ0tfSU5URVJWQUwpO1xuICAgICAgICAgICAgLy8gVW5yZWYgYmVjYXVzZSB0aGlzIHRpbWVyIHNob3VsZCBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBydW5uaW5nLlxuICAgICAgICAgICAgLy8gQ2FsbCB1bnJlZiBvbmx5IGlmIGl0IGV4aXN0cyB0byBhZGRyZXNzIGVsZWN0cm9uL2VsZWN0cm9uIzIxMTYyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNsZWFudXBUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdWJjaGFubmVsIGlmIG9uZSBhbHJlYWR5IGV4aXN0cyB3aXRoIGV4YWN0bHkgbWF0Y2hpbmcgcGFyYW1ldGVycy5cbiAgICAgKiBPdGhlcndpc2UsIGNyZWF0ZSBhbmQgc2F2ZSBhIHN1YmNoYW5uZWwgd2l0aCB0aG9zZSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxUYXJnZXRcbiAgICAgKiBAcGFyYW0gY2hhbm5lbEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSBjaGFubmVsQ3JlZGVudGlhbHNcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZVN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2xlYW51cFRhc2soKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFRhcmdldCA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKGNoYW5uZWxUYXJnZXRVcmkpO1xuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbE9iaiBvZiBzdWJjaGFubmVsT2JqQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwpKHN1YmNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbEFkZHJlc3MpICYmXG4gICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsX29wdGlvbnNfMS5jaGFubmVsT3B0aW9uc0VxdWFsKShjaGFubmVsQXJndW1lbnRzLCBzdWJjaGFubmVsT2JqLmNoYW5uZWxBcmd1bWVudHMpICYmXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscy5fZXF1YWxzKHN1YmNoYW5uZWxPYmouY2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbE9iai5zdWJjaGFubmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgbm8gbWF0Y2hpbmcgc3ViY2hhbm5lbCB3YXMgZm91bmRcbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IG5ldyBzdWJjaGFubmVsXzEuU3ViY2hhbm5lbChjaGFubmVsVGFyZ2V0VXJpLCBzdWJjaGFubmVsVGFyZ2V0LCBjaGFubmVsQXJndW1lbnRzLCBjaGFubmVsQ3JlZGVudGlhbHMsIG5ldyB0cmFuc3BvcnRfMS5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IoY2hhbm5lbFRhcmdldFVyaSkpO1xuICAgICAgICBpZiAoIShjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XS5wdXNoKHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxBZGRyZXNzOiBzdWJjaGFubmVsVGFyZ2V0LFxuICAgICAgICAgICAgY2hhbm5lbEFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscyxcbiAgICAgICAgICAgIHN1YmNoYW5uZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICByZXR1cm4gc3ViY2hhbm5lbDtcbiAgICB9XG59XG5leHBvcnRzLlN1YmNoYW5uZWxQb29sID0gU3ViY2hhbm5lbFBvb2w7XG5jb25zdCBnbG9iYWxTdWJjaGFubmVsUG9vbCA9IG5ldyBTdWJjaGFubmVsUG9vbCgpO1xuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBnbG9iYWwgc3ViY2hhbm5lbCBwb29sLCBvciBhIG5ldyBzdWJjaGFubmVsIHBvb2wuXG4gKiBAcGFyYW0gZ2xvYmFsXG4gKi9cbmZ1bmN0aW9uIGdldFN1YmNoYW5uZWxQb29sKGdsb2JhbCkge1xuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFN1YmNoYW5uZWxQb29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJjaGFubmVsUG9vbCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtcG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst single_subchannel_channel_1 = __webpack_require__(/*! ./single-subchannel-channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/single-subchannel-channel.js\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.dataProducers = new Map();\n        this.subchannelChannel = null;\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n            this.channelzTrace = new channelz_1.ChannelzTraceStub();\n            this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n        }\n        else {\n            this.channelzTrace = new channelz_1.ChannelzTrace();\n            this.callTracker = new channelz_1.ChannelzCallTracker();\n            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n        this.trace('Subchannel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n        this.secureConnector = credentials._createSecureConnector(channelTarget, options);\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString,\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        }\n        else {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options['grpc.keepalive_time_ms']) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });\n        }\n        this.connector\n            .connect(this.subchannelAddress, this.secureConnector, options)\n            .then(transport => {\n            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener(tooManyPings => {\n                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            }\n            else {\n                /* If we can't transition from CONNECTING to READY here, we will\n                 * not be using this transport, so release its resources. */\n                transport.shutdown();\n            }\n        }, error => {\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        if (errorMessage) {\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n                ' -> ' +\n                connectivity_state_1.ConnectivityState[newState] +\n                ' with error \"' + errorMessage + '\"');\n        }\n        else {\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n                ' -> ' +\n                connectivity_state_1.ConnectivityState[newState]);\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n                if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(() => {\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners) {\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            this.secureConnector.destroy();\n            process.nextTick(() => {\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error('Cannot create call, subchannel not READY');\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: status => {\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.callTracker.addCallFailed();\n                    }\n                },\n            };\n        }\n        else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        process.nextTick(() => {\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */\n            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        process.nextTick(() => {\n            this.backoffTimeout.reset();\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    isHealthy() {\n        return true;\n    }\n    addHealthStateWatcher(listener) {\n        // Do nothing with the listener\n    }\n    removeHealthStateWatcher(listener) {\n        // Do nothing with the listener\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n    getCallCredentials() {\n        return this.secureConnector.getCallCredentials();\n    }\n    getChannel() {\n        if (!this.subchannelChannel) {\n            this.subchannelChannel = new single_subchannel_channel_1.SingleSubchannelChannel(this, this.channelTarget, this.options);\n        }\n        return this.subchannelChannel;\n    }\n    addDataWatcher(dataWatcher) {\n        throw new Error('Not implemented');\n    }\n    getOrCreateDataProducer(name, createDataProducer) {\n        const existingProducer = this.dataProducers.get(name);\n        if (existingProducer) {\n            return existingProducer;\n        }\n        const newProducer = createDataProducer(this);\n        this.dataProducers.set(name, newProducer);\n        return newProducer;\n    }\n    removeDataProducer(name) {\n        this.dataProducers.delete(name);\n    }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLG9DQUFvQyxtQkFBTyxDQUFDLHlIQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLGlEQUFpRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixtREFBbUQsS0FBSyw4QkFBOEIsMEVBQTBFLG9CQUFvQjtBQUN6UTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUpBQXFKLE1BQU07QUFDM0osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwuanM/MWIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJjaGFubmVsID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBzaW5nbGVfc3ViY2hhbm5lbF9jaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zaW5nbGUtc3ViY2hhbm5lbC1jaGFubmVsXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbCc7XG4vKiBzZXRJbnRlcnZhbCBhbmQgc2V0VGltZW91dCBvbmx5IGFjY2VwdCBzaWduZWQgMzIgYml0IGludGVnZXJzLiBKUyBkb2Vzbid0XG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxuICogdG8gY2FsY3VsYXRlIGl0ICovXG5jb25zdCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgPSB+KDEgPDwgMzEpO1xuY2xhc3MgU3ViY2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEFkZHJlc3MgVGhlIGFkZHJlc3MgZm9yIHRoZSBiYWNrZW5kIHRoYXQgdGhpcyBzdWJjaGFubmVsXG4gICAgICogICAgIHdpbGwgY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xuICAgICAqICAgICBmb3IgdGhpcyBzdWJjaGFubmVsXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjaGFubmVsIGNyZWRlbnRpYWxzIHVzZWQgdG8gZXN0YWJsaXNoIHRoaXNcbiAgICAgKiAgICAgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBjcmVkZW50aWFscywgY29ubmVjdG9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzcyA9IHN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuIEludmFyaWFudDogYHNlc3Npb25gID09PSBgbnVsbGBcbiAgICAgICAgICogaWYgYW5kIG9ubHkgaWYgYGNvbm5lY3Rpdml0eVN0YXRlYCBpcyBJRExFIG9yIFRSQU5TSUVOVF9GQUlMVVJFLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5kZXJseWluZyBodHRwMiBzZXNzaW9uIHVzZWQgdG8gbWFrZSByZXF1ZXN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBzdWJjaGFubmVsIHNob3VsZCB0cmFuc2l0aW9uIGZyb20gVFJBTlNJRU5UX0ZBSUxVUkUgdG9cbiAgICAgICAgICogQ09OTkVDVElORyBpbnN0ZWFkIG9mIElETEUgd2hlbiB0aGUgYmFja29mZiB0aW1lb3V0IGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjb25uZWN0aXZpdHlcbiAgICAgICAgICogc3RhdGUgY2hhbmdlcy4gV2lsbCBiZSBtb2RpZmllZCBieSBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmAgYW5kXG4gICAgICAgICAqIGByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBjaGFubmVscyBhbmQgc3ViY2hhbm5lbCBwb29scyB3aXRoIHJlZmVyZW5jZXMgdG8gdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmNvdW50ID0gMDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YVByb2R1Y2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBvcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gKF9hID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlU3R1YigpO1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViKCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YigpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTdWJjaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcbiAgICAgICAgdGhpcy5zZWN1cmVDb25uZWN0b3IgPSBjcmVkZW50aWFscy5fY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICByZWZUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnc3ViY2hhbm5lbF9yZWZjb3VudCcsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGhhbmRsZUJhY2tvZmZUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGludWVDb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGJhY2tvZmYgdGltZXIgd2l0aCB0aGUgY3VycmVudCBuZXh0QmFja29mZiB0aW1lb3V0XG4gICAgICovXG4gICAgc3RhcnRCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJ1bk9uY2UoKTtcbiAgICB9XG4gICAgc3RvcEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgfVxuICAgIHN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWRLZWVwYWxpdmVUaW1lID0gTWF0aC5taW4odGhpcy5rZWVwYWxpdmVUaW1lLCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiBhZGp1c3RlZEtlZXBhbGl2ZVRpbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0b3JcbiAgICAgICAgICAgIC5jb25uZWN0KHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MsIHRoaXMuc2VjdXJlQ29ubmVjdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNwb3J0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKHRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0b29NYW55UGluZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vTWFueVBpbmdzICYmIHRoaXMua2VlcGFsaXZlVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgQ29ubmVjdGlvbiB0byAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCl9IGF0ICR7dGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZ30gcmVqZWN0ZWQgYnkgc2VydmVyIGJlY2F1c2Ugb2YgZXhjZXNzIHBpbmdzLiBJbmNyZWFzaW5nIHBpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmtlZXBhbGl2ZVRpbWV9IG1zYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIElmIHdlIGNhbid0IHRyYW5zaXRpb24gZnJvbSBDT05ORUNUSU5HIHRvIFJFQURZIGhlcmUsIHdlIHdpbGxcbiAgICAgICAgICAgICAgICAgKiBub3QgYmUgdXNpbmcgdGhpcyB0cmFuc3BvcnQsIHNvIHJlbGVhc2UgaXRzIHJlc291cmNlcy4gKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2h1dGRvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBgJHtlcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIHRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eVN0YXRlIGlzIG5vdCBpbiBvbGRTdGF0ZXMsIGRvIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIG9sZFN0YXRlcyBUaGUgc2V0IG9mIHN0YXRlcyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG9sZFN0YXRlcy5pbmRleE9mKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgXCInICsgZXJyb3JNZXNzYWdlICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZSB0byAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QmFja29mZigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQgJiYgdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLnRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgc3RhdGUsIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgdHJhbnNpdGlvbiBvdXQgb2ZcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBhcyB0aG91Z2ggdGhlIGJhY2tvZmYgdGltZXIgaXMgZW5kaW5nIHJpZ2h0IG5vdyAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQgJiYgdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLnRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiB1bmtub3duIENvbm5lY3Rpdml0eVN0YXRlICR7bmV3U3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgdGhpcy5rZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgKyB0aGlzLnJlZmNvdW50ICsgJyAtPiAnICsgKHRoaXMucmVmY291bnQgKyAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgKyB0aGlzLnJlZmNvdW50ICsgJyAtPiAnICsgKHRoaXMucmVmY291bnQgLSAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTaHV0dGluZyBkb3duJyk7XG4gICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgdGhpcy5zZWN1cmVDb25uZWN0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmSWZPbmVSZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVmKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGNhbGwsIHN1YmNoYW5uZWwgbm90IFJFQURZJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRzVHJhY2tlcjtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIHN0YXRzVHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3RhdHNUcmFja2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudGx5IElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYW5kIHN3aXRjaCB0byB0aGVcbiAgICAgKiBDT05ORUNUSU5HIHN0YXRlLiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBjdXJyZW50IGluIFRSQU5TSUVOVF9GQUlMVVJFLFxuICAgICAqIHRoZSBuZXh0IHRpbWUgaXQgd291bGQgdHJhbnNpdGlvbiB0byBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFnYWluIGluc3RlYWQuXG4gICAgICogT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAvKiBGaXJzdCwgdHJ5IHRvIHRyYW5zaXRpb24gZnJvbSBJRExFIHRvIGNvbm5lY3RpbmcuIElmIHRoYXQgZG9lc24ndCBoYXBwZW5cbiAgICAgICAgICAgICAqIGJlY2F1c2UgdGhlIHN0YXRlIGlzIG5vdCBjdXJyZW50bHkgSURMRSwgY2hlY2sgaWYgaXQgaXNcbiAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xuICAgICAgICAgICAgICogY29ubmVjdGluZyBhZnRlciB0aGUgYmFja29mZiB0aW1lciBlbmRzLiBPdGhlcndpc2UgZG8gbm90aGluZyAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzdWJjaGFubmVsJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgYmFja29mZiB0aW1lb3V0LCBhbmQgaW1tZWRpYXRlbHkgc3RhcnQgY29ubmVjdGluZyBpZiBpbiBiYWNrb2ZmLlxuICAgICAqL1xuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmc7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgaXNIZWFsdGh5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRkSGVhbHRoU3RhdGVXYXRjaGVyKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgd2l0aCB0aGUgbGlzdGVuZXJcbiAgICB9XG4gICAgcmVtb3ZlSGVhbHRoU3RhdGVXYXRjaGVyKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgd2l0aCB0aGUgbGlzdGVuZXJcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFsU3ViY2hhbm5lbEVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gdGhpcztcbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICBpZiAobmV3S2VlcGFsaXZlVGltZSA+IHRoaXMua2VlcGFsaXZlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDYWxsQ3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY3VyZUNvbm5lY3Rvci5nZXRDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YmNoYW5uZWxDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGFubmVsID0gbmV3IHNpbmdsZV9zdWJjaGFubmVsX2NoYW5uZWxfMS5TaW5nbGVTdWJjaGFubmVsQ2hhbm5lbCh0aGlzLCB0aGlzLmNoYW5uZWxUYXJnZXQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbENoYW5uZWw7XG4gICAgfVxuICAgIGFkZERhdGFXYXRjaGVyKGRhdGFXYXRjaGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGdldE9yQ3JlYXRlRGF0YVByb2R1Y2VyKG5hbWUsIGNyZWF0ZURhdGFQcm9kdWNlcikge1xuICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y2VyID0gdGhpcy5kYXRhUHJvZHVjZXJzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvZHVjZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1Byb2R1Y2VyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1Byb2R1Y2VyID0gY3JlYXRlRGF0YVByb2R1Y2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGFQcm9kdWNlcnMuc2V0KG5hbWUsIG5ld1Byb2R1Y2VyKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb2R1Y2VyO1xuICAgIH1cbiAgICByZW1vdmVEYXRhUHJvZHVjZXIobmFtZSkge1xuICAgICAgICB0aGlzLmRhdGFQcm9kdWNlcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbCA9IFN1YmNoYW5uZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CIPHER_SUITES = void 0;\nexports.getDefaultRootsData = getDefaultRootsData;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcz8xOGEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNJUEhFUl9TVUlURVMgPSB2b2lkIDA7XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBnZXREZWZhdWx0Um9vdHNEYXRhO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5leHBvcnRzLkNJUEhFUl9TVUlURVMgPSBwcm9jZXNzLmVudi5HUlBDX1NTTF9DSVBIRVJfU1VJVEVTO1xuY29uc3QgREVGQVVMVF9ST09UU19GSUxFX1BBVEggPSBwcm9jZXNzLmVudi5HUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSDtcbmxldCBkZWZhdWx0Um9vdHNEYXRhID0gbnVsbDtcbmZ1bmN0aW9uIGdldERlZmF1bHRSb290c0RhdGEoKSB7XG4gICAgaWYgKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Um9vdHNEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Um9vdHNEYXRhID0gZnMucmVhZEZpbGVTeW5jKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFJvb3RzRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10bHMtaGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(action-browser)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, \n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    remoteName) {\n        this.session = session;\n        this.options = options;\n        this.remoteName = remoteName;\n        /**\n         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n         */\n        this.keepaliveTimer = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */\n        this.pendingSendKeepalivePing = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n        }\n        else {\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter(e => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        else {\n            this.keepaliveTimeMs = -1;\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        else {\n            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        }\n        if ('grpc.keepalive_permit_without_calls' in options) {\n            this.keepaliveWithoutCalls =\n                options['grpc.keepalive_permit_without_calls'] === 1;\n        }\n        else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once('close', () => {\n            this.trace('session closed');\n            this.handleDisconnect();\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                opaqueData &&\n                opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace('connection closed by GOAWAY with code ' +\n                errorCode +\n                ' and data ' +\n                (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once('error', error => {\n            this.trace('connection closed with error ' + error.message);\n            this.handleDisconnect();\n        });\n        session.socket.once('close', (hadError) => {\n            this.trace('connection closed. hadError=' + hadError);\n            this.handleDisconnect();\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on('remoteSettings', (settings) => {\n                this.trace('new settings received' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n            session.on('localSettings', (settings) => {\n                this.trace('local settings acknowledged by remote' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */\n        if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n        if (session.socket instanceof tls_1.TLSSocket) {\n            this.authContext = {\n                transportSecurityType: 'ssl',\n                sslPeerCertificate: session.socket.getPeerCertificate()\n            };\n        }\n        else {\n            this.authContext = {};\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\n            : null;\n        const localAddress = sessionSocket.localAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\n            : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && 'raw' in peerCertificate\n                    ? peerCertificate.raw\n                    : null,\n            };\n        }\n        else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */\n    reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach(listener => listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */\n    handleDisconnect() {\n        this.clearKeepaliveTimeout();\n        this.reportDisconnectToOwner(false);\n        for (const call of this.activeCalls) {\n            call.onDisconnect();\n        }\n        // Wait an event loop cycle before destroying the connection\n        setImmediate(() => {\n            this.session.destroy();\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    canSendPing() {\n        return (!this.session.destroyed &&\n            this.keepaliveTimeMs > 0 &&\n            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));\n    }\n    maybeSendPing() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.keepaliveTimer) {\n            console.error('keepaliveTimeout is not null');\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n        this.keepaliveTimer = setTimeout(() => {\n            this.keepaliveTimer = null;\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        let pingSendError = '';\n        try {\n            const pingSentSuccessfully = this.session.ping((err, duration, payload) => {\n                this.clearKeepaliveTimeout();\n                if (err) {\n                    this.keepaliveTrace('Ping failed with error ' + err.message);\n                    this.handleDisconnect();\n                }\n                else {\n                    this.keepaliveTrace('Received ping response');\n                    this.maybeStartKeepalivePingTimer();\n                }\n            });\n            if (!pingSentSuccessfully) {\n                pingSendError = 'Ping returned false';\n            }\n        }\n        catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n        }\n        if (pingSendError) {\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n            this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */\n    maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        }\n        else if (!this.keepaliveTimer) {\n            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n            this.keepaliveTimer = setTimeout(() => {\n                this.keepaliveTimer = null;\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs);\n            (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */\n    }\n    /**\n     * Clears whichever keepalive timeout is currently active, if any.\n     */\n    clearKeepaliveTimeout() {\n        if (this.keepaliveTimer) {\n            clearTimeout(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */\n        try {\n            http2Stream = this.session.request(headers);\n        }\n        catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace('local window size: ' +\n            this.session.state.localWindowSize +\n            ' remote window size: ' +\n            this.session.state.remoteWindowSize);\n        this.internalsTrace('session.closed=' +\n            this.session.closed +\n            ' session.destroyed=' +\n            this.session.destroyed +\n            ' session.socket.destroyed=' +\n            this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        else {\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    getOptions() {\n        return this.options;\n    }\n    getAuthContext() {\n        return this.authContext;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget) {\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n    }\n    createSession(secureConnectResult, address, options) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        if (secureConnectResult.socket.closed) {\n            return Promise.reject('Connection closed before starting HTTP/2 handshake');\n        }\n        return new Promise((resolve, reject) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            let remoteName = null;\n            let realTarget = this.channelTarget;\n            if ('grpc.http_connect_target' in options) {\n                const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\n                if (parsedTarget) {\n                    realTarget = parsedTarget;\n                    remoteName = (0, uri_parser_1.uriToString)(parsedTarget);\n                }\n            }\n            const scheme = secureConnectResult.secure ? 'https' : 'http';\n            const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n            const closeHandler = () => {\n                var _a;\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(() => {\n                    if (!reportedError) {\n                        reportedError = true;\n                        reject(`${errorMessage.trim()} (${new Date().toISOString()})`);\n                    }\n                });\n            };\n            const errorHandler = (error) => {\n                var _a;\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n                errorMessage = error.message;\n                this.trace('connection failed with error ' + errorMessage);\n                if (!reportedError) {\n                    reportedError = true;\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                }\n            };\n            const sessionOptions = {\n                createConnection: (authority, option) => {\n                    return secureConnectResult.socket;\n                },\n                settings: {\n                    initialWindowSize: (_d = (_a = options['grpc-node.flow_control_window']) !== null && _a !== void 0 ? _a : (_c = (_b = http2.getDefaultSettings) === null || _b === void 0 ? void 0 : _b.call(http2)) === null || _c === void 0 ? void 0 : _c.initialWindowSize) !== null && _d !== void 0 ? _d : 65535,\n                }\n            };\n            const session = http2.connect(`${scheme}://${targetPath}`, sessionOptions);\n            // Prepare window size configuration for remoteSettings handler\n            const defaultWin = (_g = (_f = (_e = http2.getDefaultSettings) === null || _e === void 0 ? void 0 : _e.call(http2)) === null || _f === void 0 ? void 0 : _f.initialWindowSize) !== null && _g !== void 0 ? _g : 65535; // 65 535 B\n            const connWin = options['grpc-node.flow_control_window'];\n            this.session = session;\n            let errorMessage = 'Failed to connect';\n            let reportedError = false;\n            session.unref();\n            session.once('remoteSettings', () => {\n                var _a;\n                // Send WINDOW_UPDATE now to avoid 65 KB start-window stall.\n                if (connWin && connWin > defaultWin) {\n                    try {\n                        // Node  14.18\n                        session.setLocalWindowSize(connWin);\n                    }\n                    catch (_b) {\n                        // Older Node: bump by the delta\n                        const delta = connWin - ((_a = session.state.localWindowSize) !== null && _a !== void 0 ? _a : defaultWin);\n                        if (delta > 0)\n                            session.incrementWindowSize(delta);\n                    }\n                }\n                session.removeAllListeners();\n                secureConnectResult.socket.removeListener('close', closeHandler);\n                secureConnectResult.socket.removeListener('error', errorHandler);\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once('close', closeHandler);\n            session.once('error', errorHandler);\n            secureConnectResult.socket.once('close', closeHandler);\n            secureConnectResult.socket.once('error', errorHandler);\n        });\n    }\n    tcpConnect(address, options) {\n        return (0, http_proxy_1.getProxiedConnection)(address, options).then(proxiedSocket => {\n            if (proxiedSocket) {\n                return proxiedSocket;\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    const closeCallback = () => {\n                        reject(new Error('Socket closed'));\n                    };\n                    const errorCallback = (error) => {\n                        reject(error);\n                    };\n                    const socket = net.connect(address, () => {\n                        socket.removeListener('close', closeCallback);\n                        socket.removeListener('error', errorCallback);\n                        resolve(socket);\n                    });\n                    socket.once('close', closeCallback);\n                    socket.once('error', errorCallback);\n                });\n            }\n        });\n    }\n    async connect(address, secureConnector, options) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        let tcpConnection = null;\n        let secureConnectResult = null;\n        const addressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n        try {\n            this.trace(addressString + ' Waiting for secureConnector to be ready');\n            await secureConnector.waitForReady();\n            this.trace(addressString + ' secureConnector is ready');\n            tcpConnection = await this.tcpConnect(address, options);\n            tcpConnection.setNoDelay();\n            this.trace(addressString + ' Established TCP connection');\n            secureConnectResult = await secureConnector.connect(tcpConnection);\n            this.trace(addressString + ' Established secure connection');\n            return this.createSession(secureConnectResult, address, options);\n        }\n        catch (e) {\n            tcpConnection === null || tcpConnection === void 0 ? void 0 : tcpConnection.destroy();\n            secureConnectResult === null || secureConnectResult === void 0 ? void 0 : secureConnectResult.socket.destroy();\n            throw e;\n        }\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLDBCQUEwQixtQkFBTyxDQUFDLHFHQUFtQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZTtBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLHFIQUFxQztBQUMzRCxRQUFRLHVJQUF1STtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQixHQUFHLHlCQUF5QjtBQUNuRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsR0FBRyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLEtBQUssV0FBVztBQUNwRTtBQUNBLG1PQUFtTztBQUNuTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3RyYW5zcG9ydC5qcz83M2QzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9jYWxsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWNhbGxcIik7XG5jb25zdCBjYWxsX251bWJlcl8xID0gcmVxdWlyZShcIi4vY2FsbC1udW1iZXJcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICd0cmFuc3BvcnQnO1xuY29uc3QgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FID0gJ3RyYW5zcG9ydF9mbG93Y3RybCc7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IHsgSFRUUDJfSEVBREVSX0FVVEhPUklUWSwgSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSwgSFRUUDJfSEVBREVSX01FVEhPRCwgSFRUUDJfSEVBREVSX1BBVEgsIEhUVFAyX0hFQURFUl9URSwgSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQsIH0gPSBodHRwMi5jb25zdGFudHM7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgdG9vTWFueVBpbmdzRGF0YSA9IEJ1ZmZlci5mcm9tKCd0b29fbWFueV9waW5ncycsICdhc2NpaScpO1xuY2xhc3MgSHR0cDJUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSByZW1vdGUgc2VydmVyLCBpZiBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHN1YmNoYW5uZWxcbiAgICAgKiBhZGRyZXNzLCBpLmUuIGlmIGNvbm5lY3RpbmcgdGhyb3VnaCBhbiBIVFRQIENPTk5FQ1QgcHJveHkuXG4gICAgICovXG4gICAgcmVtb3RlTmFtZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSByZW1vdGVOYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXIgcmVmZXJlbmNlIGluZGljYXRpbmcgd2hlbiB0byBzZW5kIHRoZSBuZXh0IHBpbmcgb3Igd2hlbiB0aGUgbW9zdCByZWNlbnQgcGluZyB3aWxsIGJlIGNvbnNpZGVyZWQgbG9zdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGtlZXBhbGl2ZSB0aW1lciByYW4gb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlXG4gICAgICAgICAqIGNhbGxzLCBhbmQgYSBwaW5nIHNob3VsZCBiZSBzZW50IHRoZSBuZXh0IHRpbWUgYSBjYWxsIHN0YXJ0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAvKiBQb3B1bGF0ZSBzdWJjaGFubmVsQWRkcmVzc1N0cmluZyBhbmQgY2hhbm5lbHpSZWYgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAqIGVsc2UsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0aGUgdHJhY2UgbWV0aG9kcy4gKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBbXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUpXG4gICAgICAgICAgICAuam9pbignICcpOyAvLyByZW1vdmUgZmFsc2V5IHZhbHVlcyBmaXJzdFxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dE1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBLRUVQQUxJVkVfVElNRU9VVF9NUztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XG4gICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3Nlc3Npb24gY2xvc2VkJyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZ29hd2F5JywgKGVycm9yQ29kZSwgbGFzdFN0cmVhbUlELCBvcGFxdWVEYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9vTWFueVBpbmdzID0gZmFsc2U7XG4gICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BOC1jbGllbnQtc2lkZS1rZWVwYWxpdmUubWQjYmFzaWMta2VlcGFsaXZlICovXG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSAmJlxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEgJiZcbiAgICAgICAgICAgICAgICBvcGFxdWVEYXRhLmVxdWFscyh0b29NYW55UGluZ3NEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRvb01hbnlQaW5ncyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCBieSBHT0FXQVkgd2l0aCBjb2RlICcgK1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZSArXG4gICAgICAgICAgICAgICAgJyBhbmQgZGF0YSAnICtcbiAgICAgICAgICAgICAgICAob3BhcXVlRGF0YSA9PT0gbnVsbCB8fCBvcGFxdWVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGFxdWVEYXRhLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RGlzY29ubmVjdFRvT3duZXIodG9vTWFueVBpbmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCB3aXRoIGVycm9yICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5zb2NrZXQub25jZSgnY2xvc2UnLCAoaGFkRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkLiBoYWRFcnJvcj0nICsgaGFkRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdyZW1vdGVTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ25ldyBzZXR0aW5ncyByZWNlaXZlZCcgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2xvY2FsU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdsb2NhbCBzZXR0aW5ncyBhY2tub3dsZWRnZWQgYnkgcmVtb3RlJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIFN0YXJ0IHRoZSBrZWVwYWxpdmUgdGltZXIgbGFzdCwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyIHRyYWNlIGxvZ3MsXG4gICAgICAgICAqIHdoaWNoIHNob3VsZCBvbmx5IGhhcHBlbiBhZnRlciBldmVyeXRoaW5nIGVsc2UgaXMgc2V0IHVwLiAqL1xuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXNzaW9uLnNvY2tldCBpbnN0YW5jZW9mIHRsc18xLlRMU1NvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRTZWN1cml0eVR5cGU6ICdzc2wnLFxuICAgICAgICAgICAgICAgIHNzbFBlZXJDZXJ0aWZpY2F0ZTogc2Vzc2lvbi5zb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF1dGhDb250ZXh0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzc1xuICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBsZXQgdGxzSW5mbztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHNlc3Npb25Tb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYSA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlT3RoZXJOYW1lOiBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSA/IG51bGwgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiBwZWVyQ2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gcGVlckNlcnRpZmljYXRlXG4gICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGxzSW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcbiAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxuICAgICAgICAgICAgcmVtb3RlTmFtZTogdGhpcy5yZW1vdGVOYW1lLFxuICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IHRoaXMua2VlcGFsaXZlc1NlbnQsXG4gICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiB0aGlzLnN0cmVhbVRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogKF9iID0gdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBrZWVwYWxpdmVUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgZmxvd0NvbnRyb2xUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGludGVybmFsc1RyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICd0cmFuc3BvcnRfaW50ZXJuYWxzJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdG8gdGhlIG93bmVyIG9mIHRoaXMgb2JqZWN0IHRoYXQgdGhpcyB0cmFuc3BvcnQgc2hvdWxkIG5vIGxvbmdlclxuICAgICAqIGJlIHVzZWQuIFRoYXQgaGFwcGVucyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgb3IgaWYgdGhlIHNlcnZlciBzZW5kcyBhXG4gICAgICogR09BV0FZLlxuICAgICAqIEBwYXJhbSB0b29NYW55UGluZ3MgSWYgdHJ1ZSwgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGEgR09BV0FZIHdpdGggZGF0YVxuICAgICAqIGluZGljYXRpbmcgdGhhdCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlY2F1ZXMgdGhlIGNsaWVudCBzZW50IHRvbyBtYW55XG4gICAgICogcGluZ3MuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdEhhbmRsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIodG9vTWFueVBpbmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjb25uZWN0aW9uIGRyb3BzLCBidXQgbm90IEdPQVdBWXMuXG4gICAgICovXG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcihmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmFjdGl2ZUNhbGxzKSB7XG4gICAgICAgICAgICBjYWxsLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgYW4gZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgZGVzdHJveWluZyB0aGUgY29ubmVjdGlvblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNhblNlbmRQaW5nKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLnNlc3Npb24uZGVzdHJveWVkICYmXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyB8fCB0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPiAwKSk7XG4gICAgfVxuICAgIG1heWJlU2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2tlZXBhbGl2ZVRpbWVvdXQgaXMgbm90IG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5rZWVwYWxpdmVUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgbGV0IHBpbmdTZW5kRXJyb3IgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpbmdTZW50U3VjY2Vzc2Z1bGx5ID0gdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXBpbmdTZW50U3VjY2Vzc2Z1bGx5KSB7XG4gICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9ICdQaW5nIHJldHVybmVkIGZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxuICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9IChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnJykgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHNlbmQgZmFpbGVkOiAnICsgcGluZ1NlbmRFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGtlZXBhbGl2ZSBwaW5nIHRpbWVyIGlmIGFwcHJvcHJpYXRlLiBJZiB0aGUgdGltZXIgYWxyZWFkeSByYW5cbiAgICAgKiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmUgcmVxdWVzdHMsIGluc3RlYWQgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgdGhlIHBpbmcgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGEgcGluZyBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LFxuICAgICAqIGluc3RlYWQgZG8gbm90aGluZyBhbmQgd2FpdCBmb3IgdGhlbSB0byByZXNvbHZlLlxuICAgICAqL1xuICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcyk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZVRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE90aGVyd2lzZSwgdGhlcmUgaXMgYWxyZWFkeSBlaXRoZXIgYSBrZWVwYWxpdmUgdGltZXIgb3IgYSBwaW5nIHBlbmRpbmcsXG4gICAgICAgICAqIHdhaXQgZm9yIHRob3NlIHRvIHJlc29sdmUuICovXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB3aGljaGV2ZXIga2VlcGFsaXZlIHRpbWVvdXQgaXMgY3VycmVudGx5IGFjdGl2ZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmRlbGV0ZShjYWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQWN0aXZlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMuYWRkKGNhbGwpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDYWxscy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2dycGMnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IG1ldGhvZDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVEVdID0gJ3RyYWlsZXJzJztcbiAgICAgICAgbGV0IGh0dHAyU3RyZWFtO1xuICAgICAgICAvKiBJbiB0aGVvcnksIGlmIGFuIGVycm9yIGlzIHRocm93biBieSBzZXNzaW9uLnJlcXVlc3QgYmVjYXVzZSBzZXNzaW9uIGhhc1xuICAgICAgICAgKiBiZWNvbWUgdW51c2FibGUgKGUuZy4gYmVjYXVzZSBpdCBoYXMgcmVjZWl2ZWQgYSBnb2F3YXkpLCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICogc2hvdWxkIHNvb24gc2VlIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlIG9yIGdvYXdheSBldmVudCBhbnl3YXkgYW5kIGxlYXZlXG4gICAgICAgICAqIFJFQURZLiBCdXQgd2UgaGF2ZSBzZWVuIHJlcG9ydHMgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlblxuICAgICAgICAgKiAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvbm9kZWpzLWZpcmVzdG9yZS9pc3N1ZXMvMTAyMyNpc3N1ZWNvbW1lbnQtNjUzMjA0MDk2KVxuICAgICAgICAgKiBzbyBmb3IgZGVmZW5zZSBpbiBkZXB0aCwgd2UganVzdCBkaXNjYXJkIHRoZSBzZXNzaW9uIHdoZW4gd2Ugc2VlIGFuXG4gICAgICAgICAqIGVycm9yIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaHR0cDJTdHJlYW0gPSB0aGlzLnNlc3Npb24ucmVxdWVzdChoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxvd0NvbnRyb2xUcmFjZSgnbG9jYWwgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSArXG4gICAgICAgICAgICAnIHJlbW90ZSB3aW5kb3cgc2l6ZTogJyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxzVHJhY2UoJ3Nlc3Npb24uY2xvc2VkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uZGVzdHJveWVkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3llZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zb2NrZXQuZGVzdHJveWVkKTtcbiAgICAgICAgbGV0IGV2ZW50VHJhY2tlcjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBsZXQgY2FsbDtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlU2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FsbCA9IG5ldyBzdWJjaGFubmVsX2NhbGxfMS5IdHRwMlN1YmNoYW5uZWxDYWxsKGh0dHAyU3RyZWFtLCBldmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0aGlzLCAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKSk7XG4gICAgICAgIHRoaXMuYWRkQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgZ2V0UGVlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICBnZXRBdXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aENvbnRleHQ7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICB9XG59XG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLmNoYW5uZWxUYXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNyZWF0ZVNlc3Npb24oc2VjdXJlQ29ubmVjdFJlc3VsdCwgYWRkcmVzcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Nvbm5lY3Rpb24gY2xvc2VkIGJlZm9yZSBzdGFydGluZyBIVFRQLzIgaGFuZHNoYWtlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGxldCByZW1vdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWFsVGFyZ2V0ID0gdGhpcy5jaGFubmVsVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShvcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lID0gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocGFyc2VkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBzZWN1cmVDb25uZWN0UmVzdWx0LnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkocmVhbFRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIExlYXZlIHRpbWUgZm9yIGVycm9yIGV2ZW50IHRvIGhhcHBlbiBiZWZvcmUgcmVqZWN0aW5nXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXBvcnRlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChgJHtlcnJvck1lc3NhZ2UudHJpbSgpfSAoJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gZmFpbGVkIHdpdGggZXJyb3IgJyArIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBvcnRlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYCR7ZXJyb3JNZXNzYWdlfSAoJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uOiAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlY3VyZUNvbm5lY3RSZXN1bHQuc29ja2V0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1NpemU6IChfZCA9IChfYSA9IG9wdGlvbnNbJ2dycGMtbm9kZS5mbG93X2NvbnRyb2xfd2luZG93J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGh0dHAyLmdldERlZmF1bHRTZXR0aW5ncykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaHR0cDIpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5pdGlhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDY1NTM1LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChgJHtzY2hlbWV9Oi8vJHt0YXJnZXRQYXRofWAsIHNlc3Npb25PcHRpb25zKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgd2luZG93IHNpemUgY29uZmlndXJhdGlvbiBmb3IgcmVtb3RlU2V0dGluZ3MgaGFuZGxlclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFdpbiA9IChfZyA9IChfZiA9IChfZSA9IGh0dHAyLmdldERlZmF1bHRTZXR0aW5ncykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoaHR0cDIpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaW5pdGlhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDY1NTM1OyAvLyA2NSA1MzUgQlxuICAgICAgICAgICAgY29uc3QgY29ubldpbiA9IG9wdGlvbnNbJ2dycGMtbm9kZS5mbG93X2NvbnRyb2xfd2luZG93J107XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdGYWlsZWQgdG8gY29ubmVjdCc7XG4gICAgICAgICAgICBsZXQgcmVwb3J0ZWRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdyZW1vdGVTZXR0aW5ncycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBXSU5ET1dfVVBEQVRFIG5vdyB0byBhdm9pZCA2NSBLQiBzdGFydC13aW5kb3cgc3RhbGwuXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5XaW4gJiYgY29ubldpbiA+IGRlZmF1bHRXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vZGUg4omlIDE0LjE4XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnNldExvY2FsV2luZG93U2l6ZShjb25uV2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9sZGVyIE5vZGU6IGJ1bXAgYnkgdGhlIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGNvbm5XaW4gLSAoKF9hID0gc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRXaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmluY3JlbWVudFdpbmRvd1NpemUoZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEh0dHAyVHJhbnNwb3J0KHNlc3Npb24sIGFkZHJlc3MsIG9wdGlvbnMsIHJlbW90ZU5hbWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGNwQ29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgaHR0cF9wcm94eV8xLmdldFByb3hpZWRDb25uZWN0aW9uKShhZGRyZXNzLCBvcHRpb25zKS50aGVuKHByb3hpZWRTb2NrZXQgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3hpZWRTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZFNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNhbGxiYWNrID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXQuY29ubmVjdChhZGRyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KGFkZHJlc3MsIHNlY3VyZUNvbm5lY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGNwQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBzZWN1cmVDb25uZWN0UmVzdWx0ID0gbnVsbDtcbiAgICAgICAgY29uc3QgYWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgV2FpdGluZyBmb3Igc2VjdXJlQ29ubmVjdG9yIHRvIGJlIHJlYWR5Jyk7XG4gICAgICAgICAgICBhd2FpdCBzZWN1cmVDb25uZWN0b3Iud2FpdEZvclJlYWR5KCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGFkZHJlc3NTdHJpbmcgKyAnIHNlY3VyZUNvbm5lY3RvciBpcyByZWFkeScpO1xuICAgICAgICAgICAgdGNwQ29ubmVjdGlvbiA9IGF3YWl0IHRoaXMudGNwQ29ubmVjdChhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRjcENvbm5lY3Rpb24uc2V0Tm9EZWxheSgpO1xuICAgICAgICAgICAgdGhpcy50cmFjZShhZGRyZXNzU3RyaW5nICsgJyBFc3RhYmxpc2hlZCBUQ1AgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdCA9IGF3YWl0IHNlY3VyZUNvbm5lY3Rvci5jb25uZWN0KHRjcENvbm5lY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy50cmFjZShhZGRyZXNzU3RyaW5nICsgJyBFc3RhYmxpc2hlZCBzZWN1cmUgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2Vzc2lvbihzZWN1cmVDb25uZWN0UmVzdWx0LCBhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGNwQ29ubmVjdGlvbiA9PT0gbnVsbCB8fCB0Y3BDb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0Y3BDb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHNlY3VyZUNvbm5lY3RSZXN1bHQgPT09IG51bGwgfHwgc2VjdXJlQ29ubmVjdFJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSB0cnVlO1xuICAgICAgICAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yID0gSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseUri = parseUri;\nexports.splitHostPort = splitHostPort;\nexports.combineHostPort = combineHostPort;\nexports.uriToString = uriToString;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3],\n    };\n}\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith('[')) {\n        const hostEnd = path.indexOf(']');\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */\n        if (host.indexOf(':') === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === ':') {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString,\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host,\n            };\n        }\n    }\n    else {\n        const splitPath = path.split(':');\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */\n        if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1],\n                };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host: path,\n            };\n        }\n    }\n}\nfunction combineHostPort(hostPort) {\n    if (hostPort.port === undefined) {\n        return hostPort.host;\n    }\n    else {\n        // Only an IPv6 host should include a colon\n        if (hostPort.host.includes(':')) {\n            return `[${hostPort.host}]:${hostPort.port}`;\n        }\n        else {\n            return `${hostPort.host}:${hostPort.port}`;\n        }\n    }\n}\nfunction uriToString(uri) {\n    let result = '';\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + ':';\n    }\n    if (uri.authority !== undefined) {\n        result += '//' + uri.authority + '/';\n    }\n    result += uri.path;\n    return result;\n}\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjLElBQUksY0FBYztBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2l0YWxvLXNhbnRvcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzP2M5OWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VVcmkgPSBwYXJzZVVyaTtcbmV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IHNwbGl0SG9zdFBvcnQ7XG5leHBvcnRzLmNvbWJpbmVIb3N0UG9ydCA9IGNvbWJpbmVIb3N0UG9ydDtcbmV4cG9ydHMudXJpVG9TdHJpbmcgPSB1cmlUb1N0cmluZztcbi8qXG4gKiBUaGUgZ3JvdXBzIGNvcnJlc3BvbmQgdG8gVVJJIHBhcnRzIGFzIGZvbGxvd3M6XG4gKiAxLiBzY2hlbWVcbiAqIDIuIGF1dGhvcml0eVxuICogMy4gcGF0aFxuICovXG5jb25zdCBVUklfUkVHRVggPSAvXig/OihbQS1aYS16MC05Ky4tXSspOik/KD86XFwvXFwvKFteL10qKVxcLyk/KC4rKSQvO1xuZnVuY3Rpb24gcGFyc2VVcmkodXJpU3RyaW5nKSB7XG4gICAgY29uc3QgcGFyc2VkVXJpID0gVVJJX1JFR0VYLmV4ZWModXJpU3RyaW5nKTtcbiAgICBpZiAocGFyc2VkVXJpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnNlZFVyaVsxXSxcbiAgICAgICAgYXV0aG9yaXR5OiBwYXJzZWRVcmlbMl0sXG4gICAgICAgIHBhdGg6IHBhcnNlZFVyaVszXSxcbiAgICB9O1xufVxuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XG5mdW5jdGlvbiBzcGxpdEhvc3RQb3J0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xuICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSBwYXRoLnN1YnN0cmluZygxLCBob3N0RW5kKTtcbiAgICAgICAgLyogT25seSBhbiBJUHY2IGFkZHJlc3Mgc2hvdWxkIGJlIGluIGJyYWNrZXRlZCBub3RhdGlvbiwgYW5kIGFuIElQdjZcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cbiAgICAgICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gaG9zdEVuZCArIDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2hvc3RFbmQgKyAxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3QocG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiArcG9ydFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnOicpO1xuICAgICAgICAvKiBFeGFjdGx5IG9uZSBjb2xvbiBtZWFucyB0aGF0IHRoaXMgaXMgaG9zdDpwb3J0LiBaZXJvIGNvbG9ucyBtZWFucyB0aGF0XG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgd2l0aCBubyBwb3J0ICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHNwbGl0UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tYmluZUhvc3RQb3J0KGhvc3RQb3J0KSB7XG4gICAgaWYgKGhvc3RQb3J0LnBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaG9zdFBvcnQuaG9zdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE9ubHkgYW4gSVB2NiBob3N0IHNob3VsZCBpbmNsdWRlIGEgY29sb25cbiAgICAgICAgaWYgKGhvc3RQb3J0Lmhvc3QuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBbJHtob3N0UG9ydC5ob3N0fV06JHtob3N0UG9ydC5wb3J0fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7aG9zdFBvcnQuaG9zdH06JHtob3N0UG9ydC5wb3J0fWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1cmlUb1N0cmluZyh1cmkpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHVyaS5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gdXJpLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgaWYgKHVyaS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gJy8vJyArIHVyaS5hdXRob3JpdHkgKyAnLyc7XG4gICAgfVxuICAgIHJlc3VsdCArPSB1cmkucGF0aDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(action-browser)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(action-browser)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(action-browser)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(action-browser)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function (IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item) => {\n        for (const [key, value] of Object.entries(item)) {\n            switch (key) {\n                case 'uninterpreted_option':\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: [],\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, options, fileDescriptors),\n        responseType: createMessageDefinition(responseType, options, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, options, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n        serialize: createSerializer(message),\n        deserialize: createDeserializer(message, options)\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1Q0FBdUMsR0FBRyx1Q0FBdUMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsWUFBWTtBQUN6TSxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsdUVBQVk7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMscUdBQTJCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQywrR0FBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsK0RBQU07QUFDM0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Qsd0JBQXdCLEtBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdGFsby1zYW50b3MvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz9iZmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTkNZX1VOS05PV05cIl0gPSBcIklERU1QT1RFTkNZX1VOS05PV05cIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xufSkoSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCB8fCAoZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0ge30pKTtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIG9iai51bmludGVycHJldGVkX29wdGlvbi5wdXNoKGl0ZW0udW5pbnRlcnByZXRlZF9vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge1xuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaWRlbXBvdGVuY3lfbGV2ZWw6IElkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTixcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgb3B0aW9uczogbWFwTWV0aG9kT3B0aW9ucyhtZXRob2QucGFyc2VkT3B0aW9ucyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2UsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XG4gICAgICAgIGRlZlttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgICAgIHNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihtZXNzYWdlKSxcbiAgICAgICAgZGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihtZXNzYWdlLCBvcHRpb25zKVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbnVtRGVmaW5pdGlvbihlbnVtVHlwZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZW51bURlc2NyaXB0b3IgPSBlbnVtVHlwZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIEVudW1EZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBlbnVtRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChlbnVtRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG4vKipcbiAqIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5TZXJ2aWNlLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6XG4gKiBPcHRpb25zKTogU2VydmljZURlZmluaXRpb247IGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5UeXBlLFxuICogbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTogTWVzc2FnZVR5cGVEZWZpbml0aW9uOyBmdW5jdGlvblxuICogY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLkVudW0sIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6XG4gKiBFbnVtVHlwZURlZmluaXRpb247XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmljZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihvYmosIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1EZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBtaXNtYXRjaCBpbiByZWZsZWN0aW9uIG9iamVjdCBoYW5kbGluZycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yTGlzdCA9IHJvb3QudG9EZXNjcmlwdG9yKCdwcm90bzMnKS5maWxlO1xuICAgIGNvbnN0IGJ1ZmZlckxpc3QgPSBkZXNjcmlwdG9yTGlzdC5tYXAodmFsdWUgPT4gQnVmZmVyLmZyb20oZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclByb3RvLmVuY29kZSh2YWx1ZSkuZmluaXNoKCkpKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBvYmpdIG9mIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhyb290LCAnJykpIHtcbiAgICAgICAgZGVmW25hbWVdID0gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGJ1ZmZlckxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21EZXNjcmlwdG9yKGRlY29kZWREZXNjcmlwdG9yU2V0KTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIExvYWQgYSAucHJvdG8gZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqIEBwYXJhbSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZSBwYXRocyB0byBsb2FkLiBDYW4gYmUgYW4gYWJzb2x1dGUgcGF0aFxuICogICAgIG9yIHJlbGF0aXZlIHRvIGFuIGluY2x1ZGUgcGF0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmtlZXBDYXNlIFByZXNlcnZlIGZpZWxkIG5hbWVzLiBUaGUgZGVmYXVsdCBpcyB0byBjaGFuZ2UgdGhlbVxuICogICAgIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0gb3B0aW9ucy5sb25ncyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgbG9uZ2AgdmFsdWVzLlxuICogICAgIFZhbGlkIG9wdGlvbnMgYXJlIGBOdW1iZXJgIGFuZCBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gYSBgTG9uZ2Agb2JqZWN0IHR5cGVcbiAqICAgICBmcm9tIGEgbGlicmFyeS5cbiAqIEBwYXJhbSBvcHRpb25zLmVudW1zIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBlbnVtYCB2YWx1ZXMuXG4gKiAgICAgVGhlIG9ubHkgdmFsaWQgb3B0aW9uIGlzIGBTdHJpbmdgLiBEZWZhdWx0cyB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zLmJ5dGVzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBieXRlc2BcbiAqICAgICB2YWx1ZXMuIFZhbGlkIG9wdGlvbnMgYXJlIGBBcnJheWAgYW5kIGBTdHJpbmdgLiBUaGUgZGVmYXVsdCBpcyB0byB1c2VcbiAqICAgICBgQnVmZmVyYC5cbiAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRzIFNldCBkZWZhdWx0IHZhbHVlcyBvbiBvdXRwdXQgb2JqZWN0cy4gRGVmYXVsdHMgdG9cbiAqICAgICBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMuYXJyYXlzIFNldCBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgYXJyYXkgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vYmplY3RzIFNldCBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG9iamVjdCB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9uZW9mcyBTZXQgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHRvIHRoZSBwcmVzZW50IGZpZWxkJ3NcbiAqICAgICBuYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5qc29uIFJlcHJlc2VudCBJbmZpbml0eSBhbmQgTmFOIGFzIHN0cmluZ3MgaW4gZmxvYXQgZmllbGRzLFxuICogICAgIGFuZCBhdXRvbWF0aWNhbGx5IGRlY29kZSBnb29nbGUucHJvdG9idWYuQW55IHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVEaXJzIFBhdGhzIHRvIHNlYXJjaCBmb3IgaW1wb3J0ZWQgYC5wcm90b2AgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnMpKGZpbGVuYW1lLCBvcHRpb25zKS50aGVuKGxvYWRlZFJvb3QgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKShmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21KU09OKGpzb24pO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5mcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3Q7XG4oMCwgdXRpbF8xLmFkZENvbW1vblByb3RvcykoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(action-browser)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QjtBQUMzRixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsdUVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSx3Q0FBd0MsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFxQztBQUN2RSxpQ0FBaUMsbUJBQU8sQ0FBQyw4SEFBNEM7QUFDckYsb0NBQW9DLG1CQUFPLENBQUMsc0lBQWdEO0FBQzVGLDJCQUEyQixtQkFBTyxDQUFDLGtIQUFzQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXRhbG8tc2FudG9zLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvdXRpbC5qcz80ZTRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5mdW5jdGlvbiBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIGluY2x1ZGVQYXRocykge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZVBhdGggPSByb290LnJlc29sdmVQYXRoO1xuICAgIHJvb3QucmVzb2x2ZVBhdGggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGluY2x1ZGVQYXRocykge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCB0YXJnZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKGZ1bGxQYXRoLCBmcy5jb25zdGFudHMuUl9PSyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYCR7dGFyZ2V0fSBub3QgZm91bmQgaW4gYW55IG9mIHRoZSBpbmNsdWRlIHBhdGhzICR7aW5jbHVkZVBhdGhzfWApO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXNvbHZlUGF0aChvcmlnaW4sIHRhcmdldCk7XG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9ucyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IGF3YWl0IHJvb3QubG9hZChmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IGxvYWRQcm90b3NXaXRoT3B0aW9ucztcbmZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jO1xuLyoqXG4gKiBMb2FkIEdvb2dsZSdzIHdlbGwta25vd24gcHJvdG8gZmlsZXMgdGhhdCBhcmVuJ3QgZXhwb3NlZCBieSBQcm90b2J1Zi5qcy5cbiAqL1xuZnVuY3Rpb24gYWRkQ29tbW9uUHJvdG9zKCkge1xuICAgIC8vIFByb3RvYnVmLmpzIGV4cG9zZXM6IGFueSwgZHVyYXRpb24sIGVtcHR5LCBmaWVsZF9tYXNrLCBzdHJ1Y3QsIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd3JhcHBlcnMuIGNvbXBpbGVyL3BsdWdpbiBpcyBleGNsdWRlZCBpbiBQcm90b2J1Zi5qcyBhbmQgaGVyZS5cbiAgICAvLyBVc2luZyBjb25zdGFudCBzdHJpbmdzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdG9vbHMgbGlrZSBXZWJwYWNrXG4gICAgY29uc3QgYXBpRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2FwaS5qc29uJyk7XG4gICAgY29uc3QgZGVzY3JpcHRvckRlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLmpzb24nKTtcbiAgICBjb25zdCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0Lmpzb24nKTtcbiAgICBjb25zdCB0eXBlRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3R5cGUuanNvbicpO1xuICAgIFByb3RvYnVmLmNvbW1vbignYXBpJywgYXBpRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbignZGVzY3JpcHRvcicsIGRlc2NyaXB0b3JEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdzb3VyY2VfY29udGV4dCcsIHNvdXJjZUNvbnRleHREZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCd0eXBlJywgdHlwZURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbn1cbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gYWRkQ29tbW9uUHJvdG9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.14.0","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":">=12.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@grpc/proto-loader":"file:../proto-loader","@types/gulp":"^4.0.17","@types/gulp-mocha":"0.0.37","@types/lodash":"^4.14.202","@types/mocha":"^10.0.6","@types/ncp":"^2.0.8","@types/node":">=20.11.20","@types/pify":"^5.0.4","@types/semver":"^7.5.8","@typescript-eslint/eslint-plugin":"^7.1.0","@typescript-eslint/parser":"^7.1.0","@typescript-eslint/typescript-estree":"^7.1.0","clang-format":"^1.8.0","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.21","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.6.0","ts-node":"^10.9.2","typescript":"^5.3.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run copy-protos && npm run generate-types && npm run generate-test-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs proto/ proto/xds/ proto/protoc-gen-validate/ -O src/generated/ --grpcLib ../index channelz.proto xds/service/orca/v3/orca.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto echo_service.proto","copy-protos":"node ./copy-protos"},"dependencies":{"@grpc/proto-loader":"^0.8.0","@js-sdsl/ordered-map":"^4.4.2"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/**/*.proto","proto/**/LICENSE","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;